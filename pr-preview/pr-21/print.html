<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>x.uma</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Cross-Platform Unified Matcher API">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "rust";
            const default_dark_theme = "coal";
            window.path_to_searchindex_js = "searchindex-012befb0.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-ddcda326.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">x.uma</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/mox-nexus/x.uma" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="xuma"><a class="header" href="#xuma">x.uma</a></h1>
<blockquote>
<p><strong>Alpha (0.0.2)</strong> — API is stabilizing. Expect breaking changes before 1.0.</p>
</blockquote>
<p>One matcher engine. Five implementations. Same semantics everywhere.</p>
<p>x.uma implements the <a href="https://www.envoyproxy.io/docs/envoy/latest/api-v3/xds/type/matcher/v3/matcher.proto">xDS Unified Matcher API</a> — the same matching protocol Envoy uses at Google scale — across Rust, Python, and TypeScript.</p>
<p>Write matching rules once. Evaluate them in any language. Get the same answer every time.</p>
<pre><code>Context → DataInput → MatchingData → InputMatcher → bool
           domain-      erased         domain-
           specific                    agnostic
</code></pre>
<p>An <code>ExactMatcher</code> doesn’t know whether it’s matching HTTP paths, Claude Code hook events, or your custom domain. It matches <em>data</em>. The domain-specific part — extracting that data from your context — is a separate port.</p>
<h2 id="implementations"><a class="header" href="#implementations">Implementations</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Package</th><th>Language</th><th>What it is</th></tr>
</thead>
<tbody>
<tr><td><strong>rumi</strong></td><td>Rust</td><td>Core engine (reference implementation)</td></tr>
<tr><td><strong>xuma</strong></td><td>Python 3.12+</td><td>Pure Python, zero native deps beyond RE2</td></tr>
<tr><td><strong>xuma</strong></td><td>TypeScript/Bun</td><td>Pure TypeScript, zero native deps beyond RE2</td></tr>
<tr><td><strong>xuma-crust</strong></td><td>Python</td><td>Rust bindings via PyO3</td></tr>
<tr><td><strong>xuma-crust</strong></td><td>TypeScript</td><td>Rust bindings via WASM</td></tr>
</tbody>
</table>
</div>
<p>All five pass the same conformance test suite (~958 tests total).</p>
<h2 id="get-started"><a class="header" href="#get-started">Get Started</a></h2>
<ul>
<li><strong><a href="#rust-quick-start">Rust</a></strong> — <code>rumi</code> + <code>rumi-http</code> in your <code>Cargo.toml</code></li>
<li><strong><a href="#python-quick-start">Python</a></strong> — <code>uv add xuma</code>, build a matcher in 10 lines</li>
<li><strong><a href="#typescript-quick-start">TypeScript</a></strong> — <code>bun add xuma</code>, same API shape as Python</li>
</ul>
<h2 id="guarantees"><a class="header" href="#guarantees">Guarantees</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Guarantee</th><th>How</th></tr>
</thead>
<tbody>
<tr><td><strong>No ReDoS</strong></td><td>Rust <code>regex</code> crate (linear time). Python uses <code>google-re2</code>. TypeScript uses <code>re2js</code>.</td></tr>
<tr><td><strong>Bounded depth</strong></td><td>Max 32 levels of nesting, validated at config load</td></tr>
<tr><td><strong>Fail-closed</strong></td><td>Missing data → predicate returns <code>false</code>. Never matches by accident.</td></tr>
<tr><td><strong>Thread-safe</strong></td><td>All types are <code>Send + Sync</code> (Rust) / immutable (Python, TypeScript)</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rust-quick-start"><a class="header" href="#rust-quick-start">Rust Quick Start</a></h1>
<p>Build an HTTP route matcher with <code>rumi</code> and <code>rumi-http</code>.</p>
<h2 id="install"><a class="header" href="#install">Install</a></h2>
<pre><code class="language-toml">[dependencies]
rumi-core = "0.0.2"
rumi-http = "0.0.2"
</code></pre>
<p><code>rumi-http</code> brings in <code>rumi-core</code> as a transitive dependency. The lib name is <code>rumi</code>, so you write <code>use rumi::prelude::*</code>.</p>
<p>The CLI is a separate binary:</p>
<pre><code class="language-bash">cargo install --path rumi/cli
</code></pre>
<h2 id="write-a-config"><a class="header" href="#write-a-config">Write a Config</a></h2>
<p>Create <code>routes.yaml</code>:</p>
<pre><code class="language-yaml">matchers:
  - predicate:
      type: and
      predicates:
        - type: single
          input: { type_url: "xuma.http.v1.PathInput", config: {} }
          value_match: { Prefix: "/api" }
        - type: single
          input: { type_url: "xuma.http.v1.MethodInput", config: {} }
          value_match: { Exact: "GET" }
    on_match: { type: action, action: "api_read" }

  - predicate:
      type: and
      predicates:
        - type: single
          input: { type_url: "xuma.http.v1.PathInput", config: {} }
          value_match: { Prefix: "/api" }
        - type: single
          input: { type_url: "xuma.http.v1.MethodInput", config: {} }
          value_match: { Exact: "POST" }
    on_match: { type: action, action: "api_write" }

on_no_match: { type: action, action: "not_found" }
</code></pre>
<p>The <code>type_url</code> selects which data input to extract. <code>value_match</code> tests the extracted value. See <a href="#config-format">Config Format</a> for the full schema.</p>
<h2 id="validate-with-the-cli"><a class="header" href="#validate-with-the-cli">Validate with the CLI</a></h2>
<pre><code class="language-bash">$ rumi check http routes.yaml
Config valid
</code></pre>
<p>Catches unknown type URLs, invalid regex patterns, and depth limit violations at load time.</p>
<h2 id="run-with-the-cli"><a class="header" href="#run-with-the-cli">Run with the CLI</a></h2>
<pre><code class="language-bash">$ rumi run http routes.yaml --method GET --path /api/users
api_read

$ rumi run http routes.yaml --method POST --path /api/items
api_write

$ rumi run http routes.yaml --method DELETE --path /api/users
not_found
</code></pre>
<h2 id="load-in-your-app"><a class="header" href="#load-in-your-app">Load in Your App</a></h2>
<p>The same config file works programmatically via the Registry API:</p>
<pre><code class="language-rust ignore">use rumi::prelude::*;
use rumi_http::{HttpRequest, register_simple};

fn main() {
    // Build registry with HTTP inputs
    let registry = register_simple(RegistryBuilder::new()).build();

    // Load the config
    let yaml = std::fs::read_to_string("routes.yaml").unwrap();
    let config: MatcherConfig&lt;String&gt; = serde_yaml::from_str(&amp;yaml).unwrap();
    let matcher = registry.load_matcher(config).unwrap();

    // Evaluate
    let request = HttpRequest::builder()
        .method("GET")
        .path("/api/users")
        .build();
    assert_eq!(matcher.evaluate(&amp;request), Some("api_read".to_string()));
}</code></pre>
<p>The registry resolves <code>type_url</code> strings to concrete <code>DataInput</code> implementations at load time. Unknown type URLs produce an error listing available types.</p>
<h2 id="compiler-shorthand"><a class="header" href="#compiler-shorthand">Compiler Shorthand</a></h2>
<p>For type-safe HTTP matching without config files, use the Gateway API compiler:</p>
<pre><code class="language-rust ignore">use rumi::prelude::*;
use rumi_http::prelude::*;

// Declarative config
let routes = vec![
    HttpRouteMatch {
        path: Some(HttpPathMatch::Prefix { value: "/api".into() }),
        method: Some(HttpMethod::Get),
        ..Default::default()
    },
];

// One call compiles all routes into a matcher
let matcher = compile_route_matches(&amp;routes, "allowed", "denied").unwrap();

let req = HttpRequest::builder().method("GET").path("/api/users").build();
assert_eq!(matcher.evaluate(&amp;req), Some(&amp;"allowed"));</code></pre>
<p>This requires <code>rumi-http</code> with the <code>ext-proc</code> feature (enabled by default).</p>
<h2 id="claude-code-hooks"><a class="header" href="#claude-code-hooks">Claude Code Hooks</a></h2>
<p>rumi also matches Claude Code hook events. Create <code>hooks.yaml</code>:</p>
<pre><code class="language-yaml">matchers:
  - predicate:
      type: and
      predicates:
        - type: single
          input: { type_url: "xuma.claude.v1.EventInput", config: {} }
          value_match: { Exact: "PreToolUse" }
        - type: single
          input: { type_url: "xuma.claude.v1.ToolNameInput", config: {} }
          value_match: { Exact: "Bash" }
        - type: single
          input: { type_url: "xuma.claude.v1.ArgumentInput", config: { name: "command" } }
          value_match: { Contains: "rm -rf" }
    on_match: { type: action, action: "block" }

on_no_match: { type: action, action: "allow" }
</code></pre>
<pre><code class="language-bash">$ rumi check claude hooks.yaml
Config valid

$ rumi run claude hooks.yaml --event PreToolUse --tool Bash --arg command="rm -rf /"
block

$ rumi run claude hooks.yaml --event PreToolUse --tool Read
allow
</code></pre>
<h2 id="safety"><a class="header" href="#safety">Safety</a></h2>
<ul>
<li><strong>ReDoS protection</strong> – the <code>regex</code> crate guarantees linear-time matching. No backtracking.</li>
<li><strong>Depth limits</strong> – nested matchers capped at 32 levels, validated at construction.</li>
<li><strong>No unsafe in core</strong> – all <code>Send + Sync</code> is compiler-derived.</li>
</ul>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<ul>
<li><a href="#the-matching-pipeline">The Matching Pipeline</a> – how data flows through the matcher</li>
<li><a href="#cli-reference-rumi">CLI Reference</a> – all commands and domains</li>
<li><a href="#config-format">Config Format</a> – full config schema and type URL tables</li>
<li><a href="#api-reference">API Reference</a> – generated docs for all languages</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="python-quick-start"><a class="header" href="#python-quick-start">Python Quick Start</a></h1>
<p>Build an HTTP route matcher with <code>xuma</code> (pure Python) or <code>xuma-crust</code> (Rust-backed).</p>
<h2 id="install-1"><a class="header" href="#install-1">Install</a></h2>
<pre><code class="language-bash"># Pure Python
uv add xuma

# Rust-backed (faster, same API surface)
uv add xuma-crust
</code></pre>
<p>Requires Python 3.12+. <code>xuma</code> uses <code>google-re2</code> for linear-time regex.</p>
<h2 id="write-a-config-1"><a class="header" href="#write-a-config-1">Write a Config</a></h2>
<p>Create <code>routes.yaml</code>:</p>
<pre><code class="language-yaml">matchers:
  - predicate:
      type: and
      predicates:
        - type: single
          input: { type_url: "xuma.http.v1.PathInput", config: {} }
          value_match: { Prefix: "/api" }
        - type: single
          input: { type_url: "xuma.http.v1.MethodInput", config: {} }
          value_match: { Exact: "GET" }
    on_match: { type: action, action: "api_read" }

  - predicate:
      type: single
      input: { type_url: "xuma.http.v1.PathInput", config: {} }
      value_match: { Exact: "/health" }
    on_match: { type: action, action: "health" }

on_no_match: { type: action, action: "not_found" }
</code></pre>
<h2 id="validate-with-the-cli-1"><a class="header" href="#validate-with-the-cli-1">Validate with the CLI</a></h2>
<pre><code class="language-bash">$ rumi check http routes.yaml
Config valid
</code></pre>
<h2 id="run-with-the-cli-1"><a class="header" href="#run-with-the-cli-1">Run with the CLI</a></h2>
<pre><code class="language-bash">$ rumi run http routes.yaml --method GET --path /api/users
api_read

$ rumi run http routes.yaml --method GET --path /health
health

$ rumi run http routes.yaml --method DELETE --path /other
not_found
</code></pre>
<h2 id="load-in-your-app-xuma"><a class="header" href="#load-in-your-app-xuma">Load in Your App (xuma)</a></h2>
<p>The pure Python implementation loads the same config:</p>
<pre><code class="language-python">import yaml
from xuma import Registry, RegistryBuilder
from xuma.http import HttpRequest, register_http

# Build registry with HTTP inputs
builder = RegistryBuilder()
register_http(builder)
registry = builder.build()

# Load config
with open("routes.yaml") as f:
    config = yaml.safe_load(f)
matcher = registry.load_matcher(config)

# Evaluate
request = HttpRequest(method="GET", raw_path="/api/users")
assert matcher.evaluate(request) == "api_read"
</code></pre>
<h2 id="load-in-your-app-xuma-crust"><a class="header" href="#load-in-your-app-xuma-crust">Load in Your App (xuma-crust)</a></h2>
<p>The Rust-backed bindings use the same config format:</p>
<pre><code class="language-python">from xuma_crust import load_http_matcher, HttpMatcher

# Load config and build matcher in one call
matcher: HttpMatcher = load_http_matcher("routes.yaml")

# Evaluate with method + path
assert matcher.evaluate("GET", "/api/users") == "api_read"
assert matcher.evaluate("DELETE", "/other") == "not_found"
</code></pre>
<p><code>xuma-crust</code> is 10-100x faster than pure Python for evaluation.</p>
<h2 id="compiler-shorthand-1"><a class="header" href="#compiler-shorthand-1">Compiler Shorthand</a></h2>
<p>For type-safe HTTP matching without config files:</p>
<pre><code class="language-python">from xuma.http import (
    HttpRouteMatch,
    HttpPathMatch,
    HttpRequest,
    compile_route_matches,
)

routes = [
    HttpRouteMatch(
        path=HttpPathMatch(type="PathPrefix", value="/api"),
        method="GET",
    ),
    HttpRouteMatch(
        path=HttpPathMatch(type="PathPrefix", value="/admin"),
        method="POST",
    ),
]

matcher = compile_route_matches(
    matches=routes,
    action="allowed",
    on_no_match="denied",
)

assert matcher.evaluate(HttpRequest(method="GET", raw_path="/api/users")) == "allowed"
assert matcher.evaluate(HttpRequest(method="DELETE", raw_path="/api/users")) == "denied"
</code></pre>
<p>Within a single <code>HttpRouteMatch</code>, all conditions are ANDed. Multiple routes are ORed. First match wins.</p>
<h2 id="safety-1"><a class="header" href="#safety-1">Safety</a></h2>
<ul>
<li><strong>ReDoS protection</strong> – <code>google-re2</code> guarantees linear-time regex matching.</li>
<li><strong>Immutable</strong> – all types are <code>frozen=True</code> dataclasses.</li>
<li><strong>Depth limits</strong> – nested matchers capped at 32 levels.</li>
<li><strong>Fail-closed</strong> – missing headers or query params return <code>None</code> from <code>DataInput</code>, which makes the predicate evaluate to <code>False</code>.</li>
</ul>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<ul>
<li><a href="#the-matching-pipeline">The Matching Pipeline</a> – how data flows through the matcher</li>
<li><a href="#cli-reference-rumi">CLI Reference</a> – all commands and domains</li>
<li><a href="#config-format">Config Format</a> – full config schema and type URL tables</li>
<li><a href="#api-reference">API Reference</a> – generated docs for all languages</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="typescript-quick-start"><a class="header" href="#typescript-quick-start">TypeScript Quick Start</a></h1>
<p>Build an HTTP route matcher with <code>xuma</code> (pure TypeScript) or <code>xuma-crust</code> (WASM-backed).</p>
<h2 id="install-2"><a class="header" href="#install-2">Install</a></h2>
<pre><code class="language-bash"># Pure TypeScript
bun add xuma

# WASM-backed (faster, same API surface)
bun add xuma-crust
</code></pre>
<p>Requires Bun runtime. <code>xuma</code> uses <code>re2js</code> for linear-time regex.</p>
<h2 id="write-a-config-2"><a class="header" href="#write-a-config-2">Write a Config</a></h2>
<p>Create <code>routes.yaml</code>:</p>
<pre><code class="language-yaml">matchers:
  - predicate:
      type: and
      predicates:
        - type: single
          input: { type_url: "xuma.http.v1.PathInput", config: {} }
          value_match: { Prefix: "/api" }
        - type: single
          input: { type_url: "xuma.http.v1.MethodInput", config: {} }
          value_match: { Exact: "GET" }
    on_match: { type: action, action: "api_read" }

  - predicate:
      type: single
      input: { type_url: "xuma.http.v1.PathInput", config: {} }
      value_match: { Exact: "/health" }
    on_match: { type: action, action: "health" }

on_no_match: { type: action, action: "not_found" }
</code></pre>
<h2 id="validate-with-the-cli-2"><a class="header" href="#validate-with-the-cli-2">Validate with the CLI</a></h2>
<pre><code class="language-bash">$ rumi check http routes.yaml
Config valid
</code></pre>
<h2 id="run-with-the-cli-2"><a class="header" href="#run-with-the-cli-2">Run with the CLI</a></h2>
<pre><code class="language-bash">$ rumi run http routes.yaml --method GET --path /api/users
api_read

$ rumi run http routes.yaml --method GET --path /health
health

$ rumi run http routes.yaml --method DELETE --path /other
not_found
</code></pre>
<h2 id="load-in-your-app-xuma-1"><a class="header" href="#load-in-your-app-xuma-1">Load in Your App (xuma)</a></h2>
<p>The pure TypeScript implementation loads the same config:</p>
<pre><code class="language-typescript">import { RegistryBuilder, registerHttp, type MatcherConfig } from "xuma";
import { HttpRequest } from "xuma/http";
import { parse } from "yaml";

// Build registry with HTTP inputs
const builder = new RegistryBuilder();
registerHttp(builder);
const registry = builder.build();

// Load config
const yaml = await Bun.file("routes.yaml").text();
const config: MatcherConfig = parse(yaml);
const matcher = registry.loadMatcher(config);

// Evaluate
const request = new HttpRequest("GET", "/api/users");
console.assert(matcher.evaluate(request) === "api_read");
</code></pre>
<h2 id="load-in-your-app-xuma-crust-1"><a class="header" href="#load-in-your-app-xuma-crust-1">Load in Your App (xuma-crust)</a></h2>
<p>The WASM-backed bindings use the same config format:</p>
<pre><code class="language-typescript">import { loadHttpMatcher, type HttpMatcher } from "xuma-crust";

// Load config and build matcher in one call
const matcher: HttpMatcher = loadHttpMatcher("routes.yaml");

// Evaluate with method + path
console.assert(matcher.evaluate("GET", "/api/users") === "api_read");
console.assert(matcher.evaluate("DELETE", "/other") === "not_found");
</code></pre>
<p><code>xuma-crust</code> is 3-10x faster than pure TypeScript for evaluation.</p>
<h2 id="compiler-shorthand-2"><a class="header" href="#compiler-shorthand-2">Compiler Shorthand</a></h2>
<p>For type-safe HTTP matching without config files:</p>
<pre><code class="language-typescript">import { compileRouteMatches, HttpRequest } from "xuma/http";
import type { HttpRouteMatch } from "xuma/http";

const routes: HttpRouteMatch[] = [
  {
    path: { type: "PathPrefix", value: "/api" },
    method: "GET",
  },
  {
    path: { type: "PathPrefix", value: "/admin" },
    method: "POST",
  },
];

const matcher = compileRouteMatches(routes, "allowed", "denied");

console.assert(matcher.evaluate(new HttpRequest("GET", "/api/users")) === "allowed");
console.assert(matcher.evaluate(new HttpRequest("DELETE", "/api/users")) === "denied");
</code></pre>
<p>Within a single <code>HttpRouteMatch</code>, all conditions are ANDed. Multiple routes are ORed. First match wins.</p>
<h2 id="integration-bun-http-server"><a class="header" href="#integration-bun-http-server">Integration: Bun HTTP Server</a></h2>
<pre><code class="language-typescript">import { compileRouteMatches, HttpRequest } from "xuma/http";

const matcher = compileRouteMatches(
  [{ path: { type: "PathPrefix", value: "/api" }, method: "GET" }],
  "allowed",
  "denied",
);

Bun.serve({
  port: 3000,
  fetch(req) {
    const url = new URL(req.url);
    const request = new HttpRequest(
      req.method,
      url.pathname + url.search,
      Object.fromEntries(req.headers),
    );
    if (matcher.evaluate(request) === "denied") {
      return new Response("Not found", { status: 404 });
    }
    return new Response("OK");
  },
});
</code></pre>
<h2 id="safety-2"><a class="header" href="#safety-2">Safety</a></h2>
<ul>
<li><strong>ReDoS protection</strong> – <code>re2js</code> guarantees linear-time regex matching.</li>
<li><strong>Immutable</strong> – all types use <code>readonly</code> fields.</li>
<li><strong>Depth limits</strong> – nested matchers capped at 32 levels.</li>
<li><strong>Fail-closed</strong> – missing data from <code>DataInput</code> returns <code>null</code>, which makes the predicate evaluate to <code>false</code>.</li>
</ul>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<ul>
<li><a href="#the-matching-pipeline">The Matching Pipeline</a> – how data flows through the matcher</li>
<li><a href="#cli-reference-rumi">CLI Reference</a> – all commands and domains</li>
<li><a href="#config-format">Config Format</a> – full config schema and type URL tables</li>
<li><a href="#api-reference">API Reference</a> – generated docs for all languages</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="the-matching-pipeline"><a class="header" href="#the-matching-pipeline">The Matching Pipeline</a></h1>
<p>Every evaluation follows the same flow. Understanding this pipeline is understanding x.uma.</p>
<h2 id="the-flow"><a class="header" href="#the-flow">The Flow</a></h2>
<pre><code class="language-text">Context (your data)
    ↓
DataInput.get()          ← extract a value from the context
    ↓
MatchingData             ← type-erased: string | int | bool | bytes | null
    ↓
InputMatcher.matches()   ← compare the value
    ↓
bool                     ← did it match?
    ↓
Predicate.evaluate()     ← combine with other conditions (AND/OR/NOT)
    ↓
bool                     ← combined result
    ↓
Matcher.evaluate()       ← find the first matching rule
    ↓
Action                   ← your decision (or null if nothing matched)
</code></pre>
<p>Two things to notice:</p>
<ol>
<li>
<p><strong>The pipeline splits at <code>MatchingData</code>.</strong> Everything above is domain-specific (knows about your context type). Everything below is domain-agnostic (works with any domain).</p>
</li>
<li>
<p><strong>The same <code>InputMatcher</code> works everywhere.</strong> An <code>ExactMatcher</code> doesn’t care whether the string came from an HTTP path or a Claude Code tool name. It matches strings.</p>
</li>
</ol>
<h2 id="concrete-example"><a class="header" href="#concrete-example">Concrete Example</a></h2>
<p>Route <code>GET /api/users</code> to the API backend:</p>
<p><strong>Python:</strong></p>
<pre><code class="language-python">from xuma import SinglePredicate, PrefixMatcher, Matcher, FieldMatcher, Action
from xuma.http import HttpRequest, PathInput

# DataInput: extract the path from the request
# InputMatcher: check if the path starts with /api
predicate = SinglePredicate(
    input=PathInput(),            # domain-specific
    matcher=PrefixMatcher("/api") # domain-agnostic
)

matcher = Matcher(
    matcher_list=(
        FieldMatcher(predicate=predicate, on_match=Action("api_backend")),
    ),
)

request = HttpRequest(method="GET", raw_path="/api/users")
assert matcher.evaluate(request) == "api_backend"
</code></pre>
<p><strong>Rust:</strong></p>
<pre><code class="language-rust ignore">use rumi::prelude::*;
use rumi_http::*;

let predicate = Predicate::Single(SinglePredicate::new(
    Box::new(SimplePathInput),         // domain-specific
    Box::new(PrefixMatcher::new("/api")), // domain-agnostic
));

let matcher: Matcher&lt;HttpRequest, &amp;str&gt; = Matcher::new(
    vec![FieldMatcher::new(predicate, OnMatch::Action("api_backend"))],
    None,
);

let request = HttpRequest::builder().method("GET").path("/api/users").build();
assert_eq!(matcher.evaluate(&amp;request), Some(&amp;"api_backend"));</code></pre>
<p><strong>TypeScript:</strong></p>
<pre><code class="language-typescript">import { SinglePredicate, PrefixMatcher, Matcher, FieldMatcher, Action } from "xuma";
import { HttpRequest, PathInput } from "xuma/http";

const predicate = new SinglePredicate(
  new PathInput(),             // domain-specific
  new PrefixMatcher("/api"),   // domain-agnostic
);

const matcher = new Matcher(
  [new FieldMatcher(predicate, new Action("api_backend"))],
);

const request = new HttpRequest("GET", "/api/users");
console.assert(matcher.evaluate(request) === "api_backend");
</code></pre>
<p>Same structure in all three languages. Same result.</p>
<h2 id="the-same-pipeline-different-domain"><a class="header" href="#the-same-pipeline-different-domain">The Same Pipeline, Different Domain</a></h2>
<p>The power of this split: the same <code>PrefixMatcher</code> works for HTTP paths and custom event types.</p>
<pre><code class="language-python">from dataclasses import dataclass
from xuma import SinglePredicate, PrefixMatcher, Matcher, FieldMatcher, Action, MatchingData

# Custom context
@dataclass(frozen=True)
class CloudEvent:
    type: str
    source: str

# Custom DataInput — extract the event type
@dataclass(frozen=True)
class EventTypeInput:
    def get(self, ctx: CloudEvent) -&gt; MatchingData:
        return ctx.type

# Use the SAME PrefixMatcher — it doesn't know about CloudEvent
predicate = SinglePredicate(
    input=EventTypeInput(),
    matcher=PrefixMatcher("com.example."),
)

matcher = Matcher(
    matcher_list=(
        FieldMatcher(predicate=predicate, on_match=Action("handle_event")),
    ),
)

event = CloudEvent(type="com.example.user.created", source="api")
assert matcher.evaluate(event) == "handle_event"
</code></pre>
<p><code>PrefixMatcher</code> operates on <code>MatchingData</code> (the erased string), not on <code>CloudEvent</code> or <code>HttpRequest</code>. Domain adapters (<code>PathInput</code>, <code>EventTypeInput</code>) are context-specific. Matchers are universal.</p>
<h2 id="pipeline-stages"><a class="header" href="#pipeline-stages">Pipeline Stages</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Stage</th><th>Role</th><th>Generic?</th><th>Examples</th></tr>
</thead>
<tbody>
<tr><td><strong>Context</strong></td><td>Your domain data</td><td>Yes (<code>Ctx</code>)</td><td><code>HttpRequest</code>, <code>HookContext</code>, your type</td></tr>
<tr><td><strong>DataInput</strong></td><td>Extract a value</td><td>Yes (<code>Ctx</code>)</td><td><code>PathInput</code>, <code>ToolNameInput</code>, your input</td></tr>
<tr><td><strong>MatchingData</strong></td><td>Type-erased value</td><td>No</td><td><code>string</code>, <code>int</code>, <code>bool</code>, <code>bytes</code>, <code>null</code></td></tr>
<tr><td><strong>InputMatcher</strong></td><td>Match the value</td><td>No</td><td><code>ExactMatcher</code>, <code>PrefixMatcher</code>, <code>RegexMatcher</code></td></tr>
<tr><td><strong>Predicate</strong></td><td>Boolean logic</td><td>Yes (<code>Ctx</code>)</td><td><code>SinglePredicate</code>, <code>And</code>, <code>Or</code>, <code>Not</code></td></tr>
<tr><td><strong>Matcher</strong></td><td>First-match-wins</td><td>Yes (<code>Ctx</code>, <code>A</code>)</td><td>Routes to actions</td></tr>
<tr><td><strong>Action</strong></td><td>Your decision</td><td>Yes (<code>A</code>)</td><td>Strings, enums, structs — anything</td></tr>
</tbody>
</table>
</div>
<p>The boundary at <code>MatchingData</code> is what makes the engine domain-agnostic. Cross it once, and every matcher works for every domain.</p>
<h2 id="next"><a class="header" href="#next">Next</a></h2>
<ul>
<li><a href="#type-erasure-and-ports">Type Erasure and Ports</a> — why <code>InputMatcher</code> is non-generic</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="type-erasure-and-ports"><a class="header" href="#type-erasure-and-ports">Type Erasure and Ports</a></h1>
<p>Why does the same <code>ExactMatcher</code> work for HTTP headers and custom event types? Because type erasure happens at the data level, not the matcher level.</p>
<h2 id="the-problem"><a class="header" href="#the-problem">The Problem</a></h2>
<p>If <code>InputMatcher</code> were generic over the context type, every domain would need its own matcher implementations:</p>
<pre><code class="language-python"># If InputMatcher were generic (DON'T DO THIS)
class InputMatcher[Ctx]:
    def matches(self, ctx: Ctx) -&gt; bool: ...

# You'd need separate matchers for each domain
http_matcher = ExactMatcher[HttpRequest]("/api")
event_matcher = ExactMatcher[CloudEvent]("com.example")
# Can't put them in the same registry. No code reuse.
</code></pre>
<h2 id="the-solution"><a class="header" href="#the-solution">The Solution</a></h2>
<p>Erase the type at the <strong>data level</strong>. Extract the value first, then match the erased value:</p>
<pre><code class="language-python"># DataInput is generic — knows about the context
class DataInput[Ctx]:
    def get(self, ctx: Ctx) -&gt; MatchingData: ...

# InputMatcher is NOT generic — knows only about MatchingData
class InputMatcher:
    def matches(self, value: MatchingData) -&gt; bool: ...
</code></pre>
<p>Now one <code>ExactMatcher</code> works everywhere:</p>
<pre><code class="language-python"># HTTP path matching
path_pred = SinglePredicate(input=PathInput(), matcher=ExactMatcher("/api"))

# Event type matching — SAME ExactMatcher
event_pred = SinglePredicate(input=EventTypeInput(), matcher=ExactMatcher("/api"))
</code></pre>
<h2 id="matchingdata-the-bridge"><a class="header" href="#matchingdata-the-bridge">MatchingData: The Bridge</a></h2>
<p><code>MatchingData</code> is the boundary between domain-specific and domain-agnostic code. Same name in all three implementations:</p>
<p><strong>Rust:</strong></p>
<pre><code class="language-rust ignore">pub enum MatchingData {
    None,
    String(String),
    Int(i64),
    Bool(bool),
    Bytes(Vec&lt;u8&gt;),
    Custom(Box&lt;dyn CustomMatchData&gt;),
}</code></pre>
<p><strong>Python:</strong></p>
<pre><code class="language-python">type MatchingData = str | int | bool | bytes | None
</code></pre>
<p><strong>TypeScript:</strong></p>
<pre><code class="language-typescript">type MatchingData = string | number | boolean | Uint8Array | null;
</code></pre>
<p>Rust uses an enum. Python and TypeScript use union types. Same concept, idiomatic syntax.</p>
<h2 id="the-two-ports"><a class="header" href="#the-two-ports">The Two Ports</a></h2>
<p>Type erasure creates two ports — the seams where domain-specific and domain-agnostic code meet:</p>
<pre><code class="language-text">┌─────────────────────────────────────────┐
│         Domain-Specific Layer           │
│   PathInput, HeaderInput, ToolNameInput │
│   (knows about Ctx)                     │
└──────────────┬──────────────────────────┘
               │ get() returns MatchingData
               ↓
┌──────────────▼──────────────────────────┐
│         Domain-Agnostic Layer           │
│   ExactMatcher, PrefixMatcher, Regex... │
│   (knows only about MatchingData)       │
└─────────────────────────────────────────┘
</code></pre>
<p><strong>Extraction port (<code>DataInput</code>)</strong> — converts <code>Ctx</code> into <code>MatchingData</code>. Domain-specific. You write one per field you want to match.</p>
<p><strong>Matching port (<code>InputMatcher</code>)</strong> — converts <code>MatchingData</code> into <code>bool</code>. Domain-agnostic. x.uma ships five: <code>ExactMatcher</code>, <code>PrefixMatcher</code>, <code>SuffixMatcher</code>, <code>ContainsMatcher</code>, <code>RegexMatcher</code>.</p>
<h2 id="cross-language-comparison"><a class="header" href="#cross-language-comparison">Cross-Language Comparison</a></h2>
<p>The same architecture in all three languages:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Concept</th><th>Rust</th><th>Python</th><th>TypeScript</th></tr>
</thead>
<tbody>
<tr><td>Erased data</td><td><code>enum MatchingData</code></td><td><code>type MatchingData</code> (union)</td><td><code>type MatchingData</code> (union)</td></tr>
<tr><td>Extraction port</td><td><code>trait DataInput&lt;Ctx&gt;</code></td><td><code>Protocol[Ctx]</code></td><td><code>interface DataInput&lt;Ctx&gt;</code></td></tr>
<tr><td>Matching port</td><td><code>trait InputMatcher</code></td><td><code>Protocol</code></td><td><code>interface InputMatcher</code></td></tr>
<tr><td>Predicate tree</td><td><code>enum Predicate&lt;Ctx&gt;</code></td><td><code>type Predicate[Ctx]</code> (union)</td><td><code>type Predicate&lt;Ctx&gt;</code> (union)</td></tr>
<tr><td>Pattern match</td><td><code>match</code> expression</td><td><code>match</code>/<code>case</code></td><td><code>instanceof</code> checks</td></tr>
<tr><td>Immutability</td><td>Owned types</td><td><code>@dataclass(frozen=True)</code></td><td><code>readonly</code> fields</td></tr>
</tbody>
</table>
</div>
<h2 id="the-none-convention"><a class="header" href="#the-none-convention">The None Convention</a></h2>
<p>When a <code>DataInput</code> returns <code>None</code>/<code>null</code> (data not present), the predicate evaluates to <code>false</code> without calling the matcher. This is enforced across all implementations.</p>
<pre><code class="language-python">from xuma import SinglePredicate, ExactMatcher
from xuma.http import HttpRequest, HeaderInput

predicate = SinglePredicate(
    input=HeaderInput("x-api-key"),
    matcher=ExactMatcher("secret"),
)

# Header not present → DataInput returns None → predicate returns False
request = HttpRequest(headers={})
assert predicate.evaluate(request) == False
</code></pre>
<p>The matcher never sees <code>None</code>. Missing data is handled upstream. This is a security guarantee: missing data never accidentally matches.</p>
<h2 id="next-1"><a class="header" href="#next-1">Next</a></h2>
<ul>
<li><a href="#the-matching-pipeline">The Matching Pipeline</a> — how data flows through the full evaluation</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>x.uma makes one bet: the boundary between “what data do I have?” and “how do I match it?” is the most valuable seam in a matcher engine.</p>
<h2 id="the-bet"><a class="header" href="#the-bet">The Bet</a></h2>
<p>Every matcher engine faces a choice. Couple the matching logic to the domain, and you get performance and simplicity — but you rebuild the engine for every new domain. Decouple them, and you get reuse — but you pay in abstraction tax and runtime indirection.</p>
<p>x.uma’s answer: erase the type at the <strong>data level</strong>, not the matcher level. One <code>ExactMatcher</code> works for HTTP paths, Claude Code tool names, gRPC service identifiers, and types that don’t exist yet.</p>
<pre><code class="language-text">Context (your data)
    ↓
DataInput.get()          ← knows your type, returns erased data
    ↓
MatchingData             ← string | int | bool | bytes | null
    ↓
InputMatcher.matches()   ← doesn't know your type, doesn't need to
    ↓
bool
</code></pre>
<p>The split happens at <code>MatchingData</code>. Above it, domain-specific code that knows about <code>HttpRequest</code> or <code>HookContext</code>. Below it, domain-agnostic matchers that work with primitives. This is the seam.</p>
<h2 id="why-this-works"><a class="header" href="#why-this-works">Why This Works</a></h2>
<p>The insight comes from Envoy, where it runs at Google scale. Envoy’s xDS Unified Matcher API uses the same split — domain-specific inputs feed type-erased data into generic matchers. x.uma implements these semantics in Rust, Python, and TypeScript.</p>
<p>What the seam buys:</p>
<p><strong>Write a matcher once, use it everywhere.</strong> <code>PrefixMatcher("/api")</code> matches HTTP paths, event source URIs, file paths — anything that produces a string through <code>MatchingData</code>. Five string matchers (<code>Exact</code>, <code>Prefix</code>, <code>Suffix</code>, <code>Contains</code>, <code>Regex</code>) cover most matching needs across all domains.</p>
<p><strong>Add a domain without touching core.</strong> HTTP matching, Claude Code hooks, and the test domain all plug in by implementing <code>DataInput</code> — a single method that extracts a value from the context. The core engine never changes.</p>
<p><strong>Share config across languages.</strong> The same JSON/YAML config produces the same matcher tree in Rust, Python, and TypeScript. <code>MatchingData</code> is the same name, same semantics, in all three.</p>
<h2 id="the-shape"><a class="header" href="#the-shape">The Shape</a></h2>
<pre><code class="language-text">┌─────────────────────────────────────────┐
│           Domain Adapters               │
│   xuma.http    xuma.claude    xuma.test │
│   (DataInput implementations)           │
└──────────────────┬──────────────────────┘
                   │  get() → MatchingData
                   ↓
┌──────────────────▼──────────────────────┐
│           Core Engine                   │
│   Matcher · Predicate · InputMatcher    │
│   (domain-agnostic, immutable)          │
└─────────────────────────────────────────┘
</code></pre>
<p>Two ports define the boundary:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Port</th><th>Direction</th><th>Generic?</th><th>You implement</th></tr>
</thead>
<tbody>
<tr><td><strong>DataInput</strong></td><td>Domain → Core</td><td>Yes (knows <code>Ctx</code>)</td><td>One per field you want to match</td></tr>
<tr><td><strong>InputMatcher</strong></td><td>Core → bool</td><td>No (knows <code>MatchingData</code>)</td><td>Rarely — five ship with x.uma</td></tr>
</tbody>
</table>
</div>
<p>Domain adapters implement <code>DataInput</code>. The core ships <code>InputMatcher</code> implementations. <code>SinglePredicate</code> wires one to the other.</p>
<h2 id="aces"><a class="header" href="#aces">ACES</a></h2>
<p>The architecture follows four properties:</p>
<p><strong>Adaptable.</strong> New domains plug in without modifying core. HTTP matching didn’t require changes to the predicate engine. Claude Code hooks didn’t require changes to HTTP matching. Each domain is independent.</p>
<p><strong>Composable.</strong> Predicates compose with AND, OR, NOT. Matchers nest up to 32 levels deep. A matcher’s action can be another matcher, creating trees of arbitrary complexity from simple building blocks.</p>
<p><strong>Extensible.</strong> <code>TypedExtensionConfig</code> from the xDS protobuf spec is the extension seam. Every input and action is identified by a type URL (<code>xuma.http.v1.PathInput</code>, <code>xuma.claude.v1.ToolNameInput</code>). New types register without modifying existing ones.</p>
<p><strong>Sustainable.</strong> Core is stable. Growth happens at the edges. Adding a domain means adding <code>DataInput</code> implementations and a compiler — not touching <code>Matcher</code>, <code>Predicate</code>, or <code>InputMatcher</code>. The architecture sustains extension without rewrites.</p>
<h2 id="what-core-owns"><a class="header" href="#what-core-owns">What Core Owns</a></h2>
<p>The core engine (<code>rumi</code> in Rust, <code>xuma</code> in Python/TypeScript) provides:</p>
<ul>
<li><strong>Matcher</strong> — first-match-wins evaluation over a list of field matchers</li>
<li><strong>Predicate</strong> — Boolean tree (Single, And, Or, Not) with short-circuit evaluation</li>
<li><strong>SinglePredicate</strong> — pairs a <code>DataInput</code> with an <code>InputMatcher</code></li>
<li><strong>MatchingData</strong> — the type-erased bridge (<code>string | int | bool | bytes | null</code>)</li>
<li><strong>InputMatcher</strong> — five string matchers plus <code>BoolMatcher</code></li>
<li><strong>OnMatch</strong> — action XOR nested matcher (illegal states unrepresentable)</li>
<li><strong>Depth/width limits</strong> — MAX_DEPTH=32, MAX_FIELD_MATCHERS=256</li>
<li><strong>Registry</strong> — immutable type registry for config-driven construction</li>
<li><strong>Trace</strong> — step-by-step evaluation debugging</li>
</ul>
<p>Core does not own domain knowledge. It does not know what an HTTP request is, what a Claude Code hook event is, or what your custom context type contains. It matches erased values.</p>
<h2 id="what-domains-own"><a class="header" href="#what-domains-own">What Domains Own</a></h2>
<p>Each domain provides:</p>
<ul>
<li><strong>Context type</strong> — <code>HttpRequest</code>, <code>HookContext</code>, your type</li>
<li><strong>DataInput implementations</strong> — extractors for each matchable field</li>
<li><strong>Compiler</strong> — transforms domain-specific config into matcher trees</li>
<li><strong>Registry function</strong> — registers domain inputs with the type registry</li>
</ul>
<p>The compiler is the user-facing API. Instead of manually constructing predicate trees, you write:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// HTTP: Gateway API config → matcher
let matcher = compile_route_matches(&amp;routes, "allowed", "denied");

// Claude: hook rules → matcher
let matcher = rule.compile("block")?;
<span class="boring">}</span></code></pre>
<p>Compilers are syntactic sugar over the core engine. They produce the same <code>Matcher&lt;Ctx, A&gt;</code> you’d build by hand.</p>
<h2 id="matcher-engine-not-policy-engine"><a class="header" href="#matcher-engine-not-policy-engine">Matcher Engine, Not Policy Engine</a></h2>
<p>x.uma is a matcher engine. It finds the first matching rule and returns an action. It does not interpret that action.</p>
<p>The generic <code>A</code> in <code>Matcher&lt;Ctx, A&gt;</code> is the boundary. <code>A</code> can be a string, an enum, a struct — anything. Core never inspects it. Whether <code>"allow"</code> means permit and <code>"deny"</code> means block is your concern, not the engine’s.</p>
<p>Policy (allow/deny, rate limits, routing decisions) lives <strong>above</strong> the matcher. This is the Istio pattern — the data plane matches, the control plane decides. x.uma is the data plane.</p>
<p>This means x.uma doesn’t compete with OPA or Cedar. It complements them. Use x.uma for fast, structured matching. Use a policy engine for policy logic that operates on the match result.</p>
<h2 id="two-construction-paths"><a class="header" href="#two-construction-paths">Two Construction Paths</a></h2>
<p>Matchers can be built two ways:</p>
<p><strong>Compiler path</strong> — domain-specific DSL produces matchers directly. Ergonomic, type-safe, no serialization overhead.</p>
<pre><code class="language-python">from xuma.http import HttpRouteMatch, compile_route_matches

routes = [HttpRouteMatch(path=HttpPathMatch(type="PathPrefix", value="/api"), method="GET")]
matcher = compile_route_matches(routes, "api", "not_found")
</code></pre>
<p><strong>Config path</strong> — JSON/YAML config loaded through the registry. Portable across languages, storable, versionable.</p>
<pre><code class="language-json">{
  "matcher_list": [{
    "predicate": {
      "single": {
        "input": { "type_url": "xuma.test.v1.StringInput", "config": { "key": "method" } },
        "matcher": { "type_url": "xuma.core.v1.StringMatcher", "config": { "exact": "GET" } }
      }
    },
    "on_match": { "action": "route-get" }
  }],
  "on_no_match": { "action": "fallback" }
}
</code></pre>
<p>Both paths produce the same <code>Matcher</code>. The compiler path is for programmatic construction. The config path is for declarative, cross-language use.</p>
<h2 id="five-implementations-one-spec"><a class="header" href="#five-implementations-one-spec">Five Implementations, One Spec</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Implementation</th><th>Language</th><th>Type</th></tr>
</thead>
<tbody>
<tr><td><strong>rumi</strong></td><td>Rust</td><td>Reference implementation</td></tr>
<tr><td><strong>xuma</strong> (Python)</td><td>Python</td><td>Pure Python</td></tr>
<tr><td><strong>xuma</strong> (TypeScript)</td><td>TypeScript</td><td>Pure TypeScript</td></tr>
<tr><td><strong>xuma-crust</strong></td><td>Python</td><td>Rust core via PyO3</td></tr>
<tr><td><strong>xuma-crust</strong></td><td>TypeScript</td><td>Rust core via WASM</td></tr>
</tbody>
</table>
</div>
<p>All five pass the same conformance test suite. Same config format, same evaluation semantics, same results. Choose based on your runtime and performance needs.</p>
<h2 id="next-2"><a class="header" href="#next-2">Next</a></h2>
<ul>
<li><a href="#the-matching-pipeline">The Matching Pipeline</a> — how data flows through evaluation</li>
<li><a href="#type-erasure-and-ports">Type Erasure and Ports</a> — the technical details of the seam</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="config-format"><a class="header" href="#config-format">Config Format</a></h1>
<p>The config format is shared across all five implementations. Same JSON/YAML structure, same semantics.</p>
<h2 id="matcherconfig"><a class="header" href="#matcherconfig">MatcherConfig</a></h2>
<p>Top-level config for a matcher:</p>
<pre><code class="language-json">{
  "matchers": [ ... ],
  "on_no_match": { ... }
}
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>matchers</code></td><td>array of <code>FieldMatcherConfig</code></td><td>Yes</td><td>Field matchers evaluated in order</td></tr>
<tr><td><code>on_no_match</code></td><td><code>OnMatchConfig</code></td><td>No</td><td>Fallback when no field matcher matches</td></tr>
</tbody>
</table>
</div>
<h2 id="fieldmatcherconfig"><a class="header" href="#fieldmatcherconfig">FieldMatcherConfig</a></h2>
<p>A single rule: predicate + action:</p>
<pre><code class="language-json">{
  "predicate": { ... },
  "on_match": { ... }
}
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>predicate</code></td><td><code>PredicateConfig</code></td><td>Yes</td><td>Condition to evaluate</td></tr>
<tr><td><code>on_match</code></td><td><code>OnMatchConfig</code></td><td>Yes</td><td>What to do when predicate matches</td></tr>
</tbody>
</table>
</div>
<h2 id="predicateconfig"><a class="header" href="#predicateconfig">PredicateConfig</a></h2>
<p>Boolean logic over conditions. Discriminated by <code>type</code>:</p>
<h3 id="single"><a class="header" href="#single">single</a></h3>
<p>Extract a value and match it:</p>
<pre><code class="language-json">{
  "type": "single",
  "input": { "type_url": "xuma.test.v1.StringInput", "config": { "key": "method" } },
  "value_match": { "Exact": "GET" }
}
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>type</code></td><td><code>"single"</code></td><td>Yes</td><td>Discriminator</td></tr>
<tr><td><code>input</code></td><td><code>TypedConfig</code></td><td>Yes</td><td>Data input reference (resolved via registry)</td></tr>
<tr><td><code>value_match</code></td><td><code>ValueMatch</code></td><td>One of</td><td>Built-in string match</td></tr>
<tr><td><code>custom_match</code></td><td><code>TypedConfig</code></td><td>One of</td><td>Custom matcher via registry</td></tr>
</tbody>
</table>
</div>
<p>Exactly one of <code>value_match</code> or <code>custom_match</code> must be set.</p>
<h3 id="and"><a class="header" href="#and">and</a></h3>
<p>All child predicates must match:</p>
<pre><code class="language-json">{
  "type": "and",
  "predicates": [ { "type": "single", ... }, { "type": "single", ... } ]
}
</code></pre>
<h3 id="or"><a class="header" href="#or">or</a></h3>
<p>Any child predicate must match:</p>
<pre><code class="language-json">{
  "type": "or",
  "predicates": [ { "type": "single", ... }, { "type": "single", ... } ]
}
</code></pre>
<h3 id="not"><a class="header" href="#not">not</a></h3>
<p>Negate a predicate:</p>
<pre><code class="language-json">{
  "type": "not",
  "predicate": { "type": "single", ... }
}
</code></pre>
<h2 id="onmatchconfig"><a class="header" href="#onmatchconfig">OnMatchConfig</a></h2>
<p>Either a terminal action or a nested matcher. Discriminated by <code>type</code>:</p>
<h3 id="action"><a class="header" href="#action">action</a></h3>
<p>Return a value:</p>
<pre><code class="language-json">{ "type": "action", "action": "route-get" }
</code></pre>
<p>The <code>action</code> field can be any JSON value – string, number, object. The engine doesn’t interpret it.</p>
<h3 id="matcher"><a class="header" href="#matcher">matcher</a></h3>
<p>Continue evaluation with a nested matcher:</p>
<pre><code class="language-json">{
  "type": "matcher",
  "matcher": {
    "matchers": [ ... ],
    "on_no_match": { ... }
  }
}
</code></pre>
<p>Action XOR matcher – never both. This enforces OnMatch exclusivity from the xDS spec.</p>
<h2 id="typedconfig"><a class="header" href="#typedconfig">TypedConfig</a></h2>
<p>Reference to a registered type:</p>
<pre><code class="language-json">{ "type_url": "xuma.test.v1.StringInput", "config": { "key": "method" } }
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>type_url</code></td><td>string</td><td>Yes</td><td>Registered type identifier</td></tr>
<tr><td><code>config</code></td><td>object</td><td>No (defaults to <code>{}</code>)</td><td>Type-specific configuration</td></tr>
</tbody>
</table>
</div>
<p>The <code>type_url</code> is resolved at load time via the Registry. Unknown type URLs produce an error listing available types.</p>
<h2 id="valuematch"><a class="header" href="#valuematch">ValueMatch</a></h2>
<p>Built-in string matchers:</p>
<pre><code class="language-json">{ "Exact": "hello" }
{ "Prefix": "/api" }
{ "Suffix": ".json" }
{ "Contains": "admin" }
{ "Regex": "^Bearer .+$" }
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Variant</th><th>Matches</th></tr>
</thead>
<tbody>
<tr><td><code>Exact</code></td><td>Exact string equality</td></tr>
<tr><td><code>Prefix</code></td><td>String starts with value</td></tr>
<tr><td><code>Suffix</code></td><td>String ends with value</td></tr>
<tr><td><code>Contains</code></td><td>String contains value</td></tr>
<tr><td><code>Regex</code></td><td>RE2 regex pattern (linear time)</td></tr>
</tbody>
</table>
</div>
<h2 id="type-url-reference"><a class="header" href="#type-url-reference">Type URL Reference</a></h2>
<h3 id="core-all-domains"><a class="header" href="#core-all-domains">Core (all domains)</a></h3>
<p>Registered by <code>register_core_matchers()</code> in all implementations:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type URL</th><th>Type</th><th>Config</th></tr>
</thead>
<tbody>
<tr><td><code>xuma.core.v1.StringMatcher</code></td><td>InputMatcher</td><td><code>StringMatchSpec</code></td></tr>
<tr><td><code>xuma.core.v1.BoolMatcher</code></td><td>InputMatcher</td><td><code>{ "value": true }</code></td></tr>
</tbody>
</table>
</div>
<h3 id="test-domain"><a class="header" href="#test-domain">Test Domain</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type URL</th><th>Config</th><th>Extracts</th></tr>
</thead>
<tbody>
<tr><td><code>xuma.test.v1.StringInput</code></td><td><code>{ "key": "method" }</code></td><td>Value for key from test context</td></tr>
</tbody>
</table>
</div>
<h3 id="http-domain"><a class="header" href="#http-domain">HTTP Domain</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type URL</th><th>Config</th><th>Extracts</th></tr>
</thead>
<tbody>
<tr><td><code>xuma.http.v1.PathInput</code></td><td><code>{}</code></td><td>Request path</td></tr>
<tr><td><code>xuma.http.v1.MethodInput</code></td><td><code>{}</code></td><td>HTTP method</td></tr>
<tr><td><code>xuma.http.v1.HeaderInput</code></td><td><code>{ "name": "content-type" }</code></td><td>Header value by name</td></tr>
<tr><td><code>xuma.http.v1.QueryParamInput</code></td><td><code>{ "name": "page" }</code></td><td>Query parameter by name</td></tr>
</tbody>
</table>
</div>
<h3 id="claude-domain"><a class="header" href="#claude-domain">Claude Domain</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type URL</th><th>Config</th><th>Extracts</th></tr>
</thead>
<tbody>
<tr><td><code>xuma.claude.v1.EventInput</code></td><td><code>{}</code></td><td>Hook event name (e.g. <code>PreToolUse</code>)</td></tr>
<tr><td><code>xuma.claude.v1.ToolNameInput</code></td><td><code>{}</code></td><td>Tool name (e.g. <code>Bash</code>)</td></tr>
<tr><td><code>xuma.claude.v1.ArgumentInput</code></td><td><code>{ "name": "command" }</code></td><td>Tool argument by name</td></tr>
<tr><td><code>xuma.claude.v1.SessionIdInput</code></td><td><code>{}</code></td><td>Session ID</td></tr>
<tr><td><code>xuma.claude.v1.CwdInput</code></td><td><code>{}</code></td><td>Working directory</td></tr>
<tr><td><code>xuma.claude.v1.GitBranchInput</code></td><td><code>{}</code></td><td>Git branch</td></tr>
</tbody>
</table>
</div>
<h2 id="full-examples"><a class="header" href="#full-examples">Full Examples</a></h2>
<h3 id="http-route-matching"><a class="header" href="#http-route-matching">HTTP Route Matching</a></h3>
<pre><code class="language-yaml">matchers:
  - predicate:
      type: and
      predicates:
        - type: single
          input: { type_url: "xuma.http.v1.PathInput", config: {} }
          value_match: { Prefix: "/api" }
        - type: single
          input: { type_url: "xuma.http.v1.MethodInput", config: {} }
          value_match: { Exact: "GET" }
    on_match: { type: action, action: "api_read" }

  - predicate:
      type: single
      input: { type_url: "xuma.http.v1.HeaderInput", config: { name: "content-type" } }
      value_match: { Exact: "application/json" }
    on_match: { type: action, action: "json_handler" }

on_no_match: { type: action, action: "not_found" }
</code></pre>
<h3 id="claude-code-hook-policy"><a class="header" href="#claude-code-hook-policy">Claude Code Hook Policy</a></h3>
<pre><code class="language-yaml">matchers:
  - predicate:
      type: and
      predicates:
        - type: single
          input: { type_url: "xuma.claude.v1.EventInput", config: {} }
          value_match: { Exact: "PreToolUse" }
        - type: single
          input: { type_url: "xuma.claude.v1.ToolNameInput", config: {} }
          value_match: { Exact: "Bash" }
        - type: single
          input: { type_url: "xuma.claude.v1.ArgumentInput", config: { name: "command" } }
          value_match: { Contains: "rm -rf" }
    on_match: { type: action, action: "block" }

  - predicate:
      type: single
      input: { type_url: "xuma.claude.v1.EventInput", config: {} }
      value_match: { Exact: "PreToolUse" }
    on_match: { type: action, action: "allow" }

on_no_match: { type: action, action: "allow" }
</code></pre>
<h3 id="test-domain-key-value"><a class="header" href="#test-domain-key-value">Test Domain (key-value)</a></h3>
<pre><code class="language-yaml">matchers:
  - predicate:
      type: and
      predicates:
        - type: single
          input: { type_url: "xuma.test.v1.StringInput", config: { key: "method" } }
          value_match: { Exact: "GET" }
        - type: single
          input: { type_url: "xuma.test.v1.StringInput", config: { key: "path" } }
          value_match: { Prefix: "/api" }
    on_match: { type: action, action: "api_get" }

  - predicate:
      type: single
      input: { type_url: "xuma.test.v1.StringInput", config: { key: "path" } }
      value_match: { Exact: "/health" }
    on_match: { type: action, action: "health" }

on_no_match: { type: action, action: "not_found" }
</code></pre>
<h2 id="validation-limits"><a class="header" href="#validation-limits">Validation Limits</a></h2>
<p>Configs are validated at load time:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Limit</th><th>Value</th><th>Error</th></tr>
</thead>
<tbody>
<tr><td>Max nesting depth</td><td>32 levels</td><td><code>DepthExceeded</code></td></tr>
<tr><td>Max field matchers per matcher</td><td>256</td><td><code>TooManyFieldMatchers</code></td></tr>
<tr><td>Max predicates per AND/OR</td><td>256</td><td><code>TooManyPredicates</code></td></tr>
<tr><td>Max pattern length</td><td>8192 chars</td><td><code>PatternTooLong</code></td></tr>
<tr><td>Max regex pattern length</td><td>4096 chars</td><td><code>PatternTooLong</code></td></tr>
</tbody>
</table>
</div>
<p>If a config loads successfully, the resulting matcher is guaranteed to be structurally valid. Parse, don’t validate.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cli-reference-rumi"><a class="header" href="#cli-reference-rumi">CLI Reference (rumi)</a></h1>
<p><code>rumi</code> is the command-line interface for running and validating matcher configs across three domains.</p>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<pre><code class="language-bash">cargo install --path rumi/cli
</code></pre>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<pre><code>rumi &lt;command&gt; [domain] [options]
</code></pre>
<h2 id="domains"><a class="header" href="#domains">Domains</a></h2>
<p>The CLI supports three matching domains. Each domain has its own registry of type URLs and context type.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Domain</th><th>Context</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><em>(default)</em></td><td>Key-value pairs</td><td>Test domain (<code>xuma.test.v1.*</code>)</td></tr>
<tr><td><code>http</code></td><td>HTTP request</td><td>Method, path, headers, query params (<code>xuma.http.v1.*</code>)</td></tr>
<tr><td><code>claude</code></td><td>Hook event</td><td>Claude Code hook events (<code>xuma.claude.v1.*</code>)</td></tr>
</tbody>
</table>
</div>
<h2 id="commands"><a class="header" href="#commands">Commands</a></h2>
<h3 id="run"><a class="header" href="#run">run</a></h3>
<p>Run a config file against a context and print the resulting action.</p>
<p><strong>Test domain (default):</strong></p>
<pre><code class="language-bash">rumi run config.yaml --context method=GET path=/api
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Flag</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>--context key=value...</code></td><td>Context key-value pairs</td></tr>
</tbody>
</table>
</div>
<p><strong>HTTP domain:</strong></p>
<pre><code class="language-bash">rumi run http routes.yaml --method GET --path /api/users
rumi run http routes.yaml --method POST --path /api --header content-type=application/json
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Flag</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>--method METHOD</code></td><td>HTTP method (required)</td></tr>
<tr><td><code>--path PATH</code></td><td>Request path (required)</td></tr>
<tr><td><code>--header key=value</code></td><td>Header (repeatable)</td></tr>
<tr><td><code>--query key=value</code></td><td>Query parameter (repeatable)</td></tr>
</tbody>
</table>
</div>
<p><strong>Claude domain:</strong></p>
<pre><code class="language-bash">rumi run claude hooks.yaml --event PreToolUse --tool Bash --arg command="ls -la"
rumi run claude hooks.yaml --event SessionStart --cwd /home/user --branch main
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Flag</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>--event EVENT</code></td><td>Hook event name (required)</td></tr>
<tr><td><code>--tool NAME</code></td><td>Tool name</td></tr>
<tr><td><code>--arg key=value</code></td><td>Tool argument (repeatable)</td></tr>
<tr><td><code>--cwd PATH</code></td><td>Working directory</td></tr>
<tr><td><code>--branch NAME</code></td><td>Git branch</td></tr>
<tr><td><code>--session ID</code></td><td>Session ID</td></tr>
</tbody>
</table>
</div>
<p>Valid events: <code>PreToolUse</code>, <code>PostToolUse</code>, <code>Stop</code>, <code>SubagentStop</code>, <code>UserPromptSubmit</code>, <code>SessionStart</code>, <code>SessionEnd</code>, <code>PreCompact</code>, <code>Notification</code>.</p>
<p>Prints the matched action string, or <code>(no match)</code> if nothing matched.</p>
<h3 id="check"><a class="header" href="#check">check</a></h3>
<p>Validate a config file without evaluating:</p>
<pre><code class="language-bash">rumi check config.yaml
rumi check http routes.yaml
rumi check claude hooks.yaml
</code></pre>
<p>Loads the config against the domain’s registry (including type URL resolution and depth validation). Catches: unknown type URLs, invalid regex patterns, depth limit violations, malformed config.</p>
<p>Prints <code>Config valid</code> on success. Exits with non-zero status on error.</p>
<h3 id="info"><a class="header" href="#info">info</a></h3>
<p>List all registered type URLs for a domain:</p>
<pre><code class="language-bash">$ rumi info
Registered inputs:
  xuma.test.v1.StringInput

Registered matchers:
  xuma.core.v1.StringMatcher
  xuma.core.v1.BoolMatcher

$ rumi info http
Registered inputs:
  xuma.http.v1.PathInput
  xuma.http.v1.MethodInput
  xuma.http.v1.HeaderInput
  xuma.http.v1.QueryParamInput

Registered matchers:
  xuma.core.v1.StringMatcher
  xuma.core.v1.BoolMatcher

$ rumi info claude
Registered inputs:
  xuma.claude.v1.EventInput
  xuma.claude.v1.ToolNameInput
  xuma.claude.v1.ArgumentInput
  xuma.claude.v1.SessionIdInput
  xuma.claude.v1.CwdInput
  xuma.claude.v1.GitBranchInput

Registered matchers:
  xuma.core.v1.StringMatcher
  xuma.core.v1.BoolMatcher
</code></pre>
<h3 id="help"><a class="header" href="#help">help</a></h3>
<pre><code class="language-bash">rumi help
rumi --help
rumi -h
</code></pre>
<h2 id="config-file-format"><a class="header" href="#config-file-format">Config File Format</a></h2>
<p>The CLI accepts the same config format used by all implementations. See <a href="#config-format">Config Format</a> for the full schema. Files can be YAML (<code>.yaml</code>, <code>.yml</code>) or JSON (<code>.json</code>).</p>
<h2 id="exit-codes"><a class="header" href="#exit-codes">Exit Codes</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Code</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><td>0</td><td>Success</td></tr>
<tr><td>1</td><td>Error (invalid config, unknown command, missing flags, etc.)</td></tr>
</tbody>
</table>
</div>
<h2 id="design"><a class="header" href="#design">Design</a></h2>
<p>The CLI has zero runtime dependencies beyond <code>rumi</code>, <code>rumi-http</code>, and <code>rumi-test</code>. No <code>clap</code> – argument parsing is hand-written. The binary is small and builds fast.</p>
<p>Each domain registers its own <code>Registry&lt;Ctx&gt;</code>:</p>
<ul>
<li>Test: <code>rumi_test::register()</code> -&gt; <code>Registry&lt;TestContext&gt;</code></li>
<li>HTTP: <code>rumi_http::register_simple()</code> -&gt; <code>Registry&lt;HttpRequest&gt;</code></li>
<li>Claude: <code>rumi::claude::register()</code> -&gt; <code>Registry&lt;HookContext&gt;</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="api-reference"><a class="header" href="#api-reference">API Reference</a></h1>
<p>Generated from source. Always current.</p>
<ul>
<li><strong>Rust</strong> — <code>cargo doc --manifest-path rumi/Cargo.toml --workspace --exclude rumi-proto --no-deps --open</code></li>
<li><strong>Python</strong> — <code>cd puma &amp;&amp; uv run pdoc xuma</code></li>
<li><strong>TypeScript</strong> — <code>cd bumi &amp;&amp; bunx typedoc src/index.ts</code></li>
</ul>
<p>Hosted API docs coming soon.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="security-model"><a class="header" href="#security-model">Security Model</a></h1>
<p>x.uma’s security model prevents four classes of attack against matcher engines. Every guarantee is enforced at construction time, not evaluation time.</p>
<h2 id="threat-model"><a class="header" href="#threat-model">Threat Model</a></h2>
<p>Matcher configs can come from untrusted sources — user-provided routing rules, dynamically loaded policy files, configs from external systems. The engine must be safe even when the config is adversarial.</p>
<h2 id="redos-protection"><a class="header" href="#redos-protection">ReDoS Protection</a></h2>
<p><strong>Threat:</strong> Regular expression Denial of Service. A crafted regex pattern causes exponential backtracking, consuming CPU indefinitely.</p>
<p><strong>Mitigation:</strong> All implementations use RE2-class linear-time regex engines:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Implementation</th><th>Regex Engine</th><th>Guarantee</th></tr>
</thead>
<tbody>
<tr><td>rumi (Rust)</td><td><code>regex</code> crate (DFA)</td><td>Linear time, proven</td></tr>
<tr><td>xuma (Python)</td><td><code>google-re2</code> (C++ RE2 binding)</td><td>Linear time, Google RE2</td></tr>
<tr><td>xuma (TypeScript)</td><td><code>re2js</code> (pure JS RE2 port)</td><td>Linear time, RE2 semantics</td></tr>
<tr><td>xuma-crust (Python)</td><td>Rust <code>regex</code> via PyO3</td><td>Same as rumi</td></tr>
<tr><td>xuma-crust (TypeScript)</td><td>Rust <code>regex</code> via WASM</td><td>Same as rumi</td></tr>
</tbody>
</table>
</div>
<p>No implementation uses a backtracking regex engine. Patterns that would cause catastrophic backtracking in PCRE/Python <code>re</code>/JavaScript <code>RegExp</code> are either rejected or matched in linear time.</p>
<p><strong>Pattern length limit:</strong> Regex patterns are capped at 4,096 characters (<code>MAX_REGEX_PATTERN_LENGTH</code>). Non-regex patterns are capped at 8,192 characters (<code>MAX_PATTERN_LENGTH</code>).</p>
<h2 id="depth-limit"><a class="header" href="#depth-limit">Depth Limit</a></h2>
<p><strong>Threat:</strong> Stack overflow from deeply nested matchers. A config with 1,000 levels of nested matchers could exhaust the call stack during evaluation.</p>
<p><strong>Mitigation:</strong> Maximum nesting depth of 32 levels (<code>MAX_DEPTH</code>), validated at construction time. If a config exceeds this limit, <code>MatcherError::DepthExceeded</code> is returned and no matcher is constructed.</p>
<p>32 levels is generous — real-world matchers rarely exceed 5 levels. The limit catches misconfigured or adversarial configs.</p>
<h2 id="width-limits"><a class="header" href="#width-limits">Width Limits</a></h2>
<p><strong>Threat:</strong> Resource exhaustion from extremely wide matchers. A config with millions of field matchers at depth 1 bypasses depth limits but still causes excessive memory and CPU usage.</p>
<p><strong>Mitigation:</strong> Three width limits, all validated at construction time:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Limit</th><th>Value</th><th>Protects</th></tr>
</thead>
<tbody>
<tr><td><code>MAX_FIELD_MATCHERS</code></td><td>256 per <code>Matcher</code></td><td>Memory from wide matcher lists</td></tr>
<tr><td><code>MAX_PREDICATES_PER_COMPOUND</code></td><td>256 per AND/OR</td><td>CPU from wide predicate trees</td></tr>
<tr><td><code>MAX_PATTERN_LENGTH</code></td><td>8,192 chars</td><td>Memory from large string patterns</td></tr>
</tbody>
</table>
</div>
<h2 id="none-to-false"><a class="header" href="#none-to-false">None-to-False</a></h2>
<p><strong>Threat:</strong> Missing data accidentally matching a rule. If a header doesn’t exist, it should not match <code>ExactMatcher("secret")</code>.</p>
<p><strong>Mitigation:</strong> When <code>DataInput.get()</code> returns <code>None</code>/<code>null</code>, the predicate evaluates to <code>false</code>. The <code>InputMatcher</code> is never called. This is enforced in all five implementations.</p>
<p>This is a security invariant, not a convenience feature. It ensures fail-closed behavior: missing data means no match.</p>
<h2 id="immutability"><a class="header" href="#immutability">Immutability</a></h2>
<p><strong>Threat:</strong> Race conditions from concurrent access. Matchers shared across threads could produce inconsistent results if modified during evaluation.</p>
<p><strong>Mitigation:</strong></p>
<ul>
<li><strong>Rust:</strong> All core types are <code>Send + Sync</code>. Matchers are immutable after construction and safe to share via <code>Arc&lt;Matcher&gt;</code>.</li>
<li><strong>Python:</strong> All types use <code>@dataclass(frozen=True)</code>. Fields cannot be reassigned after construction.</li>
<li><strong>TypeScript:</strong> All types use <code>readonly</code> fields.</li>
<li><strong>Registry:</strong> Immutable after <code>.build()</code>. The builder produces the registry, then the builder is consumed. No runtime registration.</li>
</ul>
<h2 id="construction-time-validation"><a class="header" href="#construction-time-validation">Construction-Time Validation</a></h2>
<p>All validation happens when the matcher is built, not when it’s evaluated. If a <code>Matcher</code> object exists, it’s guaranteed to be:</p>
<ul>
<li>Within depth limits</li>
<li>Within width limits</li>
<li>Free of invalid regex patterns</li>
<li>Free of unknown type URLs (config path)</li>
<li>Structurally sound (OnMatch exclusivity enforced by the type system)</li>
</ul>
<p>This follows the “parse, don’t validate” principle. The construction boundary is the trust boundary.</p>
<h2 id="error-messages"><a class="header" href="#error-messages">Error Messages</a></h2>
<p><code>MatcherError</code> variants include actionable context:</p>
<ul>
<li><code>UnknownTypeUrl</code> lists all registered type URLs</li>
<li><code>DepthExceeded</code> shows actual vs maximum depth</li>
<li><code>PatternTooLong</code> shows actual vs maximum length</li>
<li><code>InvalidPattern</code> includes the regex compilation error</li>
</ul>
<p>Self-correcting error messages help operators fix configs without guessing.</p>
<h2 id="what-is-not-protected"><a class="header" href="#what-is-not-protected">What Is NOT Protected</a></h2>
<ul>
<li><strong>Semantic correctness:</strong> x.uma doesn’t verify that your rules do what you intend. First-match-wins means rule order matters — a too-broad rule early in the list can shadow specific rules.</li>
<li><strong>Action interpretation:</strong> The engine returns actions without interpreting them. Whether <code>"allow"</code> means permit is your responsibility.</li>
<li><strong>Context injection:</strong> x.uma trusts the context you provide. If your <code>DataInput</code> produces unsafe values from user input, the engine cannot protect you.</li>
<li><strong>Side effects:</strong> Evaluation is pure (no I/O, no state mutation). But the code that acts on the result is outside x.uma’s scope.</li>
</ul>
<h2 id="next-3"><a class="header" href="#next-3">Next</a></h2>
<ul>
<li><a href="#architecture">Architecture</a> — how safety is built into the design</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace-2a3cd908.js"></script>
        <script src="mode-rust-2c9d5c9a.js"></script>
        <script src="editor-16ca416c.js"></script>
        <script src="theme-dawn-4493f9c8.js"></script>
        <script src="theme-tomorrow_night-9dbe62a9.js"></script>

        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
