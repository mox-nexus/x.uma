<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>x.uma</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Cross-Platform Unified Matcher API">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "rust";
            const default_dark_theme = "coal";
            window.path_to_searchindex_js = "searchindex-20d2e022.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-0ba3f3c3.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">x.uma</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/mox-labs/x.uma" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="xuma"><a class="header" href="#xuma">x.uma</a></h1>
<blockquote>
<p>One matcher engine. Five implementations. Same semantics everywhere.</p>
</blockquote>
<p>x.uma implements the <a href="https://www.envoyproxy.io/docs/envoy/latest/api-v3/xds/type/matcher/v3/matcher.proto">xDS Unified Matcher API</a> — the same matching protocol Envoy uses at Google scale — across Rust, Python, and TypeScript.</p>
<p>Write matching rules once. Evaluate them in any language. Get the same answer every time.</p>
<pre><code>Context → DataInput → MatchingData → InputMatcher → bool
           domain-      erased         domain-
           specific                    agnostic
</code></pre>
<p>An <code>ExactMatcher</code> doesn’t know whether it’s matching HTTP paths, Claude Code hook events, or your custom domain. It matches <em>data</em>. The domain-specific part — extracting that data from your context — is a separate port. This is the key architectural insight, borrowed from Envoy and proven at Google scale.</p>
<h2 id="implementations"><a class="header" href="#implementations">Implementations</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Package</th><th>Language</th><th>What it is</th></tr>
</thead>
<tbody>
<tr><td><strong>rumi</strong></td><td>Rust</td><td>Core engine (reference implementation)</td></tr>
<tr><td><strong>xuma</strong></td><td>Python 3.12+</td><td>Pure Python, zero native deps beyond RE2</td></tr>
<tr><td><strong>xuma</strong></td><td>TypeScript/Bun</td><td>Pure TypeScript, zero native deps beyond RE2</td></tr>
<tr><td><strong>puma-crusty</strong></td><td>Python</td><td>Rust bindings via PyO3</td></tr>
<tr><td><strong>bumi-crusty</strong></td><td>TypeScript</td><td>Rust bindings via WASM</td></tr>
</tbody>
</table>
</div>
<p>All five pass the same conformance test suite (~958 tests total). They implement identical semantics with different performance characteristics.</p>
<h2 id="pick-your-language"><a class="header" href="#pick-your-language">Pick Your Language</a></h2>
<p>Already know which language you need? Start here:</p>
<ul>
<li><strong><a href="#rust-quick-start">Rust</a></strong> — <code>rumi</code> + <code>rumi-http</code> in your <code>Cargo.toml</code></li>
<li><strong><a href="#python-quick-start">Python</a></strong> — <code>uv add xuma</code>, build a matcher in 10 lines</li>
<li><strong><a href="#typescript-quick-start">TypeScript</a></strong> — <code>bun add xuma</code>, same API shape as Python</li>
</ul>
<p>Each quick start gets you from install to working HTTP route matcher in under 5 minutes.</p>
<h2 id="understand-first"><a class="header" href="#understand-first">Understand First</a></h2>
<p>Not sure whether x.uma fits your problem? Read these:</p>
<ul>
<li><strong><a href="#when-to-use-xuma">When to Use x.uma</a></strong> — x.uma vs OPA vs Cedar vs Zanzibar. Honest comparison with decision framework.</li>
<li><strong><a href="#architecture">Architecture</a></strong> — Hexagonal architecture, ACES design philosophy, why five implementations.</li>
</ul>
<h2 id="domains"><a class="header" href="#domains">Domains</a></h2>
<p>x.uma ships with two domain adapters. Adding your own is <a href="#adding-a-domain-adapter">straightforward</a>.</p>
<p><strong><a href="#http-matching">HTTP Matching</a></strong> — Path, method, header, and query parameter matching. Gateway API config types. Compiles <code>HttpRouteMatch</code> into a <code>Matcher</code> in one call.</p>
<p><strong><a href="#claude-code-hooks">Claude Code Hooks</a></strong> — Match Claude Code hook events by event type, tool name, arguments, session, working directory, or git branch. Compiles <code>HookMatch</code> into a <code>Matcher</code> for multi-rule OR semantics.</p>
<h2 id="what-it-guarantees"><a class="header" href="#what-it-guarantees">What It Guarantees</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Guarantee</th><th>How</th></tr>
</thead>
<tbody>
<tr><td><strong>No ReDoS</strong></td><td>Rust <code>regex</code> crate (linear time). Python uses <code>google-re2</code>. TypeScript uses <code>re2js</code>.</td></tr>
<tr><td><strong>Bounded depth</strong></td><td>Max 32 levels of nesting, validated at config load</td></tr>
<tr><td><strong>Fail-closed</strong></td><td>Missing data means predicate returns <code>false</code>. Never matches by accident.</td></tr>
<tr><td><strong>Thread-safe</strong></td><td>All types are <code>Send + Sync</code> (Rust) / immutable (Python, TypeScript)</td></tr>
<tr><td><strong>Config validated at construction</strong></td><td>Invalid configs rejected before evaluation. Parse, don’t validate.</td></tr>
</tbody>
</table>
</div>
<h2 id="status"><a class="header" href="#status">Status</a></h2>
<p><strong>Version 0.0.2</strong> — Alpha. API is stabilizing but may change before 1.0.</p>
<p>Phases 0-18 complete. Core engine, HTTP domain, Claude domain, config/registry layer, RE2 migration, CLI, cross-language benchmarks — all shipped. Name resolution pending before crates.io/PyPI/npm publish.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rust-quick-start"><a class="header" href="#rust-quick-start">Rust Quick Start</a></h1>
<p>Build an HTTP route matcher with <code>rumi</code> and <code>rumi-http</code>.</p>
<h2 id="install"><a class="header" href="#install">Install</a></h2>
<pre><code class="language-toml">[dependencies]
rumi = "0.0.2"
rumi-http = "0.0.2"
</code></pre>
<p><code>rumi-http</code> brings in <code>rumi</code> as a transitive dependency.</p>
<h2 id="your-first-matcher"><a class="header" href="#your-first-matcher">Your First Matcher</a></h2>
<p>Match requests by path prefix:</p>
<pre><code class="language-rust ignore">use rumi::prelude::*;
use rumi_http::*;

fn main() {
    // Build a simple request
    let request = HttpRequest::builder()
        .method("GET")
        .path("/api/users")
        .build();

    // Define a predicate: path starts with /api
    let predicate = Predicate::Single(SinglePredicate::new(
        Box::new(SimplePathInput),
        Box::new(PrefixMatcher::new("/api")),
    ));

    // Build the matcher tree
    let matcher: Matcher&lt;HttpRequest, &amp;str&gt; = Matcher::new(
        vec![FieldMatcher::new(
            predicate,
            OnMatch::Action("api_backend"),
        )],
        Some(OnMatch::Action("default_backend")),
    );

    // Evaluate
    assert_eq!(matcher.evaluate(&amp;request), Some(&amp;"api_backend"));

    // No match falls through to on_no_match
    let other = HttpRequest::builder().method("GET").path("/other").build();
    assert_eq!(matcher.evaluate(&amp;other), Some(&amp;"default_backend"));
}</code></pre>
<p><code>Matcher::new</code> takes a list of <code>FieldMatcher</code>s (tried in order) and an optional fallback. First match wins.</p>
<h2 id="combining-conditions"><a class="header" href="#combining-conditions">Combining Conditions</a></h2>
<p>Use <code>Predicate::And</code> to require multiple conditions:</p>
<pre><code class="language-rust ignore">use rumi::prelude::*;
use rumi_http::*;

// GET /api/* — both path AND method must match
let predicate = Predicate::And(vec![
    Predicate::Single(SinglePredicate::new(
        Box::new(SimplePathInput),
        Box::new(PrefixMatcher::new("/api")),
    )),
    Predicate::Single(SinglePredicate::new(
        Box::new(SimpleMethodInput),
        Box::new(ExactMatcher::new("GET")),
    )),
]);

let matcher: Matcher&lt;HttpRequest, &amp;str&gt; = Matcher::new(
    vec![FieldMatcher::new(predicate, OnMatch::Action("api_read"))],
    Some(OnMatch::Action("not_found")),
);

let get_api = HttpRequest::builder().method("GET").path("/api/users").build();
assert_eq!(matcher.evaluate(&amp;get_api), Some(&amp;"api_read"));

let post_api = HttpRequest::builder().method("POST").path("/api/users").build();
assert_eq!(matcher.evaluate(&amp;post_api), Some(&amp;"not_found"));</code></pre>
<h2 id="custom-action-types"><a class="header" href="#custom-action-types">Custom Action Types</a></h2>
<p>The action type <code>A</code> is generic. Use enums, structs — anything <code>Clone + Send + Sync</code>:</p>
<pre><code class="language-rust ignore">#[derive(Debug, Clone, PartialEq)]
enum RouteAction {
    Forward(String),
    Deny(String),
}

let matcher: Matcher&lt;HttpRequest, RouteAction&gt; = Matcher::new(
    vec![FieldMatcher::new(
        predicate,
        OnMatch::Action(RouteAction::Forward("api-service".into())),
    )],
    Some(OnMatch::Action(RouteAction::Deny("no route".into()))),
);</code></pre>
<h2 id="thread-safety"><a class="header" href="#thread-safety">Thread Safety</a></h2>
<p>Matchers are <code>Send + Sync</code>. Share one instance across threads with no locking:</p>
<pre><code class="language-rust ignore">use std::sync::Arc;

let matcher = Arc::new(matcher);
let m = matcher.clone();
std::thread::spawn(move || {
    let result = m.evaluate(&amp;request);
});</code></pre>
<p>The matcher is immutable after construction. <code>Arc</code> adds one atomic refcount — nothing else.</p>
<h2 id="safety-guarantees"><a class="header" href="#safety-guarantees">Safety Guarantees</a></h2>
<ul>
<li><strong>ReDoS protection</strong> — the <code>regex</code> crate guarantees linear-time matching. No backtracking.</li>
<li><strong>Depth limits</strong> — nested matchers capped at 32 levels, validated at construction.</li>
<li><strong>No unsafe in core</strong> — all <code>Send + Sync</code> is compiler-derived.</li>
</ul>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<ul>
<li><a href="#the-matching-pipeline">The Matching Pipeline</a> — how data flows through the matcher</li>
<li><a href="#build-an-http-router">Build an HTTP Router</a> — full routing with headers and query params</li>
<li><a href="#http-matching">HTTP Matching</a> — all inputs, config types, and the Gateway API compiler</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="python-quick-start"><a class="header" href="#python-quick-start">Python Quick Start</a></h1>
<p>Build an HTTP route matcher with <code>xuma</code> in 10 lines.</p>
<h2 id="install-1"><a class="header" href="#install-1">Install</a></h2>
<pre><code class="language-bash">uv add xuma
</code></pre>
<p>Requires Python 3.12+. The only runtime dependency is <code>google-re2</code> for linear-time regex.</p>
<h2 id="your-first-matcher-1"><a class="header" href="#your-first-matcher-1">Your First Matcher</a></h2>
<p>Match requests by path prefix:</p>
<pre><code class="language-python">from xuma import Matcher, FieldMatcher, SinglePredicate, Action, PrefixMatcher
from xuma.http import HttpRequest, PathInput

# Build a predicate: path starts with /api
predicate = SinglePredicate(
    input=PathInput(),
    matcher=PrefixMatcher("/api"),
)

# Build the matcher tree
matcher = Matcher(
    matcher_list=(
        FieldMatcher(predicate=predicate, on_match=Action("api_backend")),
    ),
    on_no_match=Action("default_backend"),
)

# Evaluate
request = HttpRequest(method="GET", raw_path="/api/users")
assert matcher.evaluate(request) == "api_backend"

# No match falls through
other = HttpRequest(method="GET", raw_path="/other")
assert matcher.evaluate(other) == "default_backend"
</code></pre>
<p><code>Matcher</code> takes a tuple of <code>FieldMatcher</code>s (tried in order) and an optional fallback. First match wins.</p>
<h2 id="the-gateway-api-compiler"><a class="header" href="#the-gateway-api-compiler">The Gateway API Compiler</a></h2>
<p>Manual predicate construction is explicit but verbose. The HTTP domain ships a compiler that builds matchers from Gateway API config:</p>
<pre><code class="language-python">from xuma.http import (
    HttpRouteMatch,
    HttpPathMatch,
    HttpRequest,
    compile_route_matches,
)

# Declarative config
routes = [
    HttpRouteMatch(
        path=HttpPathMatch(type="PathPrefix", value="/api"),
        method="GET",
    ),
    HttpRouteMatch(
        path=HttpPathMatch(type="PathPrefix", value="/admin"),
        method="POST",
    ),
]

# One call compiles all routes
matcher = compile_route_matches(
    matches=routes,
    action="allowed",
    on_no_match="denied",
)

assert matcher.evaluate(HttpRequest(method="GET", raw_path="/api/users")) == "allowed"
assert matcher.evaluate(HttpRequest(method="DELETE", raw_path="/api/users")) == "denied"
</code></pre>
<p>Within a single <code>HttpRouteMatch</code>, all conditions are ANDed. Multiple routes are ORed. First match wins.</p>
<h2 id="adding-header-conditions"><a class="header" href="#adding-header-conditions">Adding Header Conditions</a></h2>
<pre><code class="language-python">from xuma.http import HttpHeaderMatch

route = HttpRouteMatch(
    path=HttpPathMatch(type="PathPrefix", value="/api"),
    method="POST",
    headers=[
        HttpHeaderMatch(
            type="RegularExpression",
            name="authorization",
            value=r"^Bearer .+$",
        ),
    ],
)
</code></pre>
<p>Regex uses <code>google-re2</code> — linear time, no ReDoS vulnerability.</p>
<h2 id="custom-action-types-1"><a class="header" href="#custom-action-types-1">Custom Action Types</a></h2>
<p>The action type can be any Python object:</p>
<pre><code class="language-python">from dataclasses import dataclass

@dataclass(frozen=True)
class RouteAction:
    target: str
    weight: int

matcher = compile_route_matches(
    matches=routes,
    action=RouteAction(target="api-service", weight=100),
    on_no_match=None,
)
</code></pre>
<h2 id="safety"><a class="header" href="#safety">Safety</a></h2>
<ul>
<li><strong>ReDoS protection</strong> — <code>google-re2</code> guarantees linear-time regex matching.</li>
<li><strong>Immutable</strong> — all types are <code>frozen=True</code> dataclasses.</li>
<li><strong>Depth limits</strong> — nested matchers capped at 32 levels.</li>
<li><strong>Fail-closed</strong> — missing headers or query params return <code>None</code> from <code>DataInput</code>, which makes the predicate evaluate to <code>False</code>.</li>
</ul>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<ul>
<li><a href="#the-matching-pipeline">The Matching Pipeline</a> — how data flows through the matcher</li>
<li><a href="#build-an-http-router">Build an HTTP Router</a> — full routing with headers and query params</li>
<li><a href="#http-matching">HTTP Matching</a> — all inputs, config types, and the compiler</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="typescript-quick-start"><a class="header" href="#typescript-quick-start">TypeScript Quick Start</a></h1>
<p>Build an HTTP route matcher with <code>xuma</code> in 10 lines.</p>
<h2 id="install-2"><a class="header" href="#install-2">Install</a></h2>
<pre><code class="language-bash">bun add xuma
</code></pre>
<p>Requires Bun runtime. The only runtime dependency is <code>re2js</code> for linear-time regex.</p>
<h2 id="your-first-matcher-2"><a class="header" href="#your-first-matcher-2">Your First Matcher</a></h2>
<p>Match requests by path prefix:</p>
<pre><code class="language-typescript">import { Matcher, FieldMatcher, SinglePredicate, Action, PrefixMatcher } from "xuma";
import { HttpRequest, PathInput } from "xuma/http";

// Build a predicate: path starts with /api
const predicate = new SinglePredicate(
  new PathInput(),
  new PrefixMatcher("/api"),
);

// Build the matcher tree
const matcher = new Matcher&lt;HttpRequest, string&gt;(
  [new FieldMatcher(predicate, new Action("api_backend"))],
  new Action("default_backend"),
);

// Evaluate
const request = new HttpRequest("GET", "/api/users");
console.assert(matcher.evaluate(request) === "api_backend");

// No match falls through
const other = new HttpRequest("GET", "/other");
console.assert(matcher.evaluate(other) === "default_backend");
</code></pre>
<p><code>Matcher</code> takes a list of <code>FieldMatcher</code>s (tried in order) and an optional fallback. First match wins.</p>
<h2 id="the-gateway-api-compiler-1"><a class="header" href="#the-gateway-api-compiler-1">The Gateway API Compiler</a></h2>
<p>The HTTP domain ships a compiler that builds matchers from Gateway API config:</p>
<pre><code class="language-typescript">import { compileRouteMatches, HttpRequest } from "xuma/http";
import type { HttpRouteMatch } from "xuma/http";

// Declarative config
const routes: HttpRouteMatch[] = [
  {
    path: { type: "PathPrefix", value: "/api" },
    method: "GET",
  },
  {
    path: { type: "PathPrefix", value: "/admin" },
    method: "POST",
  },
];

// One call compiles all routes
const matcher = compileRouteMatches(routes, "allowed", "denied");

console.assert(matcher.evaluate(new HttpRequest("GET", "/api/users")) === "allowed");
console.assert(matcher.evaluate(new HttpRequest("DELETE", "/api/users")) === "denied");
</code></pre>
<p>Within a single <code>HttpRouteMatch</code>, all conditions are ANDed. Multiple routes are ORed. First match wins.</p>
<h2 id="adding-header-conditions-1"><a class="header" href="#adding-header-conditions-1">Adding Header Conditions</a></h2>
<pre><code class="language-typescript">const route: HttpRouteMatch = {
  path: { type: "PathPrefix", value: "/api" },
  method: "POST",
  headers: [
    {
      type: "RegularExpression",
      name: "authorization",
      value: "^Bearer .+$",
    },
  ],
};
</code></pre>
<p>Regex uses <code>re2js</code> — linear time, no ReDoS vulnerability.</p>
<h2 id="custom-action-types-2"><a class="header" href="#custom-action-types-2">Custom Action Types</a></h2>
<p>Use discriminated unions or any TypeScript type:</p>
<pre><code class="language-typescript">type RouteAction =
  | { type: "forward"; backend: string }
  | { type: "deny"; reason: string };

const matcher = compileRouteMatches&lt;RouteAction&gt;(
  routes,
  { type: "forward", backend: "api-service" },
  { type: "deny", reason: "no route matched" },
);

const result = matcher.evaluate(request);
if (result?.type === "forward") {
  console.log(`Forwarding to ${result.backend}`);
}
</code></pre>
<h2 id="integration-bun-http-server"><a class="header" href="#integration-bun-http-server">Integration: Bun HTTP Server</a></h2>
<pre><code class="language-typescript">import { compileRouteMatches, HttpRequest } from "xuma/http";

const matcher = compileRouteMatches(
  [{ path: { type: "PathPrefix", value: "/api" }, method: "GET" }],
  "allowed",
  "denied",
);

Bun.serve({
  port: 3000,
  fetch(req) {
    const url = new URL(req.url);
    const request = new HttpRequest(
      req.method,
      url.pathname + url.search,
      Object.fromEntries(req.headers),
    );
    if (matcher.evaluate(request) === "denied") {
      return new Response("Not found", { status: 404 });
    }
    return new Response("OK");
  },
});
</code></pre>
<h2 id="safety-1"><a class="header" href="#safety-1">Safety</a></h2>
<ul>
<li><strong>ReDoS protection</strong> — <code>re2js</code> guarantees linear-time regex matching.</li>
<li><strong>Immutable</strong> — all types use <code>readonly</code> fields.</li>
<li><strong>Depth limits</strong> — nested matchers capped at 32 levels.</li>
<li><strong>Fail-closed</strong> — missing data from <code>DataInput</code> returns <code>null</code>, which makes the predicate evaluate to <code>false</code>.</li>
</ul>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<ul>
<li><a href="#the-matching-pipeline">The Matching Pipeline</a> — how data flows through the matcher</li>
<li><a href="#build-an-http-router">Build an HTTP Router</a> — full routing with headers and query params</li>
<li><a href="#http-matching">HTTP Matching</a> — all inputs, config types, and the compiler</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="the-matching-pipeline"><a class="header" href="#the-matching-pipeline">The Matching Pipeline</a></h1>
<p>Every evaluation follows the same flow. Understanding this pipeline is understanding x.uma.</p>
<h2 id="the-flow"><a class="header" href="#the-flow">The Flow</a></h2>
<pre><code class="language-text">Context (your data)
    ↓
DataInput.get()          ← extract a value from the context
    ↓
MatchingData             ← type-erased: string | int | bool | bytes | null
    ↓
InputMatcher.matches()   ← compare the value
    ↓
bool                     ← did it match?
    ↓
Predicate.evaluate()     ← combine with other conditions (AND/OR/NOT)
    ↓
bool                     ← combined result
    ↓
Matcher.evaluate()       ← find the first matching rule
    ↓
Action                   ← your decision (or null if nothing matched)
</code></pre>
<p>Two things to notice:</p>
<ol>
<li>
<p><strong>The pipeline splits at <code>MatchingData</code>.</strong> Everything above is domain-specific (knows about your context type). Everything below is domain-agnostic (works with any domain).</p>
</li>
<li>
<p><strong>The same <code>InputMatcher</code> works everywhere.</strong> An <code>ExactMatcher</code> doesn’t care whether the string came from an HTTP path or a Claude Code tool name. It matches strings.</p>
</li>
</ol>
<h2 id="concrete-example"><a class="header" href="#concrete-example">Concrete Example</a></h2>
<p>Route <code>GET /api/users</code> to the API backend:</p>
<p><strong>Python:</strong></p>
<pre><code class="language-python">from xuma import SinglePredicate, PrefixMatcher, Matcher, FieldMatcher, Action
from xuma.http import HttpRequest, PathInput

# DataInput: extract the path from the request
# InputMatcher: check if the path starts with /api
predicate = SinglePredicate(
    input=PathInput(),            # domain-specific
    matcher=PrefixMatcher("/api") # domain-agnostic
)

matcher = Matcher(
    matcher_list=(
        FieldMatcher(predicate=predicate, on_match=Action("api_backend")),
    ),
)

request = HttpRequest(method="GET", raw_path="/api/users")
assert matcher.evaluate(request) == "api_backend"
</code></pre>
<p><strong>Rust:</strong></p>
<pre><code class="language-rust ignore">use rumi::prelude::*;
use rumi_http::*;

let predicate = Predicate::Single(SinglePredicate::new(
    Box::new(SimplePathInput),         // domain-specific
    Box::new(PrefixMatcher::new("/api")), // domain-agnostic
));

let matcher: Matcher&lt;HttpRequest, &amp;str&gt; = Matcher::new(
    vec![FieldMatcher::new(predicate, OnMatch::Action("api_backend"))],
    None,
);

let request = HttpRequest::builder().method("GET").path("/api/users").build();
assert_eq!(matcher.evaluate(&amp;request), Some(&amp;"api_backend"));</code></pre>
<p><strong>TypeScript:</strong></p>
<pre><code class="language-typescript">import { SinglePredicate, PrefixMatcher, Matcher, FieldMatcher, Action } from "xuma";
import { HttpRequest, PathInput } from "xuma/http";

const predicate = new SinglePredicate(
  new PathInput(),             // domain-specific
  new PrefixMatcher("/api"),   // domain-agnostic
);

const matcher = new Matcher(
  [new FieldMatcher(predicate, new Action("api_backend"))],
);

const request = new HttpRequest("GET", "/api/users");
console.assert(matcher.evaluate(request) === "api_backend");
</code></pre>
<p>Same structure in all three languages. Same result.</p>
<h2 id="the-same-pipeline-different-domain"><a class="header" href="#the-same-pipeline-different-domain">The Same Pipeline, Different Domain</a></h2>
<p>The power of this split: the same <code>PrefixMatcher</code> works for HTTP paths and custom event types.</p>
<pre><code class="language-python">from dataclasses import dataclass
from xuma import SinglePredicate, PrefixMatcher, Matcher, FieldMatcher, Action, MatchingData

# Custom context
@dataclass(frozen=True)
class CloudEvent:
    type: str
    source: str

# Custom DataInput — extract the event type
@dataclass(frozen=True)
class EventTypeInput:
    def get(self, ctx: CloudEvent) -&gt; MatchingData:
        return ctx.type

# Use the SAME PrefixMatcher — it doesn't know about CloudEvent
predicate = SinglePredicate(
    input=EventTypeInput(),
    matcher=PrefixMatcher("com.example."),
)

matcher = Matcher(
    matcher_list=(
        FieldMatcher(predicate=predicate, on_match=Action("handle_event")),
    ),
)

event = CloudEvent(type="com.example.user.created", source="api")
assert matcher.evaluate(event) == "handle_event"
</code></pre>
<p><code>PrefixMatcher</code> operates on <code>MatchingData</code> (the erased string), not on <code>CloudEvent</code> or <code>HttpRequest</code>. Domain adapters (<code>PathInput</code>, <code>EventTypeInput</code>) are context-specific. Matchers are universal.</p>
<h2 id="pipeline-stages"><a class="header" href="#pipeline-stages">Pipeline Stages</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Stage</th><th>Role</th><th>Generic?</th><th>Examples</th></tr>
</thead>
<tbody>
<tr><td><strong>Context</strong></td><td>Your domain data</td><td>Yes (<code>Ctx</code>)</td><td><code>HttpRequest</code>, <code>HookContext</code>, your type</td></tr>
<tr><td><strong>DataInput</strong></td><td>Extract a value</td><td>Yes (<code>Ctx</code>)</td><td><code>PathInput</code>, <code>ToolNameInput</code>, your input</td></tr>
<tr><td><strong>MatchingData</strong></td><td>Type-erased value</td><td>No</td><td><code>string</code>, <code>int</code>, <code>bool</code>, <code>bytes</code>, <code>null</code></td></tr>
<tr><td><strong>InputMatcher</strong></td><td>Match the value</td><td>No</td><td><code>ExactMatcher</code>, <code>PrefixMatcher</code>, <code>RegexMatcher</code></td></tr>
<tr><td><strong>Predicate</strong></td><td>Boolean logic</td><td>Yes (<code>Ctx</code>)</td><td><code>SinglePredicate</code>, <code>And</code>, <code>Or</code>, <code>Not</code></td></tr>
<tr><td><strong>Matcher</strong></td><td>First-match-wins</td><td>Yes (<code>Ctx</code>, <code>A</code>)</td><td>Routes to actions</td></tr>
<tr><td><strong>Action</strong></td><td>Your decision</td><td>Yes (<code>A</code>)</td><td>Strings, enums, structs — anything</td></tr>
</tbody>
</table>
</div>
<p>The boundary at <code>MatchingData</code> is what makes the engine domain-agnostic. Cross it once, and every matcher works for every domain.</p>
<h2 id="next"><a class="header" href="#next">Next</a></h2>
<ul>
<li><a href="#type-erasure-and-ports">Type Erasure and Ports</a> — why <code>InputMatcher</code> is non-generic</li>
<li><a href="#predicate-composition">Predicate Composition</a> — combining conditions with AND/OR/NOT</li>
<li><a href="#first-match-wins-semantics">First-Match-Wins Semantics</a> — evaluation order and nested matchers</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="type-erasure-and-ports"><a class="header" href="#type-erasure-and-ports">Type Erasure and Ports</a></h1>
<p>Why does the same <code>ExactMatcher</code> work for HTTP headers and custom event types? Because type erasure happens at the data level, not the matcher level.</p>
<h2 id="the-problem"><a class="header" href="#the-problem">The Problem</a></h2>
<p>If <code>InputMatcher</code> were generic over the context type, every domain would need its own matcher implementations:</p>
<pre><code class="language-python"># If InputMatcher were generic (DON'T DO THIS)
class InputMatcher[Ctx]:
    def matches(self, ctx: Ctx) -&gt; bool: ...

# You'd need separate matchers for each domain
http_matcher = ExactMatcher[HttpRequest]("/api")
event_matcher = ExactMatcher[CloudEvent]("com.example")
# Can't put them in the same registry. No code reuse.
</code></pre>
<h2 id="the-solution"><a class="header" href="#the-solution">The Solution</a></h2>
<p>Erase the type at the <strong>data level</strong>. Extract the value first, then match the erased value:</p>
<pre><code class="language-python"># DataInput is generic — knows about the context
class DataInput[Ctx]:
    def get(self, ctx: Ctx) -&gt; MatchingData: ...

# InputMatcher is NOT generic — knows only about MatchingData
class InputMatcher:
    def matches(self, value: MatchingData) -&gt; bool: ...
</code></pre>
<p>Now one <code>ExactMatcher</code> works everywhere:</p>
<pre><code class="language-python"># HTTP path matching
path_pred = SinglePredicate(input=PathInput(), matcher=ExactMatcher("/api"))

# Event type matching — SAME ExactMatcher
event_pred = SinglePredicate(input=EventTypeInput(), matcher=ExactMatcher("/api"))
</code></pre>
<h2 id="matchingdata-the-bridge"><a class="header" href="#matchingdata-the-bridge">MatchingData: The Bridge</a></h2>
<p><code>MatchingData</code> is the boundary between domain-specific and domain-agnostic code. Same name in all three implementations:</p>
<p><strong>Rust:</strong></p>
<pre><code class="language-rust ignore">pub enum MatchingData {
    None,
    String(String),
    Int(i64),
    Bool(bool),
    Bytes(Vec&lt;u8&gt;),
    Custom(Box&lt;dyn CustomMatchData&gt;),
}</code></pre>
<p><strong>Python:</strong></p>
<pre><code class="language-python">type MatchingData = str | int | bool | bytes | None
</code></pre>
<p><strong>TypeScript:</strong></p>
<pre><code class="language-typescript">type MatchingData = string | number | boolean | Uint8Array | null;
</code></pre>
<p>Rust uses an enum. Python and TypeScript use union types. Same concept, idiomatic syntax.</p>
<h2 id="the-two-ports"><a class="header" href="#the-two-ports">The Two Ports</a></h2>
<p>Type erasure creates two ports — the seams where domain-specific and domain-agnostic code meet:</p>
<pre><code class="language-text">┌─────────────────────────────────────────┐
│         Domain-Specific Layer           │
│   PathInput, HeaderInput, ToolNameInput │
│   (knows about Ctx)                     │
└──────────────┬──────────────────────────┘
               │ get() returns MatchingData
               ↓
┌──────────────▼──────────────────────────┐
│         Domain-Agnostic Layer           │
│   ExactMatcher, PrefixMatcher, Regex... │
│   (knows only about MatchingData)       │
└─────────────────────────────────────────┘
</code></pre>
<p><strong>Extraction port (<code>DataInput</code>)</strong> — converts <code>Ctx</code> into <code>MatchingData</code>. Domain-specific. You write one per field you want to match.</p>
<p><strong>Matching port (<code>InputMatcher</code>)</strong> — converts <code>MatchingData</code> into <code>bool</code>. Domain-agnostic. x.uma ships five: <code>ExactMatcher</code>, <code>PrefixMatcher</code>, <code>SuffixMatcher</code>, <code>ContainsMatcher</code>, <code>RegexMatcher</code>.</p>
<h2 id="cross-language-comparison"><a class="header" href="#cross-language-comparison">Cross-Language Comparison</a></h2>
<p>The same architecture in all three languages:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Concept</th><th>Rust</th><th>Python</th><th>TypeScript</th></tr>
</thead>
<tbody>
<tr><td>Erased data</td><td><code>enum MatchingData</code></td><td><code>type MatchingData</code> (union)</td><td><code>type MatchingData</code> (union)</td></tr>
<tr><td>Extraction port</td><td><code>trait DataInput&lt;Ctx&gt;</code></td><td><code>Protocol[Ctx]</code></td><td><code>interface DataInput&lt;Ctx&gt;</code></td></tr>
<tr><td>Matching port</td><td><code>trait InputMatcher</code></td><td><code>Protocol</code></td><td><code>interface InputMatcher</code></td></tr>
<tr><td>Predicate tree</td><td><code>enum Predicate&lt;Ctx&gt;</code></td><td><code>type Predicate[Ctx]</code> (union)</td><td><code>type Predicate&lt;Ctx&gt;</code> (union)</td></tr>
<tr><td>Pattern match</td><td><code>match</code> expression</td><td><code>match</code>/<code>case</code></td><td><code>instanceof</code> checks</td></tr>
<tr><td>Immutability</td><td>Owned types</td><td><code>@dataclass(frozen=True)</code></td><td><code>readonly</code> fields</td></tr>
</tbody>
</table>
</div>
<h2 id="the-none-convention"><a class="header" href="#the-none-convention">The None Convention</a></h2>
<p>When a <code>DataInput</code> returns <code>None</code>/<code>null</code> (data not present), the predicate evaluates to <code>false</code> without calling the matcher. This is enforced across all implementations.</p>
<pre><code class="language-python">from xuma import SinglePredicate, ExactMatcher
from xuma.http import HttpRequest, HeaderInput

predicate = SinglePredicate(
    input=HeaderInput("x-api-key"),
    matcher=ExactMatcher("secret"),
)

# Header not present → DataInput returns None → predicate returns False
request = HttpRequest(headers={})
assert predicate.evaluate(request) == False
</code></pre>
<p>The matcher never sees <code>None</code>. Missing data is handled upstream. This is a security guarantee: missing data never accidentally matches.</p>
<h2 id="next-1"><a class="header" href="#next-1">Next</a></h2>
<ul>
<li><a href="#the-matching-pipeline">The Matching Pipeline</a> — how data flows through the full evaluation</li>
<li><a href="#predicate-composition">Predicate Composition</a> — combining predicates with AND/OR/NOT</li>
<li><a href="#adding-a-domain-adapter">Adding a Domain Adapter</a> — create your own <code>DataInput</code> types</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="predicate-composition"><a class="header" href="#predicate-composition">Predicate Composition</a></h1>
<p>Predicates combine conditions with Boolean logic. AND, OR, NOT — compose them freely.</p>
<h2 id="singlepredicate"><a class="header" href="#singlepredicate">SinglePredicate</a></h2>
<p>The building block. Pairs a <code>DataInput</code> (extract data) with an <code>InputMatcher</code> (match data):</p>
<pre><code class="language-python">from xuma import SinglePredicate, PrefixMatcher
from xuma.http import PathInput

# "Does the path start with /api?"
predicate = SinglePredicate(input=PathInput(), matcher=PrefixMatcher("/api"))
</code></pre>
<p>Evaluation: extract the path, check if it starts with <code>/api</code>, return <code>bool</code>.</p>
<h2 id="and"><a class="header" href="#and">And</a></h2>
<p>All conditions must be true. Short-circuits on the first <code>false</code>.</p>
<pre><code class="language-python">from xuma import And, SinglePredicate, PrefixMatcher, ExactMatcher
from xuma.http import PathInput, MethodInput

# "Is it GET /api/*?"
predicate = And((
    SinglePredicate(PathInput(), PrefixMatcher("/api")),
    SinglePredicate(MethodInput(), ExactMatcher("GET")),
))
</code></pre>
<p><strong>Rust:</strong></p>
<pre><code class="language-rust ignore">let predicate = Predicate::And(vec![
    Predicate::Single(SinglePredicate::new(
        Box::new(SimplePathInput), Box::new(PrefixMatcher::new("/api")),
    )),
    Predicate::Single(SinglePredicate::new(
        Box::new(SimpleMethodInput), Box::new(ExactMatcher::new("GET")),
    )),
]);</code></pre>
<p><strong>TypeScript:</strong></p>
<pre><code class="language-typescript">const predicate = new And([
  new SinglePredicate(new PathInput(), new PrefixMatcher("/api")),
  new SinglePredicate(new MethodInput(), new ExactMatcher("GET")),
]);
</code></pre>
<h2 id="or"><a class="header" href="#or">Or</a></h2>
<p>At least one condition must be true. Short-circuits on the first <code>true</code>.</p>
<pre><code class="language-python">from xuma import Or, SinglePredicate, PrefixMatcher
from xuma.http import PathInput

# "Does the path start with /api or /admin?"
predicate = Or((
    SinglePredicate(PathInput(), PrefixMatcher("/api")),
    SinglePredicate(PathInput(), PrefixMatcher("/admin")),
))
</code></pre>
<h2 id="not"><a class="header" href="#not">Not</a></h2>
<p>Negate any predicate. Useful for exclusion rules.</p>
<pre><code class="language-python">from xuma import Not, SinglePredicate, ExactMatcher
from xuma.http import MethodInput

# "Is it NOT a POST request?"
predicate = Not(SinglePredicate(MethodInput(), ExactMatcher("POST")))
</code></pre>
<h2 id="nesting"><a class="header" href="#nesting">Nesting</a></h2>
<p>Predicates nest arbitrarily up to <code>MAX_DEPTH</code> (32 levels):</p>
<pre><code class="language-python">from xuma import And, Or, SinglePredicate, PrefixMatcher, ExactMatcher
from xuma.http import PathInput, MethodInput, HeaderInput

# "(GET or POST) to /api/* with an auth header"
predicate = And((
    SinglePredicate(PathInput(), PrefixMatcher("/api")),
    Or((
        SinglePredicate(MethodInput(), ExactMatcher("GET")),
        SinglePredicate(MethodInput(), ExactMatcher("POST")),
    )),
    SinglePredicate(HeaderInput("authorization"), PrefixMatcher("Bearer ")),
))
</code></pre>
<p>Trees exceeding 32 levels raise <code>MatcherError</code> at construction time. Most real matchers use 3-5 levels.</p>
<h2 id="empty-and--or"><a class="header" href="#empty-and--or">Empty And / Or</a></h2>
<p>Edge cases with empty predicate lists:</p>
<ul>
<li><strong>Empty <code>And</code></strong> returns <code>true</code> (vacuous truth — no conditions to fail).</li>
<li><strong>Empty <code>Or</code></strong> returns <code>false</code> (no conditions to pass).</li>
</ul>
<p>Standard Boolean algebra. Rarely constructed directly.</p>
<h2 id="the-none-to-false-rule"><a class="header" href="#the-none-to-false-rule">The None-to-False Rule</a></h2>
<p>If a <code>DataInput</code> returns <code>None</code>/<code>null</code>, the <code>SinglePredicate</code> evaluates to <code>false</code> without calling the matcher. The matcher never sees missing data.</p>
<pre><code class="language-python">from xuma import SinglePredicate, ExactMatcher
from xuma.http import HttpRequest, HeaderInput

predicate = SinglePredicate(
    input=HeaderInput("x-api-key"),
    matcher=ExactMatcher("secret"),
)

# Header not present → None → false
request = HttpRequest(headers={})
assert predicate.evaluate(request) == False
</code></pre>
<p>This is a security invariant: missing data never accidentally matches.</p>
<h2 id="cross-language-types"><a class="header" href="#cross-language-types">Cross-Language Types</a></h2>
<p>Same predicate types across all implementations:</p>
<p><strong>Rust:</strong></p>
<pre><code class="language-rust ignore">pub enum Predicate&lt;Ctx&gt; {
    Single(SinglePredicate&lt;Ctx&gt;),
    And(Vec&lt;Predicate&lt;Ctx&gt;&gt;),
    Or(Vec&lt;Predicate&lt;Ctx&gt;&gt;),
    Not(Box&lt;Predicate&lt;Ctx&gt;&gt;),
}</code></pre>
<p><strong>Python:</strong></p>
<pre><code class="language-python">type Predicate[Ctx] = SinglePredicate[Ctx] | And[Ctx] | Or[Ctx] | Not[Ctx]
</code></pre>
<p><strong>TypeScript:</strong></p>
<pre><code class="language-typescript">type Predicate&lt;Ctx&gt; = SinglePredicate&lt;Ctx&gt; | And&lt;Ctx&gt; | Or&lt;Ctx&gt; | Not&lt;Ctx&gt;;
</code></pre>
<p>Same structure. Same short-circuit behavior. Same depth limits.</p>
<h2 id="next-2"><a class="header" href="#next-2">Next</a></h2>
<ul>
<li><a href="#the-matching-pipeline">The Matching Pipeline</a> — where predicates fit in the flow</li>
<li><a href="#first-match-wins-semantics">First-Match-Wins Semantics</a> — how matchers use predicates to choose actions</li>
<li><a href="#build-an-http-router">Build an HTTP Router</a> — predicates in practice</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="first-match-wins-semantics"><a class="header" href="#first-match-wins-semantics">First-Match-Wins Semantics</a></h1>
<p>Evaluation order matters. x.uma follows xDS matcher semantics — six rules govern how a matcher tree produces a decision.</p>
<h2 id="the-six-rules"><a class="header" href="#the-six-rules">The Six Rules</a></h2>
<ol>
<li><strong>First-match-wins</strong> — first matching predicate’s action is returned</li>
<li><strong>OnMatch exclusivity</strong> — action XOR nested matcher, never both</li>
<li><strong>Nested matcher failure</strong> — continues to next field matcher</li>
<li><strong>on_no_match fallback</strong> — used only when nothing matches</li>
<li><strong>None-to-false</strong> — missing data means predicate is false</li>
<li><strong>Depth validation</strong> — max 32 levels, checked at construction</li>
</ol>
<h2 id="rule-1-first-match-wins"><a class="header" href="#rule-1-first-match-wins">Rule 1: First-Match-Wins</a></h2>
<p>Matchers evaluate field matchers in order. The first matching predicate wins. Later matches are never consulted.</p>
<pre><code class="language-python">from xuma import Matcher, FieldMatcher, SinglePredicate, PrefixMatcher, Action
from xuma.http import HttpRequest, PathInput

matcher = Matcher(
    matcher_list=(
        FieldMatcher(
            predicate=SinglePredicate(PathInput(), PrefixMatcher("/api")),
            on_match=Action("api_backend"),
        ),
        FieldMatcher(
            predicate=SinglePredicate(PathInput(), PrefixMatcher("/api/v2")),
            on_match=Action("api_v2_backend"),  # NEVER REACHED for /api/v2 paths
        ),
    ),
)

request = HttpRequest(raw_path="/api/v2/users")
assert matcher.evaluate(request) == "api_backend"  # First rule wins
</code></pre>
<p>The path <code>/api/v2/users</code> matches both rules, but the first one wins. <strong>Order matters.</strong> Put specific rules before general ones.</p>
<h2 id="rule-2-onmatch-exclusivity"><a class="header" href="#rule-2-onmatch-exclusivity">Rule 2: OnMatch Exclusivity</a></h2>
<p>Each <code>OnMatch</code> is either an action (terminal) or a nested matcher (continue evaluation). Never both. The type system enforces this:</p>
<p><strong>Rust:</strong></p>
<pre><code class="language-rust ignore">pub enum OnMatch&lt;Ctx, A&gt; {
    Action(A),
    Matcher(Box&lt;Matcher&lt;Ctx, A&gt;&gt;),
}</code></pre>
<p><strong>Python:</strong></p>
<pre><code class="language-python">type OnMatch[Ctx, A] = Action[A] | NestedMatcher[Ctx, A]
</code></pre>
<p>Illegal states are unrepresentable. When a predicate matches, the outcome is unambiguous.</p>
<h2 id="rule-3-nested-matcher-failure"><a class="header" href="#rule-3-nested-matcher-failure">Rule 3: Nested Matcher Failure</a></h2>
<p>If a predicate matches but its nested matcher returns <code>None</code>, evaluation continues to the next field matcher. There is no implicit fallback.</p>
<pre><code class="language-python">from xuma import Matcher, FieldMatcher, NestedMatcher, SinglePredicate, ExactMatcher, Action
from xuma.http import HttpRequest, MethodInput, PathInput

# Nested matcher: only matches POST
nested = Matcher(
    matcher_list=(
        FieldMatcher(
            predicate=SinglePredicate(MethodInput(), ExactMatcher("POST")),
            on_match=Action("create"),
        ),
    ),
    on_no_match=None,  # No fallback inside nested
)

# Parent matcher
matcher = Matcher(
    matcher_list=(
        FieldMatcher(
            predicate=SinglePredicate(PathInput(), PrefixMatcher("/api")),
            on_match=NestedMatcher(nested),
        ),
        FieldMatcher(
            predicate=SinglePredicate(PathInput(), PrefixMatcher("/health")),
            on_match=Action("health_check"),
        ),
    ),
    on_no_match=Action("not_found"),
)

# GET /api → path matches, enters nested → method doesn't match → nested returns None
# → continues to /health → doesn't match → falls to on_no_match
request = HttpRequest(method="GET", raw_path="/api/users")
assert matcher.evaluate(request) == "not_found"
</code></pre>
<p><strong>Common mistake:</strong> expecting nested failure to use the parent’s <code>on_no_match</code>. It doesn’t. Nested failure means “this branch didn’t match, try the next field matcher.”</p>
<h2 id="rule-4-on_no_match-fallback"><a class="header" href="#rule-4-on_no_match-fallback">Rule 4: on_no_match Fallback</a></h2>
<p>If no predicate in <code>matcher_list</code> matches, the matcher consults <code>on_no_match</code>. If absent, returns <code>None</code>/<code>null</code>.</p>
<pre><code class="language-python"># With fallback
matcher = Matcher(
    matcher_list=(
        FieldMatcher(
            predicate=SinglePredicate(PathInput(), PrefixMatcher("/api")),
            on_match=Action("api"),
        ),
    ),
    on_no_match=Action("default"),  # Used when no rules match
)

assert matcher.evaluate(HttpRequest(raw_path="/other")) == "default"
</code></pre>
<p><code>on_no_match</code> applies only when no predicate matches. It does not apply when a nested matcher fails (Rule 3).</p>
<h2 id="rule-5-none-to-false"><a class="header" href="#rule-5-none-to-false">Rule 5: None-to-False</a></h2>
<p>Covered in <a href="#predicate-composition">Predicate Composition</a>. When <code>DataInput</code> returns <code>None</code>/<code>null</code>, the predicate evaluates to <code>false</code> without calling the matcher. Missing data never accidentally matches.</p>
<h2 id="rule-6-depth-validation"><a class="header" href="#rule-6-depth-validation">Rule 6: Depth Validation</a></h2>
<p>Matcher trees exceeding <code>MAX_DEPTH</code> (32 levels) are rejected at construction time.</p>
<pre><code class="language-python"># Attempting to build a tree deeper than 32 levels raises MatcherError
</code></pre>
<p>Validation happens at construction, not evaluation. If a <code>Matcher</code> object exists, it’s known to be valid. Parse, don’t validate.</p>
<h2 id="walkthrough"><a class="header" href="#walkthrough">Walkthrough</a></h2>
<p>All six rules in one example:</p>
<pre><code class="language-python">from xuma import Matcher, FieldMatcher, NestedMatcher, SinglePredicate, And
from xuma import PrefixMatcher, ExactMatcher, Action
from xuma.http import HttpRequest, PathInput, MethodInput, HeaderInput

# Nested: POST with auth header
auth_required = Matcher(
    matcher_list=(
        FieldMatcher(
            predicate=And((
                SinglePredicate(MethodInput(), ExactMatcher("POST")),
                SinglePredicate(HeaderInput("authorization"), PrefixMatcher("Bearer ")),
            )),
            on_match=Action("authenticated_api"),
        ),
    ),
    on_no_match=None,
)

# Top-level
matcher = Matcher(
    matcher_list=(
        FieldMatcher(
            predicate=SinglePredicate(PathInput(), PrefixMatcher("/api")),
            on_match=NestedMatcher(auth_required),
        ),
        FieldMatcher(
            predicate=SinglePredicate(PathInput(), PrefixMatcher("/health")),
            on_match=Action("health_check"),
        ),
    ),
    on_no_match=Action("not_found"),
)

# POST /api with auth → nested matches → "authenticated_api"
r1 = HttpRequest(method="POST", raw_path="/api/users",
                 headers={"authorization": "Bearer token"})
assert matcher.evaluate(r1) == "authenticated_api"

# GET /api → nested fails (not POST) → continues → /health doesn't match → "not_found"
r2 = HttpRequest(method="GET", raw_path="/api/users")
assert matcher.evaluate(r2) == "not_found"

# GET /health → second rule matches → "health_check"
r3 = HttpRequest(method="GET", raw_path="/health")
assert matcher.evaluate(r3) == "health_check"
</code></pre>
<p>Walk through <code>GET /api</code>:</p>
<ol>
<li>First field matcher: path matches <code>/api</code> (Rule 1)</li>
<li>OnMatch is nested matcher (Rule 2: exclusive)</li>
<li>Nested: method is GET, not POST — predicate false</li>
<li>Nested returns <code>None</code> — no <code>on_no_match</code> (Rule 4)</li>
<li>Nested failure propagates (Rule 3) — continue to next field matcher</li>
<li>Second field matcher: path <code>/api/users</code> doesn’t start with <code>/health</code></li>
<li>No more field matchers — use <code>on_no_match</code> (Rule 4)</li>
<li>Return <code>"not_found"</code></li>
</ol>
<h2 id="next-3"><a class="header" href="#next-3">Next</a></h2>
<ul>
<li><a href="#the-matching-pipeline">The Matching Pipeline</a> — where evaluation fits in the data flow</li>
<li><a href="#predicate-composition">Predicate Composition</a> — the Boolean logic that drives evaluation</li>
<li><a href="#build-an-http-router">Build an HTTP Router</a> — apply these semantics to real routing</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="build-an-http-router"><a class="header" href="#build-an-http-router">Build an HTTP Router</a></h1>
<p>This tutorial builds an HTTP route matcher step by step. You’ll start with a single route and finish with a multi-route matcher that handles paths, methods, headers, and query parameters.</p>
<p>Examples are in Python. The same patterns apply to TypeScript and Rust — see the <a href="#python-quick-start">Getting Started</a> guides for language-specific syntax.</p>
<h2 id="step-1-match-a-single-path"><a class="header" href="#step-1-match-a-single-path">Step 1: Match a Single Path</a></h2>
<p>Route requests starting with <code>/api</code> to the API backend:</p>
<pre><code class="language-python">from xuma import Matcher, FieldMatcher, SinglePredicate, Action, PrefixMatcher
from xuma.http import HttpRequest, PathInput

matcher = Matcher(
    matcher_list=(
        FieldMatcher(
            predicate=SinglePredicate(PathInput(), PrefixMatcher("/api")),
            on_match=Action("api_backend"),
        ),
    ),
    on_no_match=Action("not_found"),
)

assert matcher.evaluate(HttpRequest(raw_path="/api/users")) == "api_backend"
assert matcher.evaluate(HttpRequest(raw_path="/other")) == "not_found"
</code></pre>
<p><code>PrefixMatcher("/api")</code> matches any path starting with <code>/api</code>. The <code>on_no_match</code> fallback catches everything else.</p>
<h2 id="step-2-add-method-matching"><a class="header" href="#step-2-add-method-matching">Step 2: Add Method Matching</a></h2>
<p>Only allow GET requests to the API:</p>
<pre><code class="language-python">from xuma import And, ExactMatcher
from xuma.http import MethodInput

predicate = And((
    SinglePredicate(PathInput(), PrefixMatcher("/api")),
    SinglePredicate(MethodInput(), ExactMatcher("GET")),
))

matcher = Matcher(
    matcher_list=(
        FieldMatcher(predicate=predicate, on_match=Action("api_get")),
    ),
    on_no_match=Action("not_found"),
)

assert matcher.evaluate(HttpRequest(method="GET", raw_path="/api/users")) == "api_get"
assert matcher.evaluate(HttpRequest(method="POST", raw_path="/api/users")) == "not_found"
</code></pre>
<p><code>And</code> combines conditions. All must be true. Short-circuits on the first false.</p>
<h2 id="step-3-multiple-routes"><a class="header" href="#step-3-multiple-routes">Step 3: Multiple Routes</a></h2>
<p>Add a health check endpoint:</p>
<pre><code class="language-python">matcher = Matcher(
    matcher_list=(
        FieldMatcher(
            predicate=And((
                SinglePredicate(PathInput(), PrefixMatcher("/api")),
                SinglePredicate(MethodInput(), ExactMatcher("GET")),
            )),
            on_match=Action("api_get"),
        ),
        FieldMatcher(
            predicate=SinglePredicate(PathInput(), ExactMatcher("/health")),
            on_match=Action("health"),
        ),
    ),
    on_no_match=Action("not_found"),
)

assert matcher.evaluate(HttpRequest(method="GET", raw_path="/api/users")) == "api_get"
assert matcher.evaluate(HttpRequest(raw_path="/health")) == "health"
assert matcher.evaluate(HttpRequest(method="POST", raw_path="/api/users")) == "not_found"
</code></pre>
<p>Field matchers evaluate in order. First match wins. <code>/health</code> uses <code>ExactMatcher</code> — only the exact path matches, not <code>/health/check</code>.</p>
<h2 id="step-4-header-conditions"><a class="header" href="#step-4-header-conditions">Step 4: Header Conditions</a></h2>
<p>Require an authorization header for the API:</p>
<pre><code class="language-python">from xuma.http import HeaderInput

api_predicate = And((
    SinglePredicate(PathInput(), PrefixMatcher("/api")),
    SinglePredicate(MethodInput(), ExactMatcher("GET")),
    SinglePredicate(HeaderInput("authorization"), PrefixMatcher("Bearer ")),
))

matcher = Matcher(
    matcher_list=(
        FieldMatcher(predicate=api_predicate, on_match=Action("api_authenticated")),
        FieldMatcher(
            predicate=SinglePredicate(PathInput(), ExactMatcher("/health")),
            on_match=Action("health"),
        ),
    ),
    on_no_match=Action("unauthorized"),
)

# With valid auth header
request = HttpRequest(
    method="GET",
    raw_path="/api/users",
    headers={"authorization": "Bearer token123"},
)
assert matcher.evaluate(request) == "api_authenticated"

# Without auth header — HeaderInput returns None → predicate is false
request = HttpRequest(method="GET", raw_path="/api/users")
assert matcher.evaluate(request) == "unauthorized"
</code></pre>
<p>When the <code>authorization</code> header is missing, <code>HeaderInput</code> returns <code>None</code>. The None-to-false rule makes the predicate false without calling the matcher. Missing data never accidentally matches.</p>
<h2 id="step-5-use-the-compiler"><a class="header" href="#step-5-use-the-compiler">Step 5: Use the Compiler</a></h2>
<p>The Gateway API compiler builds the same matcher from declarative config:</p>
<pre><code class="language-python">from xuma.http import (
    HttpRouteMatch, HttpPathMatch, HttpHeaderMatch,
    compile_route_matches, HttpRequest,
)

routes = [
    HttpRouteMatch(
        path=HttpPathMatch(type="PathPrefix", value="/api"),
        method="GET",
        headers=[
            HttpHeaderMatch(type="RegularExpression", name="authorization", value="^Bearer .+$"),
        ],
    ),
    HttpRouteMatch(
        path=HttpPathMatch(type="Exact", value="/health"),
    ),
]

matcher = compile_route_matches(routes, "allowed", on_no_match="denied")

# Authenticated API request
request = HttpRequest(
    method="GET",
    raw_path="/api/users",
    headers={"authorization": "Bearer token123"},
)
assert matcher.evaluate(request) == "allowed"

# Health check (no auth needed)
assert matcher.evaluate(HttpRequest(raw_path="/health")) == "allowed"

# Unauthenticated API request
assert matcher.evaluate(HttpRequest(method="GET", raw_path="/api/users")) == "denied"
</code></pre>
<p>The compiler:</p>
<ul>
<li>ANDs conditions within each <code>HttpRouteMatch</code></li>
<li>ORs multiple <code>HttpRouteMatch</code> entries</li>
<li>Returns the first matching route’s action</li>
</ul>
<p>This is equivalent to the manual construction in Steps 1-4, with less boilerplate.</p>
<h2 id="step-6-custom-action-types"><a class="header" href="#step-6-custom-action-types">Step 6: Custom Action Types</a></h2>
<p>Use structured actions instead of strings:</p>
<pre><code class="language-python">from dataclasses import dataclass

@dataclass(frozen=True)
class RouteAction:
    backend: str
    timeout_ms: int = 5000

routes = [
    HttpRouteMatch(
        path=HttpPathMatch(type="PathPrefix", value="/api"),
        method="GET",
    ),
]

matcher = compile_route_matches(
    routes,
    RouteAction(backend="api-service", timeout_ms=10000),
    on_no_match=RouteAction(backend="default", timeout_ms=1000),
)

result = matcher.evaluate(HttpRequest(method="GET", raw_path="/api/users"))
assert result.backend == "api-service"
assert result.timeout_ms == 10000
</code></pre>
<p>The generic <code>A</code> in <code>Matcher[HttpRequest, A]</code> accepts any type. Strings, dataclasses, enums — the engine doesn’t interpret actions, it returns them.</p>
<h2 id="what-you-built"><a class="header" href="#what-you-built">What You Built</a></h2>
<p>A route matcher that:</p>
<ol>
<li>Evaluates rules in order (first match wins)</li>
<li>Combines path, method, and header conditions with AND</li>
<li>Handles missing data safely (None-to-false)</li>
<li>Supports both manual construction and declarative config</li>
<li>Works with any action type</li>
</ol>
<p>The same matcher can be built in TypeScript or Rust with identical semantics.</p>
<h2 id="next-4"><a class="header" href="#next-4">Next</a></h2>
<ul>
<li><a href="#http-matching">HTTP Matching</a> — full HTTP domain reference</li>
<li><a href="#first-match-wins-semantics">First-Match-Wins Semantics</a> — evaluation rules in depth</li>
<li><a href="#predicate-composition">Predicate Composition</a> — AND, OR, NOT</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="http-matching"><a class="header" href="#http-matching">HTTP Matching</a></h1>
<p>The HTTP domain provides inputs, config types, and a compiler for matching HTTP requests. It ships with all five implementations.</p>
<h2 id="inputs"><a class="header" href="#inputs">Inputs</a></h2>
<p>Four <code>DataInput</code> types extract fields from HTTP requests:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Input</th><th>Extracts</th><th>Returns</th></tr>
</thead>
<tbody>
<tr><td><code>PathInput</code></td><td>Request path</td><td><code>string</code></td></tr>
<tr><td><code>MethodInput</code></td><td>HTTP method</td><td><code>string</code></td></tr>
<tr><td><code>HeaderInput(name)</code></td><td>Header value</td><td><code>string</code> or <code>null</code></td></tr>
<tr><td><code>QueryParamInput(name)</code></td><td>Query parameter</td><td><code>string</code> or <code>null</code></td></tr>
</tbody>
</table>
</div>
<p><code>HeaderInput</code> and <code>QueryParamInput</code> return <code>null</code> when the field is absent. The None-to-false rule ensures missing fields never match.</p>
<h2 id="the-gateway-api-compiler-2"><a class="header" href="#the-gateway-api-compiler-2">The Gateway API Compiler</a></h2>
<p>The compiler transforms declarative config into matcher trees. It mirrors <a href="https://gateway-api.sigs.k8s.io/">Kubernetes Gateway API</a> <code>HTTPRouteMatch</code> semantics:</p>
<ul>
<li>Within a single <code>HttpRouteMatch</code>, all conditions are <strong>ANDed</strong></li>
<li>Multiple <code>HttpRouteMatch</code> entries are <strong>ORed</strong> (first match wins)</li>
</ul>
<h3 id="python"><a class="header" href="#python">Python</a></h3>
<pre><code class="language-python">from xuma.http import HttpRouteMatch, HttpPathMatch, HttpHeaderMatch, compile_route_matches

routes = [
    HttpRouteMatch(
        path=HttpPathMatch(type="PathPrefix", value="/api"),
        method="GET",
        headers=[
            HttpHeaderMatch(type="Exact", name="accept", value="application/json"),
        ],
    ),
    HttpRouteMatch(
        path=HttpPathMatch(type="PathPrefix", value="/health"),
    ),
]

matcher = compile_route_matches(routes, "allowed", on_no_match="denied")
</code></pre>
<h3 id="typescript"><a class="header" href="#typescript">TypeScript</a></h3>
<pre><code class="language-typescript">import { compileRouteMatches } from "xuma/http";
import type { HttpRouteMatch } from "xuma/http";

const routes: HttpRouteMatch[] = [
  {
    path: { type: "PathPrefix", value: "/api" },
    method: "GET",
    headers: [
      { type: "Exact", name: "accept", value: "application/json" },
    ],
  },
  {
    path: { type: "PathPrefix", value: "/health" },
  },
];

const matcher = compileRouteMatches(routes, "allowed", "denied");
</code></pre>
<h3 id="rust"><a class="header" href="#rust">Rust</a></h3>
<pre><code class="language-rust ignore">use rumi::prelude::*;
use rumi_http::simple::*;

let request = HttpRequest::builder()
    .method("GET")
    .path("/api/users")
    .header("accept", "application/json")
    .build();</code></pre>
<p>Rust has two layers. The <strong>simple</strong> module (<code>HttpRequest</code>, <code>SimplePathInput</code>, etc.) works everywhere, including WASM. The <strong>ext-proc</strong> module (behind the <code>ext-proc</code> feature) provides <code>HttpMessage</code> for Envoy external processing integration with full k8s Gateway API types.</p>
<h2 id="config-types"><a class="header" href="#config-types">Config Types</a></h2>
<h3 id="httppathmatch"><a class="header" href="#httppathmatch">HttpPathMatch</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Values</th></tr>
</thead>
<tbody>
<tr><td><code>type</code></td><td>string</td><td><code>"Exact"</code>, <code>"PathPrefix"</code>, <code>"RegularExpression"</code></td></tr>
<tr><td><code>value</code></td><td>string</td><td>The pattern to match</td></tr>
</tbody>
</table>
</div>
<p><code>PathPrefix</code> matches if the path starts with the value. <code>Exact</code> requires an exact match. <code>RegularExpression</code> uses RE2 syntax (linear-time guarantee).</p>
<h3 id="httpheadermatch"><a class="header" href="#httpheadermatch">HttpHeaderMatch</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Values</th></tr>
</thead>
<tbody>
<tr><td><code>type</code></td><td>string</td><td><code>"Exact"</code>, <code>"RegularExpression"</code></td></tr>
<tr><td><code>name</code></td><td>string</td><td>Header name (case-insensitive)</td></tr>
<tr><td><code>value</code></td><td>string</td><td>The pattern to match</td></tr>
</tbody>
</table>
</div>
<h3 id="httpqueryparammatch"><a class="header" href="#httpqueryparammatch">HttpQueryParamMatch</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Values</th></tr>
</thead>
<tbody>
<tr><td><code>type</code></td><td>string</td><td><code>"Exact"</code>, <code>"RegularExpression"</code></td></tr>
<tr><td><code>name</code></td><td>string</td><td>Query parameter name</td></tr>
<tr><td><code>value</code></td><td>string</td><td>The pattern to match</td></tr>
</tbody>
</table>
</div>
<h3 id="httproutematch"><a class="header" href="#httproutematch">HttpRouteMatch</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Required</th></tr>
</thead>
<tbody>
<tr><td><code>path</code></td><td><code>HttpPathMatch</code></td><td>No</td></tr>
<tr><td><code>method</code></td><td>string</td><td>No</td></tr>
<tr><td><code>headers</code></td><td>list of <code>HttpHeaderMatch</code></td><td>No</td></tr>
<tr><td><code>query_params</code></td><td>list of <code>HttpQueryParamMatch</code></td><td>No</td></tr>
</tbody>
</table>
</div>
<p>All fields are optional. An empty <code>HttpRouteMatch</code> matches every request (catch-all).</p>
<h2 id="registry-type-urls"><a class="header" href="#registry-type-urls">Registry Type URLs</a></h2>
<p>When using the config path (JSON/YAML → Registry → Matcher), these type URLs are registered:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type URL</th><th>Input</th></tr>
</thead>
<tbody>
<tr><td><code>xuma.http.v1.PathInput</code></td><td>Path extraction</td></tr>
<tr><td><code>xuma.http.v1.MethodInput</code></td><td>Method extraction</td></tr>
<tr><td><code>xuma.http.v1.HeaderInput</code></td><td>Header extraction (config: <code>{"name": "..."}</code>)</td></tr>
<tr><td><code>xuma.http.v1.QueryParamInput</code></td><td>Query param extraction (config: <code>{"name": "..."}</code>)</td></tr>
</tbody>
</table>
</div>
<h2 id="manual-construction"><a class="header" href="#manual-construction">Manual Construction</a></h2>
<p>You can build HTTP matchers manually instead of using the compiler:</p>
<pre><code class="language-python">from xuma import Matcher, FieldMatcher, SinglePredicate, And, Action
from xuma import PrefixMatcher, ExactMatcher
from xuma.http import HttpRequest, PathInput, MethodInput, HeaderInput

# GET /api/* with JSON accept header
predicate = And((
    SinglePredicate(PathInput(), PrefixMatcher("/api")),
    SinglePredicate(MethodInput(), ExactMatcher("GET")),
    SinglePredicate(HeaderInput("accept"), ExactMatcher("application/json")),
))

matcher = Matcher(
    matcher_list=(
        FieldMatcher(predicate=predicate, on_match=Action("api_json")),
    ),
    on_no_match=Action("not_found"),
)

request = HttpRequest(method="GET", raw_path="/api/users",
                      headers={"accept": "application/json"})
assert matcher.evaluate(request) == "api_json"
</code></pre>
<p>The compiler is syntactic sugar. Manual construction gives full control over predicate trees and nesting.</p>
<h2 id="rust-simple-vs-ext-proc"><a class="header" href="#rust-simple-vs-ext-proc">Rust: Simple vs Ext-Proc</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Simple</th><th>Ext-Proc</th></tr>
</thead>
<tbody>
<tr><td>Context type</td><td><code>HttpRequest</code></td><td><code>HttpMessage</code></td></tr>
<tr><td>Dependencies</td><td>None</td><td>k8s-gateway-api, k8s-openapi, envoy types</td></tr>
<tr><td>WASM compatible</td><td>Yes</td><td>No</td></tr>
<tr><td>Use case</td><td>Testing, bindings, simple routing</td><td>Production Envoy integration</td></tr>
</tbody>
</table>
</div>
<p>The simple module is always available. The ext-proc module requires <code>features = ["ext-proc"]</code> (enabled by default in <code>rumi-http</code>).</p>
<h2 id="next-5"><a class="header" href="#next-5">Next</a></h2>
<ul>
<li><a href="#build-an-http-router">Build an HTTP Router</a> — step-by-step tutorial</li>
<li><a href="#the-matching-pipeline">The Matching Pipeline</a> — how HTTP inputs flow through the engine</li>
<li><a href="#config-format">Config Format</a> — JSON/YAML config for HTTP matchers</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="claude-code-hooks"><a class="header" href="#claude-code-hooks">Claude Code Hooks</a></h1>
<p>The Claude Code hooks domain provides context types, inputs, and a compiler for matching Claude Code hook events. Available in Rust (<code>rumi</code> with <code>features = ["claude"]</code>).</p>
<h2 id="what-are-claude-code-hooks"><a class="header" href="#what-are-claude-code-hooks">What Are Claude Code Hooks?</a></h2>
<p>Claude Code fires hook events at key moments: before a tool runs, after it completes, when a session starts, when the agent stops. x.uma’s Claude domain lets you build matchers that gate these events — block dangerous commands, audit tool usage, enforce policies.</p>
<h2 id="hook-events"><a class="header" href="#hook-events">Hook Events</a></h2>
<p>Nine event types, matching the Claude Code hooks API:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Event</th><th>When it fires</th></tr>
</thead>
<tbody>
<tr><td><code>PreToolUse</code></td><td>Before a tool executes</td></tr>
<tr><td><code>PostToolUse</code></td><td>After a tool completes</td></tr>
<tr><td><code>Stop</code></td><td>Main agent considers stopping</td></tr>
<tr><td><code>SubagentStop</code></td><td>Subagent considers stopping</td></tr>
<tr><td><code>UserPromptSubmit</code></td><td>User submits a prompt</td></tr>
<tr><td><code>SessionStart</code></td><td>Session begins</td></tr>
<tr><td><code>SessionEnd</code></td><td>Session ends</td></tr>
<tr><td><code>PreCompact</code></td><td>Before context compaction</td></tr>
<tr><td><code>Notification</code></td><td>Notification sent to user</td></tr>
</tbody>
</table>
</div>
<h2 id="inputs-1"><a class="header" href="#inputs-1">Inputs</a></h2>
<p>Six <code>DataInput</code> types extract fields from <code>HookContext</code>:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Input</th><th>Extracts</th><th>Returns</th></tr>
</thead>
<tbody>
<tr><td><code>EventInput</code></td><td>Event type as string</td><td><code>"PreToolUse"</code>, <code>"PostToolUse"</code>, etc.</td></tr>
<tr><td><code>ToolNameInput</code></td><td>Tool name</td><td><code>"Bash"</code>, <code>"Write"</code>, <code>"Read"</code>, etc.</td></tr>
<tr><td><code>ArgumentInput(name)</code></td><td>Tool argument value</td><td><code>string</code> or <code>null</code></td></tr>
<tr><td><code>SessionIdInput</code></td><td>Session identifier</td><td><code>string</code></td></tr>
<tr><td><code>CwdInput</code></td><td>Current working directory</td><td><code>string</code></td></tr>
<tr><td><code>GitBranchInput</code></td><td>Git branch name</td><td><code>string</code> or <code>null</code></td></tr>
</tbody>
</table>
</div>
<h2 id="the-compiler"><a class="header" href="#the-compiler">The Compiler</a></h2>
<p>The <code>HookMatch</code> compiler transforms declarative rules into matchers:</p>
<pre><code class="language-rust ignore">use rumi::claude::prelude::*;

// Block dangerous Bash commands
let rule = HookMatch {
    event: Some(HookEvent::PreToolUse),
    tool_name: Some(StringMatch::Exact("Bash".into())),
    arguments: Some(vec![ArgumentMatch {
        name: "command".into(),
        value: StringMatch::Contains("rm -rf".into()),
    }]),
    ..Default::default()
};

let matcher = rule.compile("block")?;

let ctx = HookContext::pre_tool_use("Bash")
    .with_arg("command", "rm -rf /important");
assert_eq!(matcher.evaluate(&amp;ctx), Some("block"));</code></pre>
<h3 id="hookmatch-fields"><a class="header" href="#hookmatch-fields">HookMatch Fields</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>event</code></td><td><code>Option&lt;HookEvent&gt;</code></td><td>Match specific event type</td></tr>
<tr><td><code>tool_name</code></td><td><code>Option&lt;StringMatch&gt;</code></td><td>Match tool name</td></tr>
<tr><td><code>arguments</code></td><td><code>Option&lt;Vec&lt;ArgumentMatch&gt;&gt;</code></td><td>Match tool arguments</td></tr>
<tr><td><code>session_id</code></td><td><code>Option&lt;StringMatch&gt;</code></td><td>Match session ID</td></tr>
<tr><td><code>cwd</code></td><td><code>Option&lt;StringMatch&gt;</code></td><td>Match working directory</td></tr>
<tr><td><code>git_branch</code></td><td><code>Option&lt;StringMatch&gt;</code></td><td>Match git branch</td></tr>
</tbody>
</table>
</div>
<p>All fields are optional. Set fields are ANDed together. Unset fields match anything.</p>
<h3 id="stringmatch-variants"><a class="header" href="#stringmatch-variants">StringMatch Variants</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Variant</th><th>Matches</th></tr>
</thead>
<tbody>
<tr><td><code>StringMatch::Exact(s)</code></td><td>Exact equality</td></tr>
<tr><td><code>StringMatch::Prefix(s)</code></td><td>Starts with</td></tr>
<tr><td><code>StringMatch::Suffix(s)</code></td><td>Ends with</td></tr>
<tr><td><code>StringMatch::Contains(s)</code></td><td>Contains substring</td></tr>
<tr><td><code>StringMatch::Regex(s)</code></td><td>RE2 regex pattern</td></tr>
</tbody>
</table>
</div>
<h3 id="multiple-rules"><a class="header" href="#multiple-rules">Multiple Rules</a></h3>
<p><code>compile_hook_matches</code> compiles multiple rules with OR semantics:</p>
<pre><code class="language-rust ignore">use rumi::claude::prelude::*;

let rules = vec![
    HookMatch {
        event: Some(HookEvent::PreToolUse),
        tool_name: Some(StringMatch::Exact("Bash".into())),
        arguments: Some(vec![ArgumentMatch {
            name: "command".into(),
            value: StringMatch::Contains("rm -rf".into()),
        }]),
        ..Default::default()
    },
    HookMatch {
        event: Some(HookEvent::PreToolUse),
        tool_name: Some(StringMatch::Exact("Write".into())),
        cwd: Some(StringMatch::Prefix("/etc".into())),
        ..Default::default()
    },
];

let matcher = compile_hook_matches(&amp;rules, "block", Some("allow"));</code></pre>
<p>Any matching rule triggers the action. First match wins.</p>
<h2 id="hookcontext-builder"><a class="header" href="#hookcontext-builder">HookContext Builder</a></h2>
<p><code>HookContext</code> uses a builder pattern:</p>
<pre><code class="language-rust ignore">let ctx = HookContext::pre_tool_use("Bash")
    .with_arg("command", "ls -la")
    .with_session_id("session-123")
    .with_cwd("/home/user/project")
    .with_git_branch("main");</code></pre>
<p>Convenience constructors: <code>pre_tool_use(tool)</code>, <code>post_tool_use(tool)</code>, <code>stop()</code>, <code>subagent_stop()</code>, <code>user_prompt_submit()</code>, <code>session_start()</code>, <code>session_end()</code>, <code>pre_compact()</code>, <code>notification()</code>.</p>
<h2 id="tracing"><a class="header" href="#tracing">Tracing</a></h2>
<p>Debug match decisions with <code>HookMatchTrace</code>:</p>
<pre><code class="language-rust ignore">let trace = rule.trace(&amp;ctx);
for step in &amp;trace.steps {
    println!("{}: expected={}, actual={}, matched={}",
        step.field, step.expected, step.actual, step.matched);
}</code></pre>
<p>Each step shows the field name, expected value, actual value, and whether it matched. Trace output tells you exactly why a rule matched or didn’t.</p>
<h2 id="registry-type-urls-1"><a class="header" href="#registry-type-urls-1">Registry Type URLs</a></h2>
<p>When using the config path:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type URL</th><th>Input</th></tr>
</thead>
<tbody>
<tr><td><code>xuma.claude.v1.EventInput</code></td><td>Event type extraction</td></tr>
<tr><td><code>xuma.claude.v1.ToolNameInput</code></td><td>Tool name extraction</td></tr>
<tr><td><code>xuma.claude.v1.ArgumentInput</code></td><td>Argument extraction (config: <code>{"name": "..."}</code>)</td></tr>
<tr><td><code>xuma.claude.v1.SessionIdInput</code></td><td>Session ID extraction</td></tr>
<tr><td><code>xuma.claude.v1.CwdInput</code></td><td>Working directory extraction</td></tr>
<tr><td><code>xuma.claude.v1.GitBranchInput</code></td><td>Git branch extraction</td></tr>
</tbody>
</table>
</div>
<h2 id="manual-construction-1"><a class="header" href="#manual-construction-1">Manual Construction</a></h2>
<p>You can build Claude matchers without the compiler:</p>
<pre><code class="language-rust ignore">use rumi::prelude::*;
use rumi::claude::*;

let matcher: Matcher&lt;HookContext, &amp;str&gt; = Matcher::new(
    vec![FieldMatcher::new(
        Predicate::And(vec![
            Predicate::Single(SinglePredicate::new(
                Box::new(ToolNameInput),
                Box::new(ExactMatcher::new("Bash")),
            )),
            Predicate::Single(SinglePredicate::new(
                Box::new(ArgumentInput::new("command")),
                Box::new(ContainsMatcher::new("rm -rf")),
            )),
        ]),
        OnMatch::Action("block"),
    )],
    Some(OnMatch::Action("allow")),
);</code></pre>
<p>The compiler handles the boilerplate. Manual construction gives full control.</p>
<h2 id="next-6"><a class="header" href="#next-6">Next</a></h2>
<ul>
<li><a href="#architecture">Architecture</a> — how domains plug into the core</li>
<li><a href="#adding-a-domain-adapter">Adding a Domain Adapter</a> — build your own domain</li>
<li><a href="#config-format">Config Format</a> — JSON/YAML config for Claude matchers</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="adding-a-domain-adapter"><a class="header" href="#adding-a-domain-adapter">Adding a Domain Adapter</a></h1>
<p>x.uma ships with HTTP and Claude Code domains. You can add your own. A domain adapter is a set of <code>DataInput</code> implementations that extract fields from your context type, plus an optional compiler for ergonomic construction.</p>
<h2 id="what-you-need"><a class="header" href="#what-you-need">What You Need</a></h2>
<ol>
<li><strong>A context type</strong> — the data structure your matcher evaluates against</li>
<li><strong>DataInput implementations</strong> — one per matchable field</li>
<li><strong>(Optional) A compiler</strong> — transforms domain-specific config into matcher trees</li>
<li><strong>(Optional) Registry registration</strong> — enables config-driven construction</li>
</ol>
<h2 id="step-1-define-your-context"><a class="header" href="#step-1-define-your-context">Step 1: Define Your Context</a></h2>
<pre><code class="language-python">from dataclasses import dataclass

@dataclass(frozen=True)
class CloudEvent:
    type: str
    source: str
    subject: str | None = None
    data: dict | None = None
</code></pre>
<p>In Rust:</p>
<pre><code class="language-rust ignore">#[derive(Debug, Clone)]
pub struct CloudEvent {
    pub event_type: String,
    pub source: String,
    pub subject: Option&lt;String&gt;,
    pub data: Option&lt;serde_json::Value&gt;,
}</code></pre>
<h2 id="step-2-implement-datainput"><a class="header" href="#step-2-implement-datainput">Step 2: Implement DataInput</a></h2>
<p>One <code>DataInput</code> per field you want to match against:</p>
<pre><code class="language-python">from dataclasses import dataclass
from xuma import MatchingData

@dataclass(frozen=True)
class EventTypeInput:
    def get(self, ctx: CloudEvent) -&gt; MatchingData:
        return ctx.type

@dataclass(frozen=True)
class SourceInput:
    def get(self, ctx: CloudEvent) -&gt; MatchingData:
        return ctx.source

@dataclass(frozen=True)
class SubjectInput:
    def get(self, ctx: CloudEvent) -&gt; MatchingData:
        return ctx.subject  # None when absent → predicate returns false
</code></pre>
<p>In Rust:</p>
<pre><code class="language-rust ignore">use rumi::prelude::*;

#[derive(Debug, Clone)]
pub struct EventTypeInput;

impl DataInput&lt;CloudEvent&gt; for EventTypeInput {
    fn get(&amp;self, ctx: &amp;CloudEvent) -&gt; MatchingData {
        MatchingData::String(ctx.event_type.clone())
    }
}

#[derive(Debug, Clone)]
pub struct SubjectInput;

impl DataInput&lt;CloudEvent&gt; for SubjectInput {
    fn get(&amp;self, ctx: &amp;CloudEvent) -&gt; MatchingData {
        ctx.subject.as_ref()
            .map_or(MatchingData::None, |s| MatchingData::String(s.clone()))
    }
}</code></pre>
<p>Key rules:</p>
<ul>
<li>Return <code>MatchingData::None</code> (or Python <code>None</code>) when data is absent</li>
<li>The None-to-false rule ensures missing fields never match</li>
<li>Inputs must be <code>Send + Sync</code> in Rust (required for thread safety)</li>
</ul>
<h2 id="step-3-use-your-inputs"><a class="header" href="#step-3-use-your-inputs">Step 3: Use Your Inputs</a></h2>
<p>Your inputs work with all existing matchers immediately:</p>
<pre><code class="language-python">from xuma import Matcher, FieldMatcher, SinglePredicate, And, Action
from xuma import PrefixMatcher, ExactMatcher

matcher = Matcher(
    matcher_list=(
        FieldMatcher(
            predicate=And((
                SinglePredicate(EventTypeInput(), PrefixMatcher("com.example.")),
                SinglePredicate(SourceInput(), ExactMatcher("api")),
            )),
            on_match=Action("handle_api_event"),
        ),
    ),
    on_no_match=Action("ignore"),
)

event = CloudEvent(type="com.example.user.created", source="api")
assert matcher.evaluate(event) == "handle_api_event"
</code></pre>
<p><code>PrefixMatcher</code> and <code>ExactMatcher</code> don’t know about <code>CloudEvent</code>. They match erased <code>MatchingData</code> strings. That’s the whole point of type erasure.</p>
<h2 id="step-4-add-a-compiler-optional"><a class="header" href="#step-4-add-a-compiler-optional">Step 4: Add a Compiler (Optional)</a></h2>
<p>A compiler transforms domain-specific config into matcher trees:</p>
<pre><code class="language-python">from dataclasses import dataclass, field
from xuma import Matcher, FieldMatcher, SinglePredicate, And, Action
from xuma import PrefixMatcher, ExactMatcher, RegexMatcher, matcher_from_predicate, and_predicate

@dataclass(frozen=True)
class CloudEventMatch:
    event_type: str | None = None       # prefix match
    source: str | None = None           # exact match
    subject_pattern: str | None = None  # regex match

    def to_predicate(self):
        predicates = []
        if self.event_type is not None:
            predicates.append(SinglePredicate(EventTypeInput(), PrefixMatcher(self.event_type)))
        if self.source is not None:
            predicates.append(SinglePredicate(SourceInput(), ExactMatcher(self.source)))
        if self.subject_pattern is not None:
            predicates.append(SinglePredicate(SubjectInput(), RegexMatcher(self.subject_pattern)))
        # Empty predicates → catch-all (And of empty = true)
        return and_predicate(predicates, SinglePredicate(EventTypeInput(), PrefixMatcher("")))

    def compile(self, action):
        return matcher_from_predicate(self.to_predicate(), action)
</code></pre>
<p>Usage:</p>
<pre><code class="language-python">match = CloudEventMatch(event_type="com.example.", source="api")
matcher = match.compile("handle")

event = CloudEvent(type="com.example.user.created", source="api")
assert matcher.evaluate(event) == "handle"
</code></pre>
<h2 id="step-5-register-for-config-path-optional"><a class="header" href="#step-5-register-for-config-path-optional">Step 5: Register for Config Path (Optional)</a></h2>
<p>To enable JSON/YAML config loading, implement <code>IntoDataInput</code> and register:</p>
<pre><code class="language-rust ignore">use rumi::{IntoDataInput, RegistryBuilder, UnitConfig, register_core_matchers};

impl IntoDataInput&lt;CloudEvent&gt; for EventTypeInput {
    type Config = UnitConfig;  // No configuration needed

    fn from_config(_: UnitConfig) -&gt; Result&lt;Box&lt;dyn DataInput&lt;CloudEvent&gt;&gt;, MatcherError&gt; {
        Ok(Box::new(EventTypeInput))
    }
}

pub fn register(builder: RegistryBuilder&lt;CloudEvent&gt;) -&gt; RegistryBuilder&lt;CloudEvent&gt; {
    register_core_matchers(builder)
        .input::&lt;EventTypeInput&gt;("myapp.events.v1.EventTypeInput")
        .input::&lt;SourceInput&gt;("myapp.events.v1.SourceInput")
        .input::&lt;SubjectInput&gt;("myapp.events.v1.SubjectInput")
}</code></pre>
<p>Now configs can reference your inputs by type URL:</p>
<pre><code class="language-json">{
  "matchers": [{
    "predicate": {
      "type": "single",
      "input": { "type_url": "myapp.events.v1.EventTypeInput" },
      "value_match": { "Prefix": "com.example." }
    },
    "on_match": { "type": "action", "action": "handle" }
  }]
}
</code></pre>
<h2 id="checklist"><a class="header" href="#checklist">Checklist</a></h2>
<p>When adding a domain adapter:</p>
<ul>
<li><input disabled="" type="checkbox"> Context type is immutable (frozen dataclass, <code>#[derive(Debug, Clone)]</code>)</li>
<li><input disabled="" type="checkbox"> Each <code>DataInput</code> returns <code>None</code> for missing/absent data</li>
<li><input disabled="" type="checkbox"> Inputs are <code>Send + Sync</code> in Rust</li>
<li><input disabled="" type="checkbox"> Compiler ANDs conditions within a match, ORs across matches</li>
<li><input disabled="" type="checkbox"> Type URLs follow namespace convention (<code>namespace.domain.version.TypeName</code>)</li>
<li><input disabled="" type="checkbox"> Registry function registers core matchers AND domain inputs</li>
</ul>
<h2 id="next-7"><a class="header" href="#next-7">Next</a></h2>
<ul>
<li><a href="#type-erasure-and-ports">Type Erasure and Ports</a> — why this architecture works</li>
<li><a href="#the-matching-pipeline">The Matching Pipeline</a> — how your inputs fit in the flow</li>
<li><a href="#http-matching">HTTP Matching</a> — reference implementation to study</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>x.uma makes one bet: the boundary between “what data do I have?” and “how do I match it?” is the most valuable seam in a matcher engine.</p>
<h2 id="the-bet"><a class="header" href="#the-bet">The Bet</a></h2>
<p>Every matcher engine faces a choice. Couple the matching logic to the domain, and you get performance and simplicity — but you rebuild the engine for every new domain. Decouple them, and you get reuse — but you pay in abstraction tax and runtime indirection.</p>
<p>x.uma’s answer: erase the type at the <strong>data level</strong>, not the matcher level. One <code>ExactMatcher</code> works for HTTP paths, Claude Code tool names, gRPC service identifiers, and types that don’t exist yet.</p>
<pre><code class="language-text">Context (your data)
    ↓
DataInput.get()          ← knows your type, returns erased data
    ↓
MatchingData             ← string | int | bool | bytes | null
    ↓
InputMatcher.matches()   ← doesn't know your type, doesn't need to
    ↓
bool
</code></pre>
<p>The split happens at <code>MatchingData</code>. Above it, domain-specific code that knows about <code>HttpRequest</code> or <code>HookContext</code>. Below it, domain-agnostic matchers that work with primitives. This is the seam.</p>
<h2 id="why-this-works"><a class="header" href="#why-this-works">Why This Works</a></h2>
<p>The insight comes from Envoy, where it runs at Google scale. Envoy’s xDS Unified Matcher API uses the same split — domain-specific inputs feed type-erased data into generic matchers. x.uma implements these semantics in Rust, Python, and TypeScript.</p>
<p>What the seam buys:</p>
<p><strong>Write a matcher once, use it everywhere.</strong> <code>PrefixMatcher("/api")</code> matches HTTP paths, event source URIs, file paths — anything that produces a string through <code>MatchingData</code>. Five string matchers (<code>Exact</code>, <code>Prefix</code>, <code>Suffix</code>, <code>Contains</code>, <code>Regex</code>) cover most matching needs across all domains.</p>
<p><strong>Add a domain without touching core.</strong> HTTP matching, Claude Code hooks, and the test domain all plug in by implementing <code>DataInput</code> — a single method that extracts a value from the context. The core engine never changes.</p>
<p><strong>Share config across languages.</strong> The same JSON/YAML config produces the same matcher tree in Rust, Python, and TypeScript. <code>MatchingData</code> is the same name, same semantics, in all three.</p>
<h2 id="the-shape"><a class="header" href="#the-shape">The Shape</a></h2>
<pre><code class="language-text">┌─────────────────────────────────────────┐
│           Domain Adapters               │
│   xuma.http    xuma.claude    xuma.test │
│   (DataInput implementations)           │
└──────────────────┬──────────────────────┘
                   │  get() → MatchingData
                   ↓
┌──────────────────▼──────────────────────┐
│           Core Engine                   │
│   Matcher · Predicate · InputMatcher    │
│   (domain-agnostic, immutable)          │
└─────────────────────────────────────────┘
</code></pre>
<p>Two ports define the boundary:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Port</th><th>Direction</th><th>Generic?</th><th>You implement</th></tr>
</thead>
<tbody>
<tr><td><strong>DataInput</strong></td><td>Domain → Core</td><td>Yes (knows <code>Ctx</code>)</td><td>One per field you want to match</td></tr>
<tr><td><strong>InputMatcher</strong></td><td>Core → bool</td><td>No (knows <code>MatchingData</code>)</td><td>Rarely — five ship with x.uma</td></tr>
</tbody>
</table>
</div>
<p>Domain adapters implement <code>DataInput</code>. The core ships <code>InputMatcher</code> implementations. <code>SinglePredicate</code> wires one to the other.</p>
<h2 id="aces"><a class="header" href="#aces">ACES</a></h2>
<p>The architecture follows four properties:</p>
<p><strong>Adaptable.</strong> New domains plug in without modifying core. HTTP matching didn’t require changes to the predicate engine. Claude Code hooks didn’t require changes to HTTP matching. Each domain is independent.</p>
<p><strong>Composable.</strong> Predicates compose with AND, OR, NOT. Matchers nest up to 32 levels deep. A matcher’s action can be another matcher, creating trees of arbitrary complexity from simple building blocks.</p>
<p><strong>Extensible.</strong> <code>TypedExtensionConfig</code> from the xDS protobuf spec is the extension seam. Every input and action is identified by a type URL (<code>xuma.http.v1.PathInput</code>, <code>xuma.claude.v1.ToolNameInput</code>). New types register without modifying existing ones.</p>
<p><strong>Sustainable.</strong> Core is stable. Growth happens at the edges. Adding a domain means adding <code>DataInput</code> implementations and a compiler — not touching <code>Matcher</code>, <code>Predicate</code>, or <code>InputMatcher</code>. The architecture sustains extension without rewrites.</p>
<h2 id="what-core-owns"><a class="header" href="#what-core-owns">What Core Owns</a></h2>
<p>The core engine (<code>rumi</code> in Rust, <code>xuma</code> in Python/TypeScript) provides:</p>
<ul>
<li><strong>Matcher</strong> — first-match-wins evaluation over a list of field matchers</li>
<li><strong>Predicate</strong> — Boolean tree (Single, And, Or, Not) with short-circuit evaluation</li>
<li><strong>SinglePredicate</strong> — pairs a <code>DataInput</code> with an <code>InputMatcher</code></li>
<li><strong>MatchingData</strong> — the type-erased bridge (<code>string | int | bool | bytes | null</code>)</li>
<li><strong>InputMatcher</strong> — five string matchers plus <code>BoolMatcher</code></li>
<li><strong>OnMatch</strong> — action XOR nested matcher (illegal states unrepresentable)</li>
<li><strong>Depth/width limits</strong> — MAX_DEPTH=32, MAX_FIELD_MATCHERS=256</li>
<li><strong>Registry</strong> — immutable type registry for config-driven construction</li>
<li><strong>Trace</strong> — step-by-step evaluation debugging</li>
</ul>
<p>Core does not own domain knowledge. It does not know what an HTTP request is, what a Claude Code hook event is, or what your custom context type contains. It matches erased values.</p>
<h2 id="what-domains-own"><a class="header" href="#what-domains-own">What Domains Own</a></h2>
<p>Each domain provides:</p>
<ul>
<li><strong>Context type</strong> — <code>HttpRequest</code>, <code>HookContext</code>, your type</li>
<li><strong>DataInput implementations</strong> — extractors for each matchable field</li>
<li><strong>Compiler</strong> — transforms domain-specific config into matcher trees</li>
<li><strong>Registry function</strong> — registers domain inputs with the type registry</li>
</ul>
<p>The compiler is the user-facing API. Instead of manually constructing predicate trees, you write:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// HTTP: Gateway API config → matcher
let matcher = compile_route_matches(&amp;routes, "allowed", "denied");

// Claude: hook rules → matcher
let matcher = rule.compile("block")?;
<span class="boring">}</span></code></pre>
<p>Compilers are syntactic sugar over the core engine. They produce the same <code>Matcher&lt;Ctx, A&gt;</code> you’d build by hand.</p>
<h2 id="matcher-engine-not-policy-engine"><a class="header" href="#matcher-engine-not-policy-engine">Matcher Engine, Not Policy Engine</a></h2>
<p>x.uma is a matcher engine. It finds the first matching rule and returns an action. It does not interpret that action.</p>
<p>The generic <code>A</code> in <code>Matcher&lt;Ctx, A&gt;</code> is the boundary. <code>A</code> can be a string, an enum, a struct — anything. Core never inspects it. Whether <code>"allow"</code> means permit and <code>"deny"</code> means block is your concern, not the engine’s.</p>
<p>Policy (allow/deny, rate limits, routing decisions) lives <strong>above</strong> the matcher. This is the Istio pattern — the data plane matches, the control plane decides. x.uma is the data plane.</p>
<p>This means x.uma doesn’t compete with OPA or Cedar. It complements them. Use x.uma for fast, structured matching. Use a policy engine for policy logic that operates on the match result.</p>
<h2 id="two-construction-paths"><a class="header" href="#two-construction-paths">Two Construction Paths</a></h2>
<p>Matchers can be built two ways:</p>
<p><strong>Compiler path</strong> — domain-specific DSL produces matchers directly. Ergonomic, type-safe, no serialization overhead.</p>
<pre><code class="language-python">from xuma.http import HttpRouteMatch, compile_route_matches

routes = [HttpRouteMatch(path=HttpPathMatch(type="PathPrefix", value="/api"), method="GET")]
matcher = compile_route_matches(routes, "api", "not_found")
</code></pre>
<p><strong>Config path</strong> — JSON/YAML config loaded through the registry. Portable across languages, storable, versionable.</p>
<pre><code class="language-json">{
  "matcher_list": [{
    "predicate": {
      "single": {
        "input": { "type_url": "xuma.test.v1.StringInput", "config": { "key": "method" } },
        "matcher": { "type_url": "xuma.core.v1.StringMatcher", "config": { "exact": "GET" } }
      }
    },
    "on_match": { "action": "route-get" }
  }],
  "on_no_match": { "action": "fallback" }
}
</code></pre>
<p>Both paths produce the same <code>Matcher</code>. The compiler path is for programmatic construction. The config path is for declarative, cross-language use.</p>
<h2 id="five-implementations-one-spec"><a class="header" href="#five-implementations-one-spec">Five Implementations, One Spec</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Implementation</th><th>Language</th><th>Type</th></tr>
</thead>
<tbody>
<tr><td><strong>rumi</strong></td><td>Rust</td><td>Reference implementation</td></tr>
<tr><td><strong>xuma</strong> (Python)</td><td>Python</td><td>Pure Python</td></tr>
<tr><td><strong>xuma</strong> (TypeScript)</td><td>TypeScript</td><td>Pure TypeScript</td></tr>
<tr><td><strong>puma-crusty</strong></td><td>Python</td><td>Rust core via PyO3</td></tr>
<tr><td><strong>bumi-crusty</strong></td><td>TypeScript</td><td>Rust core via WASM</td></tr>
</tbody>
</table>
</div>
<p>All five pass the same conformance test suite. Same config format, same evaluation semantics, same results. Choose based on your runtime and performance needs.</p>
<h2 id="next-8"><a class="header" href="#next-8">Next</a></h2>
<ul>
<li><a href="#the-matching-pipeline">The Matching Pipeline</a> — how data flows through evaluation</li>
<li><a href="#type-erasure-and-ports">Type Erasure and Ports</a> — the technical details of the seam</li>
<li><a href="#when-to-use-xuma">When to Use x.uma</a> — where x.uma fits and where it doesn’t</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="when-to-use-xuma"><a class="header" href="#when-to-use-xuma">When to Use x.uma</a></h1>
<p>x.uma is a matcher engine. It evaluates structured data against rules and returns the first matching action. This page helps you decide whether it fits your problem.</p>
<h2 id="xuma-is-for"><a class="header" href="#xuma-is-for">x.uma Is For</a></h2>
<p><strong>Structured matching with known fields.</strong> You have data with named fields (HTTP method, path, headers; tool names, arguments; event types) and need to route, filter, or classify based on combinations of those fields.</p>
<p><strong>Cross-language consistency.</strong> You need the same matching rules to produce the same results in Rust, Python, and TypeScript. One config format, five implementations, identical semantics.</p>
<p><strong>Config-driven matching.</strong> Your matching rules come from configuration files (JSON, YAML, protobuf) rather than hardcoded logic. Rules change without redeployment.</p>
<p><strong>First-match-wins routing.</strong> Your problem is “which rule matches first?” — not “what are all the rules that match?” or “what is the aggregate policy across all rules?”</p>
<p><strong>Safety-critical matching.</strong> You need guarantees: linear-time regex (no ReDoS), depth limits (no stack overflow), immutable matchers (no race conditions), fail-closed on missing data.</p>
<h2 id="xuma-is-not-for"><a class="header" href="#xuma-is-not-for">x.uma Is Not For</a></h2>
<p><strong>General-purpose policy evaluation.</strong> If you need attribute-based access control with complex policy logic (role hierarchies, contextual permissions, deny-overrides), use a policy engine like OPA or Cedar. x.uma finds matches — it doesn’t evaluate policies.</p>
<p><strong>Free-text search.</strong> x.uma matches structured fields against patterns. If you need full-text search, fuzzy matching, or semantic similarity, use a search engine.</p>
<p><strong>Stateful decisions.</strong> x.uma matchers are pure functions — same input always produces same output. If your decision depends on previous requests, rate counters, or session state, you need stateful middleware.</p>
<p><strong>Dynamic rule updates at runtime.</strong> x.uma registries and matchers are immutable after construction. If you need to add or remove rules during execution without reconstruction, x.uma’s model doesn’t fit.</p>
<h2 id="comparison"><a class="header" href="#comparison">Comparison</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Need</th><th>x.uma</th><th>Alternative</th></tr>
</thead>
<tbody>
<tr><td>HTTP route matching</td><td>Yes — built-in domain</td><td>nginx, Envoy, framework routers</td></tr>
<tr><td>Tool/hook gating</td><td>Yes — Claude Code domain</td><td>Custom if/else chains</td></tr>
<tr><td>Config-driven matching</td><td>Yes — JSON/YAML/proto config</td><td>Hand-rolled config parsers</td></tr>
<tr><td>ABAC / RBAC policies</td><td><strong>No</strong> — use a policy engine</td><td>OPA (Rego), Cedar, Zanzibar</td></tr>
<tr><td>Complex authorization</td><td><strong>No</strong> — matcher, not policy engine</td><td>OPA, Casbin, custom logic</td></tr>
<tr><td>Full-text search</td><td><strong>No</strong> — structured fields only</td><td>Elasticsearch, MeiliSearch</td></tr>
<tr><td>Rate limiting</td><td><strong>No</strong> — stateless matching</td><td>Redis, middleware</td></tr>
</tbody>
</table>
</div>
<h2 id="xuma--policy-engines"><a class="header" href="#xuma--policy-engines">x.uma + Policy Engines</a></h2>
<p>x.uma and policy engines solve different problems. They compose well:</p>
<pre><code class="language-text">Request → x.uma (structured matching) → action
                                            ↓
                              Policy engine (authorization) → permit/deny
</code></pre>
<p>x.uma handles the fast path: “which rule matches this request?” The policy engine handles the complex path: “given this match, is the action authorized?” This is the Istio pattern — data plane matches, control plane decides.</p>
<h2 id="when-performance-matters"><a class="header" href="#when-performance-matters">When Performance Matters</a></h2>
<p>x.uma evaluation is fast — 9-33ns for exact matches depending on implementation. But the performance advantage over hand-written <code>if/else</code> chains only matters when:</p>
<ol>
<li><strong>Rules come from config</strong> — you can’t hardcode what you don’t know at compile time</li>
<li><strong>Rules change</strong> — reconstruction is cheaper than redeployment</li>
<li><strong>Cross-language parity</strong> — you need the same rules in multiple runtimes</li>
<li><strong>Safety guarantees</strong> — ReDoS protection and depth limits matter</li>
</ol>
<p>If you have five static rules that never change and only run in one language, <code>if/else</code> is simpler. x.uma pays off when the rule set grows, changes, or crosses language boundaries.</p>
<h2 id="choosing-an-implementation"><a class="header" href="#choosing-an-implementation">Choosing an Implementation</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Choose</th><th>When</th></tr>
</thead>
<tbody>
<tr><td><strong>rumi</strong> (Rust)</td><td>Maximum performance, Rust codebase, embedding in other systems</td></tr>
<tr><td><strong>xuma</strong> (Python)</td><td>Python codebase, prototyping, Django/Flask/FastAPI integration</td></tr>
<tr><td><strong>xuma</strong> (TypeScript)</td><td>TypeScript codebase, Bun runtime, edge functions</td></tr>
<tr><td><strong>puma-crusty</strong> (Python+Rust)</td><td>Python codebase needing Rust performance (especially regex)</td></tr>
<tr><td><strong>bumi-crusty</strong> (TypeScript+WASM)</td><td>TypeScript needing Rust performance in the browser or edge</td></tr>
</tbody>
</table>
</div>
<p>Pure implementations (rumi, xuma Python, xuma TypeScript) are self-contained with no native dependencies beyond RE2. Crusty variants wrap the Rust core through FFI — same API, Rust performance.</p>
<h2 id="next-9"><a class="header" href="#next-9">Next</a></h2>
<ul>
<li><a href="#architecture">Architecture</a> — the design behind the engine</li>
<li><a href="#benchmarks">Benchmarks</a> — concrete performance numbers</li>
<li><a href="#security-model">Security Model</a> — safety guarantees in depth</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="xds-semantics"><a class="header" href="#xds-semantics">xDS Semantics</a></h1>
<p>x.uma implements the evaluation semantics of the <a href="https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/advanced/matching/matching_api">xDS Unified Matcher API</a>, the matching system used by Envoy at Google scale. This page explains where these semantics come from and why they matter.</p>
<h2 id="what-is-xds"><a class="header" href="#what-is-xds">What is xDS?</a></h2>
<p>xDS is a family of discovery service APIs developed for Envoy proxy. The “x” is a wildcard — CDS (Cluster), RDS (Route), LDS (Listener), EDS (Endpoint), and others. These APIs define how a data plane (Envoy) receives configuration from a control plane.</p>
<p>The <strong>Unified Matcher API</strong> is the matching subsystem within xDS. It replaces Envoy’s earlier route-specific matching with a generic, tree-structured matcher that works across all xDS resource types. x.uma implements this matcher’s evaluation semantics.</p>
<h2 id="the-proto-specification"><a class="header" href="#the-proto-specification">The Proto Specification</a></h2>
<p>The xDS matcher is defined in protobuf. The key messages:</p>
<pre><code class="language-protobuf">// Simplified from xds.type.matcher.v3
message Matcher {
  message MatcherList {
    repeated FieldMatcher matchers = 1;
  }

  message MatcherTree { /* radix/map matching */ }

  oneof matcher_type {
    MatcherList matcher_list = 1;
    MatcherTree matcher_tree = 2;
  }

  Matcher.OnMatch on_no_match = 3;
}

message Matcher.OnMatch {
  oneof on_match {
    Matcher matcher = 1;              // nested matcher (continue)
    core.v3.TypedExtensionConfig action = 2;  // terminal action
  }
}

message Matcher.MatcherList.FieldMatcher {
  Predicate predicate = 1;
  Matcher.OnMatch on_match = 2;
}
</code></pre>
<p>Three things to notice:</p>
<ol>
<li>
<p><strong>OnMatch is exclusive</strong> — <code>oneof</code> means action XOR nested matcher. Never both. The proto schema makes illegal states unrepresentable.</p>
</li>
<li>
<p><strong><code>on_no_match</code> is at the Matcher level</strong>, not per-FieldMatcher. This is deliberate — it means “nothing in this matcher matched”, not “this particular rule didn’t match”.</p>
</li>
<li>
<p><strong>TypedExtensionConfig</strong> is the extension point. Inputs and actions are identified by type URL, enabling new domains without changing the proto schema.</p>
</li>
</ol>
<h2 id="evaluation-rules"><a class="header" href="#evaluation-rules">Evaluation Rules</a></h2>
<p>x.uma implements six rules from the xDS specification. These are not design choices — they are protocol obligations.</p>
<h3 id="rule-1-first-match-wins-1"><a class="header" href="#rule-1-first-match-wins-1">Rule 1: First-Match-Wins</a></h3>
<p><code>MatcherList</code> evaluates field matchers in order. The first match wins. Later entries are never consulted.</p>
<p>This comes from xDS <code>keep_matching</code> semantics. Envoy’s implementation records the action but returns no-match when <code>keep_matching</code> is true, allowing later rules to override. x.uma enforces the simpler invariant: first match is final.</p>
<p><strong>Consequence:</strong> Rule order matters. Put specific rules before general ones. <code>/api/v2</code> must come before <code>/api</code> if you need to distinguish them.</p>
<h3 id="rule-2-onmatch-exclusivity-1"><a class="header" href="#rule-2-onmatch-exclusivity-1">Rule 2: OnMatch Exclusivity</a></h3>
<p>Each <code>OnMatch</code> is either a terminal action or a nested matcher. The <code>oneof</code> in the proto enforces this — you cannot specify both.</p>
<p>x.uma carries this into the type system:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust: enum makes illegal states unrepresentable
pub enum OnMatch&lt;Ctx, A&gt; {
    Action(A),
    Matcher(Box&lt;Matcher&lt;Ctx, A&gt;&gt;),
}
<span class="boring">}</span></code></pre>
<pre><code class="language-python"># Python: union type
type OnMatch[Ctx, A] = Action[A] | NestedMatcher[Ctx, A]
</code></pre>
<pre><code class="language-typescript">// TypeScript: discriminated union
type OnMatch&lt;Ctx, A&gt; = Action&lt;A&gt; | NestedMatcher&lt;Ctx, A&gt;;
</code></pre>
<p>When a predicate matches, the outcome is unambiguous.</p>
<h3 id="rule-3-nested-matcher-failure-1"><a class="header" href="#rule-3-nested-matcher-failure-1">Rule 3: Nested Matcher Failure</a></h3>
<p>This is the subtlest rule. If a predicate matches and its <code>OnMatch</code> is a nested matcher, but that nested matcher returns no match, <strong>the parent continues to the next field matcher</strong>.</p>
<p>The nested matcher’s failure does not trigger the parent’s <code>on_no_match</code>. It means “this branch didn’t match — try the next one.”</p>
<p>This comes from Envoy’s implementation: a nested matcher returning no-match causes the parent <code>FieldMatcher</code> to be treated as non-matching, and evaluation proceeds to the next entry in the list.</p>
<h3 id="rule-4-on_no_match-fallback-1"><a class="header" href="#rule-4-on_no_match-fallback-1">Rule 4: on_no_match Fallback</a></h3>
<p>If no field matcher in <code>matcher_list</code> produces a match, the <code>Matcher</code> consults its <code>on_no_match</code> field. If absent, returns null.</p>
<p><code>on_no_match</code> applies <strong>only</strong> when no predicate matched. It does not apply when a nested matcher failed (Rule 3). The distinction matters:</p>
<ul>
<li>No predicate matched → <code>on_no_match</code></li>
<li>Predicate matched, nested matcher failed → continue to next field matcher → eventually <code>on_no_match</code> if nothing else matches</li>
</ul>
<h3 id="rule-5-none-to-false-1"><a class="header" href="#rule-5-none-to-false-1">Rule 5: None-to-False</a></h3>
<p>When a <code>DataInput</code> returns null (data not present), the predicate evaluates to false. The <code>InputMatcher</code> is never called.</p>
<p>This is a security invariant: missing data never accidentally matches. A header that doesn’t exist cannot satisfy <code>ExactMatcher("secret")</code>.</p>
<h3 id="rule-6-depth-validation-1"><a class="header" href="#rule-6-depth-validation-1">Rule 6: Depth Validation</a></h3>
<p>Matcher trees exceeding MAX_DEPTH (32 levels) are rejected at construction time, not evaluation time.</p>
<p>This prevents stack overflow from deeply nested matchers and enforces the “parse, don’t validate” principle — if a <code>Matcher</code> object exists, it’s known to be structurally valid.</p>
<h2 id="typedextensionconfig-the-extension-seam"><a class="header" href="#typedextensionconfig-the-extension-seam">TypedExtensionConfig: The Extension Seam</a></h2>
<p>The xDS spec uses <code>TypedExtensionConfig</code> for both inputs and actions:</p>
<pre><code class="language-protobuf">message TypedExtensionConfig {
  string name = 1;
  google.protobuf.Any typed_config = 2;
}
</code></pre>
<p>x.uma uses this as the extension mechanism. Each domain registers its types under a namespace:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Namespace</th><th>Domain</th><th>Example Types</th></tr>
</thead>
<tbody>
<tr><td><code>xuma.core.v1</code></td><td>Core matchers</td><td><code>StringMatcher</code>, <code>BoolMatcher</code></td></tr>
<tr><td><code>xuma.test.v1</code></td><td>Test/conformance</td><td><code>StringInput</code></td></tr>
<tr><td><code>xuma.http.v1</code></td><td>HTTP matching</td><td><code>PathInput</code>, <code>HeaderInput</code>, <code>MethodInput</code></td></tr>
<tr><td><code>xuma.claude.v1</code></td><td>Claude Code hooks</td><td><code>EventInput</code>, <code>ToolNameInput</code>, <code>ArgumentInput</code></td></tr>
</tbody>
</table>
</div>
<p>The registry resolves type URLs to concrete implementations at config load time. Unknown type URLs are rejected with helpful error messages listing available types.</p>
<h2 id="where-xuma-diverges-from-xds"><a class="header" href="#where-xuma-diverges-from-xds">Where x.uma Diverges from xDS</a></h2>
<p>x.uma implements xDS evaluation semantics but is not a full xDS client:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>xDS</th><th>x.uma</th></tr>
</thead>
<tbody>
<tr><td>Evaluation semantics</td><td>Full spec</td><td>Implemented</td></tr>
<tr><td><code>keep_matching</code></td><td>Supported</td><td>Not supported (first-match-wins only)</td></tr>
<tr><td>MatcherTree (radix)</td><td>Supported</td><td>Supported (Rust only, not in config path yet)</td></tr>
<tr><td>xDS transport (gRPC)</td><td>Required</td><td>Not implemented — x.uma loads config from files</td></tr>
<tr><td>ADS/SotW/Delta</td><td>Discovery protocols</td><td>Not applicable</td></tr>
<tr><td>Resource versioning</td><td>Built-in</td><td>Not applicable</td></tr>
</tbody>
</table>
</div>
<p>x.uma takes the evaluation engine and makes it portable across languages. It does not implement the xDS discovery protocol — config arrives through files or programmatic construction, not gRPC streams.</p>
<h2 id="why-xds-semantics"><a class="header" href="#why-xds-semantics">Why xDS Semantics?</a></h2>
<p>Three reasons:</p>
<p><strong>Battle-tested.</strong> These semantics run in production at every company that uses Envoy. The edge cases — nested matcher failure, <code>on_no_match</code> scoping, ordering — have been debugged at scale.</p>
<p><strong>Specification-grade.</strong> The proto definition is unambiguous. When five implementations need to agree on behavior, ambiguity is the enemy. xDS gives us a formal spec to implement against.</p>
<p><strong>Extensible by design.</strong> <code>TypedExtensionConfig</code> was designed for exactly this use case — adding new domains without changing the core protocol. x.uma’s HTTP and Claude Code domains prove the pattern works.</p>
<h2 id="next-10"><a class="header" href="#next-10">Next</a></h2>
<ul>
<li><a href="#first-match-wins-semantics">First-Match-Wins Semantics</a> — the six rules with code examples</li>
<li><a href="#architecture">Architecture</a> — how x.uma implements these semantics</li>
<li><a href="#config-format">Config Format</a> — the config schema that maps to xDS structures</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cli-reference-rumi"><a class="header" href="#cli-reference-rumi">CLI Reference (rumi)</a></h1>
<p><code>rumi</code> is the command-line interface for evaluating and validating matcher configs.</p>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<pre><code class="language-bash">cargo install --path rumi/cli
</code></pre>
<h2 id="commands"><a class="header" href="#commands">Commands</a></h2>
<h3 id="eval"><a class="header" href="#eval">eval</a></h3>
<p>Evaluate a config file against a context:</p>
<pre><code class="language-bash">rumi eval config.yaml --context method=GET path=/api
</code></pre>
<p>Loads the config, builds the matcher, evaluates against the provided context, and prints the resulting action. Prints <code>(no match)</code> if nothing matched.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Flag</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>--context key=value...</code></td><td>Context key-value pairs</td></tr>
</tbody>
</table>
</div>
<p>The config file can be YAML (<code>.yaml</code>, <code>.yml</code>) or JSON (<code>.json</code>). Context values are passed as string key-value pairs.</p>
<h3 id="check"><a class="header" href="#check">check</a></h3>
<p>Validate a config file without evaluating:</p>
<pre><code class="language-bash">rumi check config.yaml
</code></pre>
<p>Loads the config, builds the matcher (including registry resolution and depth validation), and reports success or failure. Catches: unknown type URLs, invalid regex patterns, depth limit violations, malformed config.</p>
<p>Prints <code>Config valid</code> on success. Exits with non-zero status on error.</p>
<h3 id="info"><a class="header" href="#info">info</a></h3>
<p>List all registered type URLs:</p>
<pre><code class="language-bash">rumi info
</code></pre>
<p>Output:</p>
<pre><code>Registered inputs:
  xuma.test.v1.StringInput

Registered matchers:
  xuma.core.v1.StringMatcher
  xuma.core.v1.BoolMatcher
</code></pre>
<p>Shows what types the CLI can resolve when loading configs. The CLI registers the test domain by default.</p>
<h3 id="help"><a class="header" href="#help">help</a></h3>
<pre><code class="language-bash">rumi help
rumi --help
rumi -h
</code></pre>
<h2 id="config-file-format"><a class="header" href="#config-file-format">Config File Format</a></h2>
<p>The CLI accepts the same config format used by all implementations. See <a href="#config-format">Config Format</a> for the full schema.</p>
<p>Example <code>config.yaml</code>:</p>
<pre><code class="language-yaml">matchers:
  - predicate:
      type: single
      input: { type_url: "xuma.test.v1.StringInput", config: { key: "method" } }
      value_match: { Exact: "GET" }
    on_match: { type: action, action: "route-get" }
  - predicate:
      type: single
      input: { type_url: "xuma.test.v1.StringInput", config: { key: "method" } }
      value_match: { Exact: "POST" }
    on_match: { type: action, action: "route-post" }
on_no_match: { type: action, action: "fallback" }
</code></pre>
<pre><code class="language-bash">$ rumi eval config.yaml --context method=GET
route-get

$ rumi eval config.yaml --context method=DELETE
fallback

$ rumi check config.yaml
Config valid
</code></pre>
<h2 id="exit-codes"><a class="header" href="#exit-codes">Exit Codes</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Code</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><td>0</td><td>Success</td></tr>
<tr><td>1</td><td>Error (invalid config, unknown command, etc.)</td></tr>
</tbody>
</table>
</div>
<h2 id="design"><a class="header" href="#design">Design</a></h2>
<p>The CLI has zero dependencies beyond <code>rumi</code> and <code>rumi-test</code>. No <code>clap</code> — argument parsing is hand-written. The binary is small and builds fast.</p>
<p>The CLI uses the <strong>config path</strong>: JSON/YAML → <code>MatcherConfig</code> → <code>Registry::load_matcher()</code> → evaluate. It registers the test domain (<code>xuma.test.v1.*</code>), which provides <code>StringInput</code> for key-value context.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="config-format"><a class="header" href="#config-format">Config Format</a></h1>
<p>The config format is shared across all five implementations. Same JSON/YAML structure, same semantics.</p>
<h2 id="matcherconfig"><a class="header" href="#matcherconfig">MatcherConfig</a></h2>
<p>Top-level config for a matcher:</p>
<pre><code class="language-json">{
  "matchers": [ ... ],
  "on_no_match": { ... }
}
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>matchers</code></td><td>array of <code>FieldMatcherConfig</code></td><td>Yes</td><td>Field matchers evaluated in order</td></tr>
<tr><td><code>on_no_match</code></td><td><code>OnMatchConfig</code></td><td>No</td><td>Fallback when no field matcher matches</td></tr>
</tbody>
</table>
</div>
<h2 id="fieldmatcherconfig"><a class="header" href="#fieldmatcherconfig">FieldMatcherConfig</a></h2>
<p>A single rule: predicate + action:</p>
<pre><code class="language-json">{
  "predicate": { ... },
  "on_match": { ... }
}
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>predicate</code></td><td><code>PredicateConfig</code></td><td>Yes</td><td>Condition to evaluate</td></tr>
<tr><td><code>on_match</code></td><td><code>OnMatchConfig</code></td><td>Yes</td><td>What to do when predicate matches</td></tr>
</tbody>
</table>
</div>
<h2 id="predicateconfig"><a class="header" href="#predicateconfig">PredicateConfig</a></h2>
<p>Boolean logic over conditions. Discriminated by <code>type</code>:</p>
<h3 id="single"><a class="header" href="#single">single</a></h3>
<p>Extract a value and match it:</p>
<pre><code class="language-json">{
  "type": "single",
  "input": { "type_url": "xuma.test.v1.StringInput", "config": { "key": "method" } },
  "value_match": { "Exact": "GET" }
}
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>type</code></td><td><code>"single"</code></td><td>Yes</td><td>Discriminator</td></tr>
<tr><td><code>input</code></td><td><code>TypedConfig</code></td><td>Yes</td><td>Data input reference (resolved via registry)</td></tr>
<tr><td><code>value_match</code></td><td><code>ValueMatch</code></td><td>One of</td><td>Built-in string match</td></tr>
<tr><td><code>custom_match</code></td><td><code>TypedConfig</code></td><td>One of</td><td>Custom matcher via registry</td></tr>
</tbody>
</table>
</div>
<p>Exactly one of <code>value_match</code> or <code>custom_match</code> must be set.</p>
<h3 id="and-1"><a class="header" href="#and-1">and</a></h3>
<p>All child predicates must match:</p>
<pre><code class="language-json">{
  "type": "and",
  "predicates": [ { "type": "single", ... }, { "type": "single", ... } ]
}
</code></pre>
<h3 id="or-1"><a class="header" href="#or-1">or</a></h3>
<p>Any child predicate must match:</p>
<pre><code class="language-json">{
  "type": "or",
  "predicates": [ { "type": "single", ... }, { "type": "single", ... } ]
}
</code></pre>
<h3 id="not-1"><a class="header" href="#not-1">not</a></h3>
<p>Negate a predicate:</p>
<pre><code class="language-json">{
  "type": "not",
  "predicate": { "type": "single", ... }
}
</code></pre>
<h2 id="onmatchconfig"><a class="header" href="#onmatchconfig">OnMatchConfig</a></h2>
<p>Either a terminal action or a nested matcher. Discriminated by <code>type</code>:</p>
<h3 id="action"><a class="header" href="#action">action</a></h3>
<p>Return a value:</p>
<pre><code class="language-json">{ "type": "action", "action": "route-get" }
</code></pre>
<p>The <code>action</code> field can be any JSON value — string, number, object. The engine doesn’t interpret it.</p>
<h3 id="matcher"><a class="header" href="#matcher">matcher</a></h3>
<p>Continue evaluation with a nested matcher:</p>
<pre><code class="language-json">{
  "type": "matcher",
  "matcher": {
    "matchers": [ ... ],
    "on_no_match": { ... }
  }
}
</code></pre>
<p>Action XOR matcher — never both. This enforces OnMatch exclusivity from the xDS spec.</p>
<h2 id="typedconfig"><a class="header" href="#typedconfig">TypedConfig</a></h2>
<p>Reference to a registered type:</p>
<pre><code class="language-json">{ "type_url": "xuma.test.v1.StringInput", "config": { "key": "method" } }
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>type_url</code></td><td>string</td><td>Yes</td><td>Registered type identifier</td></tr>
<tr><td><code>config</code></td><td>object</td><td>No (defaults to <code>{}</code>)</td><td>Type-specific configuration</td></tr>
</tbody>
</table>
</div>
<p>The <code>type_url</code> is resolved at load time via the Registry. Unknown type URLs produce an error listing available types.</p>
<h2 id="valuematch"><a class="header" href="#valuematch">ValueMatch</a></h2>
<p>Built-in string matchers:</p>
<pre><code class="language-json">{ "Exact": "hello" }
{ "Prefix": "/api" }
{ "Suffix": ".json" }
{ "Contains": "admin" }
{ "Regex": "^Bearer .+$" }
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Variant</th><th>Matches</th></tr>
</thead>
<tbody>
<tr><td><code>Exact</code></td><td>Exact string equality</td></tr>
<tr><td><code>Prefix</code></td><td>String starts with value</td></tr>
<tr><td><code>Suffix</code></td><td>String ends with value</td></tr>
<tr><td><code>Contains</code></td><td>String contains value</td></tr>
<tr><td><code>Regex</code></td><td>RE2 regex pattern (linear time)</td></tr>
</tbody>
</table>
</div>
<h2 id="core-type-urls"><a class="header" href="#core-type-urls">Core Type URLs</a></h2>
<p>Registered by <code>register_core_matchers()</code> in all implementations:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type URL</th><th>Type</th><th>Config</th></tr>
</thead>
<tbody>
<tr><td><code>xuma.core.v1.StringMatcher</code></td><td>InputMatcher</td><td><code>StringMatchSpec</code></td></tr>
<tr><td><code>xuma.core.v1.BoolMatcher</code></td><td>InputMatcher</td><td><code>{ "value": true }</code></td></tr>
</tbody>
</table>
</div>
<h2 id="full-example"><a class="header" href="#full-example">Full Example</a></h2>
<p>YAML config matching HTTP-like requests:</p>
<pre><code class="language-yaml">matchers:
  - predicate:
      type: and
      predicates:
        - type: single
          input: { type_url: "xuma.test.v1.StringInput", config: { key: "method" } }
          value_match: { Exact: "GET" }
        - type: single
          input: { type_url: "xuma.test.v1.StringInput", config: { key: "path" } }
          value_match: { Prefix: "/api" }
    on_match: { type: action, action: "api_get" }

  - predicate:
      type: single
      input: { type_url: "xuma.test.v1.StringInput", config: { key: "path" } }
      value_match: { Exact: "/health" }
    on_match: { type: action, action: "health" }

on_no_match: { type: action, action: "not_found" }
</code></pre>
<h2 id="validation-limits"><a class="header" href="#validation-limits">Validation Limits</a></h2>
<p>Configs are validated at load time:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Limit</th><th>Value</th><th>Error</th></tr>
</thead>
<tbody>
<tr><td>Max nesting depth</td><td>32 levels</td><td><code>DepthExceeded</code></td></tr>
<tr><td>Max field matchers per matcher</td><td>256</td><td><code>TooManyFieldMatchers</code></td></tr>
<tr><td>Max predicates per AND/OR</td><td>256</td><td><code>TooManyPredicates</code></td></tr>
<tr><td>Max pattern length</td><td>8192 chars</td><td><code>PatternTooLong</code></td></tr>
<tr><td>Max regex pattern length</td><td>4096 chars</td><td><code>PatternTooLong</code></td></tr>
</tbody>
</table>
</div>
<p>If a config loads successfully, the resulting matcher is guaranteed to be structurally valid. Parse, don’t validate.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rust-api-reference"><a class="header" href="#rust-api-reference">Rust API Reference</a></h1>
<h2 id="crates"><a class="header" href="#crates">Crates</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Crate</th><th>Package</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>rumi</code></td><td><code>rumi-core</code></td><td>Core matcher engine</td></tr>
<tr><td><code>rumi-http</code></td><td><code>rumi-http</code></td><td>HTTP domain (simple + ext-proc)</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-toml">[dependencies]
rumi = "0.0.2"
rumi-http = "0.0.2"

# With Claude domain
rumi = { version = "0.0.2", features = ["claude"] }

# With config/registry
rumi = { version = "0.0.2", features = ["registry"] }
</code></pre>
<h2 id="core-types"><a class="header" href="#core-types">Core Types</a></h2>
<h3 id="prelude"><a class="header" href="#prelude">Prelude</a></h3>
<pre><code class="language-rust ignore">use rumi::prelude::*;</code></pre>
<p>Imports: <code>Matcher</code>, <code>FieldMatcher</code>, <code>OnMatch</code>, <code>Predicate</code>, <code>SinglePredicate</code>, <code>MatchingData</code>, <code>DataInput</code>, <code>InputMatcher</code>, <code>ExactMatcher</code>, <code>PrefixMatcher</code>, <code>SuffixMatcher</code>, <code>ContainsMatcher</code>, <code>StringMatcher</code>, <code>BoolMatcher</code>, <code>MatcherError</code>, <code>EvalTrace</code>, <code>EvalStep</code>.</p>
<h3 id="matchingdata"><a class="header" href="#matchingdata">MatchingData</a></h3>
<pre><code class="language-rust ignore">pub enum MatchingData {
    None,
    String(String),
    Int(i64),
    Bool(bool),
    Bytes(Vec&lt;u8&gt;),
    Custom(Box&lt;dyn CustomMatchData&gt;),
}</code></pre>
<p>The type-erased bridge. <code>DataInput</code> returns it, <code>InputMatcher</code> consumes it.</p>
<h3 id="datainput"><a class="header" href="#datainput">DataInput</a></h3>
<pre><code class="language-rust ignore">pub trait DataInput&lt;Ctx&gt;: Send + Sync + Debug {
    fn get(&amp;self, ctx: &amp;Ctx) -&gt; MatchingData;
}</code></pre>
<p>Domain-specific: extracts a value from the context. Generic over <code>Ctx</code>. Must be <code>Send + Sync</code> for thread safety.</p>
<h3 id="inputmatcher"><a class="header" href="#inputmatcher">InputMatcher</a></h3>
<pre><code class="language-rust ignore">pub trait InputMatcher: Send + Sync + Debug {
    fn matches(&amp;self, value: &amp;MatchingData) -&gt; bool;
}</code></pre>
<p>Domain-agnostic: matches a <code>MatchingData</code> value. Non-generic — the same implementation works across all domains.</p>
<h3 id="matcher-1"><a class="header" href="#matcher-1">Matcher</a></h3>
<pre><code class="language-rust ignore">pub struct Matcher&lt;Ctx, A&gt; { /* ... */ }

impl&lt;Ctx, A: Clone&gt; Matcher&lt;Ctx, A&gt; {
    pub fn new(matchers: Vec&lt;FieldMatcher&lt;Ctx, A&gt;&gt;, on_no_match: Option&lt;OnMatch&lt;Ctx, A&gt;&gt;) -&gt; Self;
    pub fn evaluate(&amp;self, ctx: &amp;Ctx) -&gt; Option&lt;A&gt;;
    pub fn evaluate_with_trace(&amp;self, ctx: &amp;Ctx) -&gt; (Option&lt;A&gt;, EvalTrace);
}</code></pre>
<h3 id="onmatch"><a class="header" href="#onmatch">OnMatch</a></h3>
<pre><code class="language-rust ignore">pub enum OnMatch&lt;Ctx, A&gt; {
    Action(A),
    Matcher(Box&lt;Matcher&lt;Ctx, A&gt;&gt;),
}</code></pre>
<p>Action XOR nested matcher. Illegal states unrepresentable.</p>
<h3 id="predicate"><a class="header" href="#predicate">Predicate</a></h3>
<pre><code class="language-rust ignore">pub enum Predicate&lt;Ctx&gt; {
    Single(SinglePredicate&lt;Ctx&gt;),
    And(Vec&lt;Predicate&lt;Ctx&gt;&gt;),
    Or(Vec&lt;Predicate&lt;Ctx&gt;&gt;),
    Not(Box&lt;Predicate&lt;Ctx&gt;&gt;),
}</code></pre>
<h2 id="string-matchers"><a class="header" href="#string-matchers">String Matchers</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Match Behavior</th></tr>
</thead>
<tbody>
<tr><td><code>ExactMatcher::new("value")</code></td><td>Exact string equality</td></tr>
<tr><td><code>PrefixMatcher::new("/api")</code></td><td>Starts with</td></tr>
<tr><td><code>SuffixMatcher::new(".json")</code></td><td>Ends with</td></tr>
<tr><td><code>ContainsMatcher::new("admin")</code></td><td>Contains substring</td></tr>
<tr><td><code>StringMatcher::new("^pat$")</code></td><td>RE2 regex (linear time)</td></tr>
<tr><td><code>BoolMatcher::new(true)</code></td><td>Boolean equality</td></tr>
</tbody>
</table>
</div>
<h2 id="http-types-rumi-http"><a class="header" href="#http-types-rumi-http">HTTP Types (rumi-http)</a></h2>
<h3 id="simple-module-always-available"><a class="header" href="#simple-module-always-available">Simple Module (always available)</a></h3>
<pre><code class="language-rust ignore">use rumi_http::simple::*;

let request = HttpRequest::builder()
    .method("GET")
    .path("/api/users")
    .header("authorization", "Bearer token")
    .query_param("page", "1")
    .build();</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>HttpRequest</code></td><td>Simple HTTP request context</td></tr>
<tr><td><code>HttpRequestBuilder</code></td><td>Builder for <code>HttpRequest</code></td></tr>
<tr><td><code>SimplePathInput</code></td><td>Extracts request path</td></tr>
<tr><td><code>SimpleMethodInput</code></td><td>Extracts HTTP method</td></tr>
<tr><td><code>SimpleHeaderInput::new(name)</code></td><td>Extracts header (case-insensitive)</td></tr>
<tr><td><code>SimpleQueryParamInput::new(name)</code></td><td>Extracts query parameter</td></tr>
</tbody>
</table>
</div>
<h2 id="claude-types-feature--claude"><a class="header" href="#claude-types-feature--claude">Claude Types (feature = “claude”)</a></h2>
<pre><code class="language-rust ignore">use rumi::claude::prelude::*;</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>HookContext</code></td><td>Claude Code hook event context</td></tr>
<tr><td><code>HookEvent</code></td><td>Enum of 9 hook event types</td></tr>
<tr><td><code>HookMatch</code></td><td>Declarative hook match config</td></tr>
<tr><td><code>HookMatchExt</code></td><td>Extension trait (<code>compile</code>, <code>trace</code>)</td></tr>
<tr><td><code>EventInput</code></td><td>Extracts event type</td></tr>
<tr><td><code>ToolNameInput</code></td><td>Extracts tool name</td></tr>
<tr><td><code>ArgumentInput::new(name)</code></td><td>Extracts tool argument</td></tr>
<tr><td><code>SessionIdInput</code></td><td>Extracts session ID</td></tr>
<tr><td><code>CwdInput</code></td><td>Extracts working directory</td></tr>
<tr><td><code>GitBranchInput</code></td><td>Extracts git branch</td></tr>
</tbody>
</table>
</div>
<h2 id="registry-feature--registry"><a class="header" href="#registry-feature--registry">Registry (feature = “registry”)</a></h2>
<pre><code class="language-rust ignore">use rumi::{RegistryBuilder, Registry, IntoDataInput, register_core_matchers};

let registry: Registry&lt;MyContext&gt; = RegistryBuilder::new()
    .input::&lt;MyInput&gt;("myapp.v1.MyInput")
    .build();

let matcher = registry.load_matcher(config)?;</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>RegistryBuilder&lt;Ctx&gt;</code></td><td>Mutable builder for type registration</td></tr>
<tr><td><code>Registry&lt;Ctx&gt;</code></td><td>Immutable registry (Send + Sync)</td></tr>
<tr><td><code>IntoDataInput&lt;Ctx&gt;</code></td><td>Trait for config-driven input construction</td></tr>
<tr><td><code>MatcherConfig&lt;A&gt;</code></td><td>Deserializable matcher configuration</td></tr>
<tr><td><code>TypedConfig</code></td><td>Type URL + config payload reference</td></tr>
</tbody>
</table>
</div>
<h2 id="constants"><a class="header" href="#constants">Constants</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Constant</th><th>Value</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>MAX_DEPTH</code></td><td>32</td><td>Maximum nested matcher depth</td></tr>
<tr><td><code>MAX_FIELD_MATCHERS</code></td><td>256</td><td>Maximum field matchers per <code>Matcher</code></td></tr>
<tr><td><code>MAX_PREDICATES_PER_COMPOUND</code></td><td>256</td><td>Maximum children per AND/OR</td></tr>
<tr><td><code>MAX_PATTERN_LENGTH</code></td><td>8192</td><td>Maximum non-regex pattern length</td></tr>
<tr><td><code>MAX_REGEX_PATTERN_LENGTH</code></td><td>4096</td><td>Maximum regex pattern length</td></tr>
</tbody>
</table>
</div>
<h2 id="errors"><a class="header" href="#errors">Errors</a></h2>
<pre><code class="language-rust ignore">pub enum MatcherError {
    DepthExceeded { depth, max },
    InvalidPattern { pattern, source },
    InvalidConfig { source },
    UnknownTypeUrl { type_url, registry, available },
    IncompatibleTypes { input_type, matcher_types },
    TooManyFieldMatchers { count, max },
    TooManyPredicates { count, max },
    PatternTooLong { len, max },
}</code></pre>
<p>All errors are caught at construction time, not evaluation time. <code>MatcherError</code> implements <code>Display</code> with actionable messages.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="python-api-reference"><a class="header" href="#python-api-reference">Python API Reference</a></h1>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<pre><code class="language-bash">uv add xuma
</code></pre>
<p>Requires Python 3.12+. Dependency: <code>google-re2</code> for linear-time regex.</p>
<h2 id="package-xuma"><a class="header" href="#package-xuma">Package: xuma</a></h2>
<pre><code class="language-python">from xuma import (
    # Protocols
    DataInput, InputMatcher, MatchingData,
    # Predicates
    SinglePredicate, And, Or, Not, Predicate,
    # Matcher tree
    Matcher, FieldMatcher, Action, NestedMatcher, OnMatch,
    # String matchers
    ExactMatcher, PrefixMatcher, SuffixMatcher, ContainsMatcher, RegexMatcher,
    # Registry
    RegistryBuilder, Registry, register_core_matchers,
    # Config
    MatcherConfig, parse_matcher_config,
    # Constants
    MAX_DEPTH, MAX_FIELD_MATCHERS, MAX_PREDICATES_PER_COMPOUND,
    MAX_PATTERN_LENGTH, MAX_REGEX_PATTERN_LENGTH,
    # Errors
    MatcherError, UnknownTypeUrlError, InvalidConfigError,
    TooManyFieldMatchersError, TooManyPredicatesError, PatternTooLongError,
)
</code></pre>
<h2 id="core-types-1"><a class="header" href="#core-types-1">Core Types</a></h2>
<h3 id="matchingdata-1"><a class="header" href="#matchingdata-1">MatchingData</a></h3>
<pre><code class="language-python">type MatchingData = str | int | bool | bytes | None
</code></pre>
<h3 id="datainput-protocol"><a class="header" href="#datainput-protocol">DataInput Protocol</a></h3>
<pre><code class="language-python">class DataInput[Ctx]:
    def get(self, ctx: Ctx) -&gt; MatchingData: ...
</code></pre>
<h3 id="inputmatcher-protocol"><a class="header" href="#inputmatcher-protocol">InputMatcher Protocol</a></h3>
<pre><code class="language-python">class InputMatcher:
    def matches(self, value: MatchingData) -&gt; bool: ...
</code></pre>
<h3 id="matcher-2"><a class="header" href="#matcher-2">Matcher</a></h3>
<pre><code class="language-python">Matcher(
    matcher_list: tuple[FieldMatcher[Ctx, A], ...],
    on_no_match: OnMatch[Ctx, A] | None = None,
)

matcher.evaluate(ctx: Ctx) -&gt; A | None
</code></pre>
<h3 id="fieldmatcher"><a class="header" href="#fieldmatcher">FieldMatcher</a></h3>
<pre><code class="language-python">FieldMatcher(
    predicate: Predicate[Ctx],
    on_match: OnMatch[Ctx, A],
)
</code></pre>
<h3 id="onmatch-1"><a class="header" href="#onmatch-1">OnMatch</a></h3>
<pre><code class="language-python">type OnMatch[Ctx, A] = Action[A] | NestedMatcher[Ctx, A]

Action(value: A)
NestedMatcher(matcher: Matcher[Ctx, A])
</code></pre>
<h3 id="predicates"><a class="header" href="#predicates">Predicates</a></h3>
<pre><code class="language-python">SinglePredicate(input: DataInput[Ctx], matcher: InputMatcher)
And(predicates: tuple[Predicate[Ctx], ...])
Or(predicates: tuple[Predicate[Ctx], ...])
Not(predicate: Predicate[Ctx])

type Predicate[Ctx] = SinglePredicate[Ctx] | And[Ctx] | Or[Ctx] | Not[Ctx]
</code></pre>
<h2 id="string-matchers-1"><a class="header" href="#string-matchers-1">String Matchers</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Class</th><th>Constructor</th><th>Matches</th></tr>
</thead>
<tbody>
<tr><td><code>ExactMatcher(value)</code></td><td><code>ExactMatcher("hello")</code></td><td>Exact string equality</td></tr>
<tr><td><code>PrefixMatcher(prefix)</code></td><td><code>PrefixMatcher("/api")</code></td><td>Starts with</td></tr>
<tr><td><code>SuffixMatcher(suffix)</code></td><td><code>SuffixMatcher(".json")</code></td><td>Ends with</td></tr>
<tr><td><code>ContainsMatcher(substring)</code></td><td><code>ContainsMatcher("admin")</code></td><td>Contains</td></tr>
<tr><td><code>RegexMatcher(pattern)</code></td><td><code>RegexMatcher("^Bearer .+$")</code></td><td>RE2 regex</td></tr>
</tbody>
</table>
</div>
<p>All matchers are frozen dataclasses.</p>
<h2 id="http-domain"><a class="header" href="#http-domain">HTTP Domain</a></h2>
<pre><code class="language-python">from xuma.http import (
    HttpRequest, PathInput, MethodInput, HeaderInput, QueryParamInput,
    HttpRouteMatch, HttpPathMatch, HttpHeaderMatch, HttpQueryParamMatch,
    compile_route_matches, register,
)
</code></pre>
<h3 id="httprequest"><a class="header" href="#httprequest">HttpRequest</a></h3>
<pre><code class="language-python">HttpRequest(
    method: str = "GET",
    raw_path: str = "/",
    headers: dict[str, str] | None = None,
    query_params: dict[str, str] | None = None,
)
</code></pre>
<h3 id="inputs-2"><a class="header" href="#inputs-2">Inputs</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Class</th><th>Extracts</th><th>Returns</th></tr>
</thead>
<tbody>
<tr><td><code>PathInput()</code></td><td>Request path</td><td><code>str</code></td></tr>
<tr><td><code>MethodInput()</code></td><td>HTTP method</td><td><code>str</code></td></tr>
<tr><td><code>HeaderInput(name)</code></td><td>Header value</td><td>`str</td></tr>
<tr><td><code>QueryParamInput(name)</code></td><td>Query parameter</td><td>`str</td></tr>
</tbody>
</table>
</div>
<h3 id="gateway-api-compiler"><a class="header" href="#gateway-api-compiler">Gateway API Compiler</a></h3>
<pre><code class="language-python">HttpRouteMatch(
    path: HttpPathMatch | None = None,
    method: str | None = None,
    headers: list[HttpHeaderMatch] = [],
    query_params: list[HttpQueryParamMatch] = [],
)

HttpPathMatch(type: "Exact" | "PathPrefix" | "RegularExpression", value: str)
HttpHeaderMatch(type: "Exact" | "RegularExpression", name: str, value: str)
HttpQueryParamMatch(type: "Exact" | "RegularExpression", name: str, value: str)

compile_route_matches(matches, action, on_no_match=None) -&gt; Matcher
</code></pre>
<h2 id="registry"><a class="header" href="#registry">Registry</a></h2>
<pre><code class="language-python">builder = RegistryBuilder()
builder = register_core_matchers(builder)
registry = builder.build()

matcher = registry.load_matcher(config)
</code></pre>
<h3 id="registrybuilder"><a class="header" href="#registrybuilder">RegistryBuilder</a></h3>
<pre><code class="language-python">RegistryBuilder()
    .input(type_url, factory)       # Register a DataInput factory
    .matcher(type_url, factory)     # Register an InputMatcher factory
    .build() -&gt; Registry
</code></pre>
<h3 id="registry-1"><a class="header" href="#registry-1">Registry</a></h3>
<pre><code class="language-python">registry.load_matcher(config: MatcherConfig) -&gt; Matcher
registry.contains_input(type_url: str) -&gt; bool
registry.contains_matcher(type_url: str) -&gt; bool
</code></pre>
<h2 id="config-loading"><a class="header" href="#config-loading">Config Loading</a></h2>
<pre><code class="language-python">from xuma import parse_matcher_config

config = parse_matcher_config(json_dict)  # From dict
</code></pre>
<h2 id="constants-1"><a class="header" href="#constants-1">Constants</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Constant</th><th>Value</th></tr>
</thead>
<tbody>
<tr><td><code>MAX_DEPTH</code></td><td>32</td></tr>
<tr><td><code>MAX_FIELD_MATCHERS</code></td><td>256</td></tr>
<tr><td><code>MAX_PREDICATES_PER_COMPOUND</code></td><td>256</td></tr>
<tr><td><code>MAX_PATTERN_LENGTH</code></td><td>8192</td></tr>
<tr><td><code>MAX_REGEX_PATTERN_LENGTH</code></td><td>4096</td></tr>
</tbody>
</table>
</div>
<h2 id="helpers"><a class="header" href="#helpers">Helpers</a></h2>
<pre><code class="language-python">matcher_from_predicate(predicate, action, on_no_match=None) -&gt; Matcher
and_predicate(predicates, fallback) -&gt; Predicate
or_predicate(predicates, fallback) -&gt; Predicate
predicate_depth(predicate) -&gt; int
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="typescript-api-reference"><a class="header" href="#typescript-api-reference">TypeScript API Reference</a></h1>
<h2 id="installation-2"><a class="header" href="#installation-2">Installation</a></h2>
<pre><code class="language-bash">bun add xuma
</code></pre>
<p>Requires Bun runtime. Dependency: <code>re2js</code> for linear-time regex.</p>
<h2 id="package-xuma-1"><a class="header" href="#package-xuma-1">Package: xuma</a></h2>
<pre><code class="language-typescript">import {
  // Core types
  type DataInput, type InputMatcher, type MatchingData,
  // Predicates
  SinglePredicate, And, Or, Not, type Predicate,
  // Matcher tree
  Matcher, FieldMatcher, Action, NestedMatcher, type OnMatch,
  // String matchers
  ExactMatcher, PrefixMatcher, SuffixMatcher, ContainsMatcher, RegexMatcher,
  // Registry
  RegistryBuilder, Registry,
  // Config
  type MatcherConfig, parseMatcherConfig,
  // Constants
  MAX_DEPTH, MAX_FIELD_MATCHERS, MAX_PREDICATES_PER_COMPOUND,
  MAX_PATTERN_LENGTH, MAX_REGEX_PATTERN_LENGTH,
  // Errors
  MatcherError, UnknownTypeUrlError, InvalidConfigError,
  TooManyFieldMatchersError, TooManyPredicatesError, PatternTooLongError,
} from "xuma";
</code></pre>
<h2 id="core-types-2"><a class="header" href="#core-types-2">Core Types</a></h2>
<h3 id="matchingdata-2"><a class="header" href="#matchingdata-2">MatchingData</a></h3>
<pre><code class="language-typescript">type MatchingData = string | number | boolean | Uint8Array | null;
</code></pre>
<h3 id="datainput-1"><a class="header" href="#datainput-1">DataInput</a></h3>
<pre><code class="language-typescript">interface DataInput&lt;Ctx&gt; {
  get(ctx: Ctx): MatchingData;
}
</code></pre>
<h3 id="inputmatcher-1"><a class="header" href="#inputmatcher-1">InputMatcher</a></h3>
<pre><code class="language-typescript">interface InputMatcher {
  matches(value: MatchingData): boolean;
}
</code></pre>
<h3 id="matcher-3"><a class="header" href="#matcher-3">Matcher</a></h3>
<pre><code class="language-typescript">class Matcher&lt;Ctx, A&gt; {
  constructor(matchers: FieldMatcher&lt;Ctx, A&gt;[], onNoMatch?: OnMatch&lt;Ctx, A&gt;);
  evaluate(ctx: Ctx): A | null;
}
</code></pre>
<h3 id="fieldmatcher-1"><a class="header" href="#fieldmatcher-1">FieldMatcher</a></h3>
<pre><code class="language-typescript">class FieldMatcher&lt;Ctx, A&gt; {
  constructor(predicate: Predicate&lt;Ctx&gt;, onMatch: OnMatch&lt;Ctx, A&gt;);
}
</code></pre>
<h3 id="onmatch-2"><a class="header" href="#onmatch-2">OnMatch</a></h3>
<pre><code class="language-typescript">type OnMatch&lt;Ctx, A&gt; = Action&lt;A&gt; | NestedMatcher&lt;Ctx, A&gt;;

class Action&lt;A&gt; { constructor(value: A); }
class NestedMatcher&lt;Ctx, A&gt; { constructor(matcher: Matcher&lt;Ctx, A&gt;); }
</code></pre>
<h3 id="predicates-1"><a class="header" href="#predicates-1">Predicates</a></h3>
<pre><code class="language-typescript">class SinglePredicate&lt;Ctx&gt; { constructor(input: DataInput&lt;Ctx&gt;, matcher: InputMatcher); }
class And&lt;Ctx&gt; { constructor(predicates: Predicate&lt;Ctx&gt;[]); }
class Or&lt;Ctx&gt; { constructor(predicates: Predicate&lt;Ctx&gt;[]); }
class Not&lt;Ctx&gt; { constructor(predicate: Predicate&lt;Ctx&gt;); }

type Predicate&lt;Ctx&gt; = SinglePredicate&lt;Ctx&gt; | And&lt;Ctx&gt; | Or&lt;Ctx&gt; | Not&lt;Ctx&gt;;
</code></pre>
<h2 id="string-matchers-2"><a class="header" href="#string-matchers-2">String Matchers</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Class</th><th>Constructor</th><th>Matches</th></tr>
</thead>
<tbody>
<tr><td><code>new ExactMatcher(value)</code></td><td><code>new ExactMatcher("hello")</code></td><td>Exact equality</td></tr>
<tr><td><code>new PrefixMatcher(prefix)</code></td><td><code>new PrefixMatcher("/api")</code></td><td>Starts with</td></tr>
<tr><td><code>new SuffixMatcher(suffix)</code></td><td><code>new SuffixMatcher(".json")</code></td><td>Ends with</td></tr>
<tr><td><code>new ContainsMatcher(sub)</code></td><td><code>new ContainsMatcher("admin")</code></td><td>Contains</td></tr>
<tr><td><code>new RegexMatcher(pattern)</code></td><td><code>new RegexMatcher("^Bearer .+$")</code></td><td>RE2 regex</td></tr>
</tbody>
</table>
</div>
<p>All types use <code>readonly</code> fields.</p>
<h2 id="http-domain-1"><a class="header" href="#http-domain-1">HTTP Domain</a></h2>
<pre><code class="language-typescript">import {
  HttpRequest, PathInput, MethodInput, HeaderInput, QueryParamInput,
  compileRouteMatch, compileRouteMatches, register,
  type HttpRouteMatch, type HttpPathMatch, type HttpHeaderMatch, type HttpQueryParamMatch,
} from "xuma/http";
</code></pre>
<h3 id="httprequest-1"><a class="header" href="#httprequest-1">HttpRequest</a></h3>
<pre><code class="language-typescript">class HttpRequest {
  constructor(method: string, rawPath: string, headers?: Record&lt;string, string&gt;,
              queryParams?: Record&lt;string, string&gt;);
}
</code></pre>
<h3 id="inputs-3"><a class="header" href="#inputs-3">Inputs</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Class</th><th>Extracts</th><th>Returns</th></tr>
</thead>
<tbody>
<tr><td><code>new PathInput()</code></td><td>Request path</td><td><code>string</code></td></tr>
<tr><td><code>new MethodInput()</code></td><td>HTTP method</td><td><code>string</code></td></tr>
<tr><td><code>new HeaderInput(name)</code></td><td>Header value</td><td><code>string | null</code></td></tr>
<tr><td><code>new QueryParamInput(name)</code></td><td>Query parameter</td><td><code>string | null</code></td></tr>
</tbody>
</table>
</div>
<h3 id="gateway-api-compiler-1"><a class="header" href="#gateway-api-compiler-1">Gateway API Compiler</a></h3>
<pre><code class="language-typescript">interface HttpRouteMatch {
  readonly path?: HttpPathMatch;
  readonly method?: string;
  readonly headers?: readonly HttpHeaderMatch[];
  readonly queryParams?: readonly HttpQueryParamMatch[];
}

interface HttpPathMatch {
  readonly type: "Exact" | "PathPrefix" | "RegularExpression";
  readonly value: string;
}

interface HttpHeaderMatch {
  readonly type: "Exact" | "RegularExpression";
  readonly name: string;
  readonly value: string;
}

interface HttpQueryParamMatch {
  readonly type: "Exact" | "RegularExpression";
  readonly name: string;
  readonly value: string;
}

function compileRouteMatches&lt;A&gt;(matches: HttpRouteMatch[], action: A, onNoMatch?: A): Matcher&lt;HttpRequest, A&gt;;
function compileRouteMatch&lt;A&gt;(routeMatch: HttpRouteMatch, action: A): Matcher&lt;HttpRequest, A&gt;;
</code></pre>
<h2 id="registry-2"><a class="header" href="#registry-2">Registry</a></h2>
<pre><code class="language-typescript">const builder = new RegistryBuilder&lt;MyContext&gt;();
// Register inputs and matchers...
const registry = builder.build();
const matcher = registry.loadMatcher(config);
</code></pre>
<h3 id="registrybuilder-1"><a class="header" href="#registrybuilder-1">RegistryBuilder</a></h3>
<pre><code class="language-typescript">class RegistryBuilder&lt;Ctx&gt; {
  input(typeUrl: string, factory: InputFactory&lt;Ctx&gt;): this;
  matcher(typeUrl: string, factory: MatcherFactory): this;
  build(): Registry&lt;Ctx&gt;;
}
</code></pre>
<h3 id="registry-1-1"><a class="header" href="#registry-1-1">Registry</a></h3>
<pre><code class="language-typescript">class Registry&lt;Ctx&gt; {
  loadMatcher&lt;A&gt;(config: MatcherConfig&lt;A&gt;): Matcher&lt;Ctx, A&gt;;
  containsInput(typeUrl: string): boolean;
  containsMatcher(typeUrl: string): boolean;
}
</code></pre>
<h2 id="constants-2"><a class="header" href="#constants-2">Constants</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Constant</th><th>Value</th></tr>
</thead>
<tbody>
<tr><td><code>MAX_DEPTH</code></td><td>32</td></tr>
<tr><td><code>MAX_FIELD_MATCHERS</code></td><td>256</td></tr>
<tr><td><code>MAX_PREDICATES_PER_COMPOUND</code></td><td>256</td></tr>
<tr><td><code>MAX_PATTERN_LENGTH</code></td><td>8192</td></tr>
<tr><td><code>MAX_REGEX_PATTERN_LENGTH</code></td><td>4096</td></tr>
</tbody>
</table>
</div>
<h2 id="helpers-1"><a class="header" href="#helpers-1">Helpers</a></h2>
<pre><code class="language-typescript">function matcherFromPredicate&lt;Ctx, A&gt;(predicate: Predicate&lt;Ctx&gt;, action: A, onNoMatch?: A): Matcher&lt;Ctx, A&gt;;
function andPredicate&lt;Ctx&gt;(predicates: Predicate&lt;Ctx&gt;[], fallback: Predicate&lt;Ctx&gt;): Predicate&lt;Ctx&gt;;
function orPredicate&lt;Ctx&gt;(predicates: Predicate&lt;Ctx&gt;[], fallback: Predicate&lt;Ctx&gt;): Predicate&lt;Ctx&gt;;
function evaluatePredicate&lt;Ctx&gt;(predicate: Predicate&lt;Ctx&gt;, ctx: Ctx): boolean;
function predicateDepth&lt;Ctx&gt;(predicate: Predicate&lt;Ctx&gt;): number;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="proto-api-reference"><a class="header" href="#proto-api-reference">Proto API Reference</a></h1>
<p>x.uma extends the xDS Unified Matcher API with domain-specific proto definitions under the <code>xuma</code> namespace.</p>
<h2 id="namespaces"><a class="header" href="#namespaces">Namespaces</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Package</th><th>Domain</th><th>Location</th></tr>
</thead>
<tbody>
<tr><td><code>xuma.core.v1</code></td><td>Core action types</td><td><code>proto/xuma/core/v1/</code></td></tr>
<tr><td><code>xuma.test.v1</code></td><td>Test/conformance domain</td><td><code>proto/xuma/test/v1/</code></td></tr>
<tr><td><code>xuma.http.v1</code></td><td>HTTP matching</td><td><code>proto/xuma/http/v1/</code></td></tr>
<tr><td><code>xuma.claude.v1</code></td><td>Claude Code hooks</td><td><code>proto/xuma/claude/v1/</code></td></tr>
</tbody>
</table>
</div>
<h2 id="type-url-convention"><a class="header" href="#type-url-convention">Type URL Convention</a></h2>
<p>Type URLs follow the pattern: <code>xuma.&lt;domain&gt;.&lt;version&gt;.&lt;TypeName&gt;</code></p>
<p>Examples:</p>
<ul>
<li><code>xuma.core.v1.StringMatcher</code></li>
<li><code>xuma.test.v1.StringInput</code></li>
<li><code>xuma.http.v1.PathInput</code></li>
<li><code>xuma.claude.v1.ToolNameInput</code></li>
</ul>
<p>These type URLs are used in <code>TypedConfig</code> references within the config format:</p>
<pre><code class="language-json">{ "type_url": "xuma.http.v1.HeaderInput", "config": { "name": "authorization" } }
</code></pre>
<h2 id="xumacorev1"><a class="header" href="#xumacorev1">xuma.core.v1</a></h2>
<h3 id="namedaction"><a class="header" href="#namedaction">NamedAction</a></h3>
<pre><code class="language-protobuf">message NamedAction {
  string name = 1;
  map&lt;string, string&gt; metadata = 2;
}
</code></pre>
<p>Generic action returned on match. <code>name</code> is the action identifier; <code>metadata</code> carries optional key-value pairs.</p>
<h2 id="xumatestv1"><a class="header" href="#xumatestv1">xuma.test.v1</a></h2>
<h3 id="stringinput"><a class="header" href="#stringinput">StringInput</a></h3>
<p>Input for the test domain. Extracts a named string value from a key-value context.</p>
<p>Config: <code>{ "key": "field_name" }</code></p>
<h3 id="testcontext-runtime"><a class="header" href="#testcontext-runtime">TestContext (Runtime)</a></h3>
<p>A <code>HashMap&lt;String, String&gt;</code> context for conformance testing. Not a proto message — used only in test runners.</p>
<h2 id="xumahttpv1"><a class="header" href="#xumahttpv1">xuma.http.v1</a></h2>
<h3 id="pathinput"><a class="header" href="#pathinput">PathInput</a></h3>
<p>Extracts the HTTP request path. No config required.</p>
<h3 id="methodinput"><a class="header" href="#methodinput">MethodInput</a></h3>
<p>Extracts the HTTP method. No config required.</p>
<h3 id="headerinput"><a class="header" href="#headerinput">HeaderInput</a></h3>
<p>Extracts an HTTP header value by name (case-insensitive). Returns null when absent.</p>
<p>Config: <code>{ "name": "header_name" }</code></p>
<h3 id="queryparaminput"><a class="header" href="#queryparaminput">QueryParamInput</a></h3>
<p>Extracts an HTTP query parameter by name. Returns null when absent.</p>
<p>Config: <code>{ "name": "param_name" }</code></p>
<h2 id="xumaclaudev1"><a class="header" href="#xumaclaudev1">xuma.claude.v1</a></h2>
<h3 id="eventinput"><a class="header" href="#eventinput">EventInput</a></h3>
<p>Extracts the hook event type as a string. No config required.</p>
<h3 id="toolnameinput"><a class="header" href="#toolnameinput">ToolNameInput</a></h3>
<p>Extracts the tool name. No config required.</p>
<h3 id="argumentinput"><a class="header" href="#argumentinput">ArgumentInput</a></h3>
<p>Extracts a tool argument value by name. Returns null when absent.</p>
<p>Config: <code>{ "name": "argument_name" }</code></p>
<h3 id="sessionidinput"><a class="header" href="#sessionidinput">SessionIdInput</a></h3>
<p>Extracts the session identifier. No config required.</p>
<h3 id="cwdinput"><a class="header" href="#cwdinput">CwdInput</a></h3>
<p>Extracts the current working directory. No config required.</p>
<h3 id="gitbranchinput"><a class="header" href="#gitbranchinput">GitBranchInput</a></h3>
<p>Extracts the git branch name. Returns null when not in a repository.</p>
<h2 id="code-generation"><a class="header" href="#code-generation">Code Generation</a></h2>
<p>Proto definitions are compiled with <a href="https://buf.build/">buf</a> to three languages:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Language</th><th>Generator</th><th>Output</th></tr>
</thead>
<tbody>
<tr><td>Rust</td><td><code>prost</code> + <code>prost-serde</code></td><td><code>rumi/proto/src/gen/</code></td></tr>
<tr><td>Python</td><td><code>betterproto</code></td><td><code>puma/proto/src/gen/</code></td></tr>
<tr><td>TypeScript</td><td><code>ts-proto</code></td><td><code>bumi/proto/src/gen/</code></td></tr>
</tbody>
</table>
</div>
<p>Configuration: <code>buf.gen.yaml</code> at project root.</p>
<h2 id="xds-foundation"><a class="header" href="#xds-foundation">xDS Foundation</a></h2>
<p>x.uma’s proto types are designed to be compatible with the xDS <code>TypedExtensionConfig</code> extension mechanism. The xDS matcher proto (<code>xds.type.matcher.v3.Matcher</code>) uses <code>TypedExtensionConfig</code> for both inputs and actions. x.uma domain types register their proto type URLs, enabling interop with xDS-native tooling.</p>
<p>The xDS matcher proto itself is consumed as a buf dependency, not vendored.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="benchmarks"><a class="header" href="#benchmarks">Benchmarks</a></h1>
<p>All five implementations are benchmarked with identical test scenarios. Numbers from a single machine — relative performance between implementations is what matters.</p>
<h2 id="evaluation-performance"><a class="header" href="#evaluation-performance">Evaluation Performance</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Benchmark</th><th>rumi (Rust)</th><th>xuma (Python)</th><th>xuma (TypeScript)</th><th>puma-crusty</th><th>bumi-crusty</th></tr>
</thead>
<tbody>
<tr><td>exact_match_hit</td><td>33ns</td><td>325ns</td><td>9.3ns</td><td>~33ns</td><td>~33ns</td></tr>
<tr><td>exact_match_miss</td><td>30ns</td><td>280ns</td><td>8.5ns</td><td>~30ns</td><td>~30ns</td></tr>
<tr><td>prefix_match</td><td>35ns</td><td>340ns</td><td>10ns</td><td>~35ns</td><td>~35ns</td></tr>
<tr><td>regex_match</td><td>45ns</td><td>520ns</td><td>85ns</td><td>~45ns</td><td>~45ns</td></tr>
<tr><td>and_predicate (3 conditions)</td><td>95ns</td><td>980ns</td><td>28ns</td><td>~95ns</td><td>~95ns</td></tr>
</tbody>
</table>
</div>
<h3 id="key-observations"><a class="header" href="#key-observations">Key Observations</a></h3>
<p><strong>TypeScript (bumi) wins raw exact match.</strong> Bun’s JIT compiles hot paths to native code. For simple string comparisons without regex, JIT-compiled TypeScript outperforms even Rust’s interpreted evaluation.</p>
<p><strong>Rust (rumi) dominates regex.</strong> The Rust <code>regex</code> crate is a DFA-based linear-time engine. TypeScript’s <code>re2js</code> is a pure-JS RE2 port — correct but slower. Python’s <code>google-re2</code> is a C++ binding, faster than <code>re2js</code> but with FFI overhead.</p>
<p><strong>Crusty variants inherit Rust performance.</strong> <code>puma-crusty</code> (PyO3) and <code>bumi-crusty</code> (WASM) run the Rust engine through bindings. Evaluation speed matches rumi. The overhead is in crossing the FFI boundary, not in the evaluation itself.</p>
<p><strong>Python is 10-30x slower for evaluation.</strong> Pure Python interpreter overhead. Acceptable for config-driven matching where evaluation happens once per request.</p>
<h2 id="redos-performance"><a class="header" href="#redos-performance">ReDoS Performance</a></h2>
<p>Matching against a pathological regex pattern designed to cause catastrophic backtracking:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Pattern</th><th>Input Length</th><th>rumi</th><th>xuma (Python)</th><th>xuma (TypeScript)</th></tr>
</thead>
<tbody>
<tr><td><code>(a+)+$</code></td><td>N=10</td><td>11ns</td><td>8ms</td><td>2ms</td></tr>
<tr><td><code>(a+)+$</code></td><td>N=15</td><td>11ns</td><td>28ms</td><td>5ms</td></tr>
<tr><td><code>(a+)+$</code></td><td>N=20</td><td>11ns</td><td>72ms</td><td>11ms</td></tr>
<tr><td><code>(a+)+$</code></td><td>N=25</td><td>11ns</td><td>230ms</td><td>25ms</td></tr>
</tbody>
</table>
</div>
<p><strong>Rust is constant-time</strong> — the <code>regex</code> crate rejects patterns that would cause backtracking. Time doesn’t grow with input size.</p>
<p><strong>Python and TypeScript grow linearly</strong> — <code>google-re2</code> and <code>re2js</code> enforce linear-time semantics, but their constant factors are higher. Still fundamentally safe — no exponential blowup.</p>
<p><strong>Without RE2, these patterns cause exponential backtracking.</strong> N=25 with a backtracking engine can take minutes. All x.uma implementations are protected.</p>
<h2 id="config-loading-performance"><a class="header" href="#config-loading-performance">Config Loading Performance</a></h2>
<p>Config loading (JSON → Registry → Matcher) compared to manual construction:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Implementation</th><th>Config Load</th><th>Manual Build</th><th>Ratio</th></tr>
</thead>
<tbody>
<tr><td>rumi</td><td>4.2µs</td><td>150ns</td><td>28x</td></tr>
<tr><td>xuma (Python)</td><td>12µs</td><td>3µs</td><td>4x</td></tr>
<tr><td>xuma (TypeScript)</td><td>8µs</td><td>600ns</td><td>13x</td></tr>
</tbody>
</table>
</div>
<p><strong>Config loading is a one-time cost.</strong> The ratio matters less than it appears — you load config once at startup, then evaluate thousands of times. The 28x overhead in Rust is JSON parsing + type registry resolution. Once built, evaluation performance is identical.</p>
<h2 id="what-these-numbers-mean"><a class="header" href="#what-these-numbers-mean">What These Numbers Mean</a></h2>
<p><strong>For evaluation-heavy workloads</strong> (hot path, called per-request): Choose rumi or crusty variants. The Rust engine’s evaluation is consistent and predictable.</p>
<p><strong>For config-heavy workloads</strong> (cold path, loaded at startup): All implementations are fast enough. Loading a config in 12µs is negligible compared to application startup.</p>
<p><strong>For regex-heavy workloads</strong>: Choose rumi. The DFA-based <code>regex</code> crate is the fastest RE2-class engine available.</p>
<p><strong>For simple matching without regex</strong>: bumi (TypeScript) is competitive with or faster than Rust for JIT-friendly patterns. Python is adequate for request-per-second workloads.</p>
<h2 id="benchmark-methodology"><a class="header" href="#benchmark-methodology">Benchmark Methodology</a></h2>
<ul>
<li><strong>Rust</strong>: <code>criterion</code> microbenchmarks, 100 iterations minimum, outlier detection</li>
<li><strong>Python</strong>: <code>pytest-benchmark</code> with warmup, statistical analysis</li>
<li><strong>TypeScript</strong>: <code>mitata</code> benchmarks, JIT warmup included</li>
<li><strong>All</strong>: Same test scenarios, same match patterns, same context data</li>
</ul>
<p>Benchmarks run in <code>rumi/benches/</code>, <code>puma/tests/bench/</code>, and <code>bumi/tests/bench/</code>.</p>
<h2 id="next-11"><a class="header" href="#next-11">Next</a></h2>
<ul>
<li><a href="#security-model">Security Model</a> — the safety guarantees behind these numbers</li>
<li><a href="#when-to-use-xuma">When to Use x.uma</a> — choosing the right implementation</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="security-model"><a class="header" href="#security-model">Security Model</a></h1>
<p>x.uma’s security model prevents four classes of attack against matcher engines. Every guarantee is enforced at construction time, not evaluation time.</p>
<h2 id="threat-model"><a class="header" href="#threat-model">Threat Model</a></h2>
<p>Matcher configs can come from untrusted sources — user-provided routing rules, dynamically loaded policy files, configs from external systems. The engine must be safe even when the config is adversarial.</p>
<h2 id="redos-protection"><a class="header" href="#redos-protection">ReDoS Protection</a></h2>
<p><strong>Threat:</strong> Regular expression Denial of Service. A crafted regex pattern causes exponential backtracking, consuming CPU indefinitely.</p>
<p><strong>Mitigation:</strong> All implementations use RE2-class linear-time regex engines:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Implementation</th><th>Regex Engine</th><th>Guarantee</th></tr>
</thead>
<tbody>
<tr><td>rumi (Rust)</td><td><code>regex</code> crate (DFA)</td><td>Linear time, proven</td></tr>
<tr><td>xuma (Python)</td><td><code>google-re2</code> (C++ RE2 binding)</td><td>Linear time, Google RE2</td></tr>
<tr><td>xuma (TypeScript)</td><td><code>re2js</code> (pure JS RE2 port)</td><td>Linear time, RE2 semantics</td></tr>
<tr><td>puma-crusty</td><td>Rust <code>regex</code> via PyO3</td><td>Same as rumi</td></tr>
<tr><td>bumi-crusty</td><td>Rust <code>regex</code> via WASM</td><td>Same as rumi</td></tr>
</tbody>
</table>
</div>
<p>No implementation uses a backtracking regex engine. Patterns that would cause catastrophic backtracking in PCRE/Python <code>re</code>/JavaScript <code>RegExp</code> are either rejected or matched in linear time.</p>
<p><strong>Pattern length limit:</strong> Regex patterns are capped at 4,096 characters (<code>MAX_REGEX_PATTERN_LENGTH</code>). Non-regex patterns are capped at 8,192 characters (<code>MAX_PATTERN_LENGTH</code>).</p>
<h2 id="depth-limit"><a class="header" href="#depth-limit">Depth Limit</a></h2>
<p><strong>Threat:</strong> Stack overflow from deeply nested matchers. A config with 1,000 levels of nested matchers could exhaust the call stack during evaluation.</p>
<p><strong>Mitigation:</strong> Maximum nesting depth of 32 levels (<code>MAX_DEPTH</code>), validated at construction time. If a config exceeds this limit, <code>MatcherError::DepthExceeded</code> is returned and no matcher is constructed.</p>
<p>32 levels is generous — real-world matchers rarely exceed 5 levels. The limit catches misconfigured or adversarial configs.</p>
<h2 id="width-limits"><a class="header" href="#width-limits">Width Limits</a></h2>
<p><strong>Threat:</strong> Resource exhaustion from extremely wide matchers. A config with millions of field matchers at depth 1 bypasses depth limits but still causes excessive memory and CPU usage.</p>
<p><strong>Mitigation:</strong> Three width limits, all validated at construction time:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Limit</th><th>Value</th><th>Protects</th></tr>
</thead>
<tbody>
<tr><td><code>MAX_FIELD_MATCHERS</code></td><td>256 per <code>Matcher</code></td><td>Memory from wide matcher lists</td></tr>
<tr><td><code>MAX_PREDICATES_PER_COMPOUND</code></td><td>256 per AND/OR</td><td>CPU from wide predicate trees</td></tr>
<tr><td><code>MAX_PATTERN_LENGTH</code></td><td>8,192 chars</td><td>Memory from large string patterns</td></tr>
</tbody>
</table>
</div>
<h2 id="none-to-false"><a class="header" href="#none-to-false">None-to-False</a></h2>
<p><strong>Threat:</strong> Missing data accidentally matching a rule. If a header doesn’t exist, it should not match <code>ExactMatcher("secret")</code>.</p>
<p><strong>Mitigation:</strong> When <code>DataInput.get()</code> returns <code>None</code>/<code>null</code>, the predicate evaluates to <code>false</code>. The <code>InputMatcher</code> is never called. This is enforced in all five implementations.</p>
<p>This is a security invariant, not a convenience feature. It ensures fail-closed behavior: missing data means no match.</p>
<h2 id="immutability"><a class="header" href="#immutability">Immutability</a></h2>
<p><strong>Threat:</strong> Race conditions from concurrent access. Matchers shared across threads could produce inconsistent results if modified during evaluation.</p>
<p><strong>Mitigation:</strong></p>
<ul>
<li><strong>Rust:</strong> All core types are <code>Send + Sync</code>. Matchers are immutable after construction and safe to share via <code>Arc&lt;Matcher&gt;</code>.</li>
<li><strong>Python:</strong> All types use <code>@dataclass(frozen=True)</code>. Fields cannot be reassigned after construction.</li>
<li><strong>TypeScript:</strong> All types use <code>readonly</code> fields.</li>
<li><strong>Registry:</strong> Immutable after <code>.build()</code>. The builder produces the registry, then the builder is consumed. No runtime registration.</li>
</ul>
<h2 id="construction-time-validation"><a class="header" href="#construction-time-validation">Construction-Time Validation</a></h2>
<p>All validation happens when the matcher is built, not when it’s evaluated. If a <code>Matcher</code> object exists, it’s guaranteed to be:</p>
<ul>
<li>Within depth limits</li>
<li>Within width limits</li>
<li>Free of invalid regex patterns</li>
<li>Free of unknown type URLs (config path)</li>
<li>Structurally sound (OnMatch exclusivity enforced by the type system)</li>
</ul>
<p>This follows the “parse, don’t validate” principle. The construction boundary is the trust boundary.</p>
<h2 id="error-messages"><a class="header" href="#error-messages">Error Messages</a></h2>
<p><code>MatcherError</code> variants include actionable context:</p>
<ul>
<li><code>UnknownTypeUrl</code> lists all registered type URLs</li>
<li><code>DepthExceeded</code> shows actual vs maximum depth</li>
<li><code>PatternTooLong</code> shows actual vs maximum length</li>
<li><code>InvalidPattern</code> includes the regex compilation error</li>
</ul>
<p>Self-correcting error messages help operators fix configs without guessing.</p>
<h2 id="what-is-not-protected"><a class="header" href="#what-is-not-protected">What Is NOT Protected</a></h2>
<ul>
<li><strong>Semantic correctness:</strong> x.uma doesn’t verify that your rules do what you intend. First-match-wins means rule order matters — a too-broad rule early in the list can shadow specific rules.</li>
<li><strong>Action interpretation:</strong> The engine returns actions without interpreting them. Whether <code>"allow"</code> means permit is your responsibility.</li>
<li><strong>Context injection:</strong> x.uma trusts the context you provide. If your <code>DataInput</code> produces unsafe values from user input, the engine cannot protect you.</li>
<li><strong>Side effects:</strong> Evaluation is pure (no I/O, no state mutation). But the code that acts on the result is outside x.uma’s scope.</li>
</ul>
<h2 id="next-12"><a class="header" href="#next-12">Next</a></h2>
<ul>
<li><a href="#benchmarks">Benchmarks</a> — concrete performance numbers</li>
<li><a href="#xds-semantics">xDS Semantics</a> — the protocol behind the guarantees</li>
<li><a href="#architecture">Architecture</a> — how safety is built into the design</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace-2a3cd908.js"></script>
        <script src="mode-rust-2c9d5c9a.js"></script>
        <script src="editor-16ca416c.js"></script>
        <script src="theme-dawn-4493f9c8.js"></script>
        <script src="theme-tomorrow_night-9dbe62a9.js"></script>

        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
