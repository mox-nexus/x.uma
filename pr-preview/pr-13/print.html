<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>x.uma</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Cross-Platform Unified Matcher API">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "rust";
            const default_dark_theme = "coal";
            window.path_to_searchindex_js = "searchindex-8e763299.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-eb7188b1.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>â†</kbd> or <kbd>â†’</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">x.uma</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/mox-labs/x.uma" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="xuma"><a class="header" href="#xuma">x.uma</a></h1>
<blockquote>
<p>Cross-Platform Unified Matcher API</p>
</blockquote>
<p><strong>Alpha status</strong> â€” API is under active development and will change.</p>
<p>x.uma implements the <a href="https://github.com/cncf/xds">xDS Unified Matcher API</a> across multiple languages. Match structured data (HTTP requests, events, messages) against rule trees with first-match-wins semantics.</p>
<h2 id="implementations"><a class="header" href="#implementations">Implementations</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Package</th><th>Language</th><th>Status</th></tr>
</thead>
<tbody>
<tr><td><strong>rumi</strong></td><td>Rust</td><td>Production-ready core (195 tests)</td></tr>
<tr><td><strong>puma</strong></td><td>Python 3.12+</td><td>Alpha v0.1.0 (194 tests)</td></tr>
<tr><td><strong>bumi</strong></td><td>TypeScript/Bun</td><td>Alpha v0.1.0 (202 tests)</td></tr>
<tr><td><strong>puma-crusty</strong></td><td>Python (PyO3 bindings)</td><td>Alpha (37 tests)</td></tr>
<tr><td><strong>bumi-crusty</strong></td><td>TypeScript (wasm-bindgen)</td><td>Alpha (36 tests)</td></tr>
</tbody>
</table>
</div>
<p>All implementations pass the same conformance test suite. <strong>Total: 268 tests</strong> across 5 variants.</p>
<h2 id="quick-example"><a class="header" href="#quick-example">Quick Example</a></h2>
<p>The same pattern in Rust, Python, and TypeScript.</p>
<h3 id="rust"><a class="header" href="#rust">Rust</a></h3>
<pre><code class="language-rust ignore">use rumi::prelude::*;
use rumi_http::{HttpMessage, PathInput, PrefixMatcher};

let matcher = Matcher::new(
    vec![
        FieldMatcher::new(
            Predicate::Single(SinglePredicate::new(
                Box::new(PathInput),
                Box::new(PrefixMatcher::new("/api")),
            )),
            OnMatch::Action("api_handler"),
        ),
    ],
    Some(OnMatch::Action("default")),
);

// ProcessingRequest -&gt; HttpMessage -&gt; evaluate
let action = matcher.evaluate(&amp;http_message);</code></pre>
<h3 id="python"><a class="header" href="#python">Python</a></h3>
<pre><code class="language-python">from puma import Matcher, FieldMatcher, SinglePredicate, Action
from puma import PrefixMatcher
from puma.http import HttpRequest, PathInput

matcher = Matcher(
    matcher_list=(
        FieldMatcher(
            predicate=SinglePredicate(
                input=PathInput(),
                matcher=PrefixMatcher("/api")
            ),
            on_match=Action("api_handler")
        ),
    ),
    on_no_match=Action("default")
)

request = HttpRequest(method="GET", raw_path="/api/users")
action = matcher.evaluate(request)  # "api_handler"
</code></pre>
<h3 id="typescript"><a class="header" href="#typescript">TypeScript</a></h3>
<pre><code class="language-typescript">import { Matcher, FieldMatcher, SinglePredicate, Action } from "bumi";
import { PrefixMatcher } from "bumi";
import { HttpRequest, PathInput } from "bumi/http";

const matcher = new Matcher([
    new FieldMatcher(
        new SinglePredicate(
            new PathInput(),
            new PrefixMatcher("/api")
        ),
        new Action("api_handler")
    ),
], new Action("default"));

const request = new HttpRequest("GET", "/api/users");
const action = matcher.evaluate(request); // "api_handler"
</code></pre>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<p>x.uma follows hexagonal architecture (ports and adapters). The core is domain-agnostic. Domains plug in at the edges.</p>
<pre><code class="language-text">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       Domain Adapters           â”‚
â”‚   HTTP  CloudEvent  Custom      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           PORTS                 â”‚
â”‚  DataInput[Ctx] â†’ MatchingValue â”‚
â”‚  InputMatcher â†’ bool            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           CORE                  â”‚
â”‚  Matcher, Predicate, Actions    â”‚
â”‚    (domain-agnostic)            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<p><strong>DataInput</strong> extracts values from your context (HTTP request, event, custom type).</p>
<p><strong>InputMatcher</strong> matches the extracted value (exact, prefix, regex, etc).</p>
<p><strong>Matcher</strong> composes predicates with first-match-wins semantics.</p>
<p>The same <code>ExactMatcher</code> works for HTTP headers, event types, or your custom domain. This is the key design insight from Envoyâ€™s matcher architecture.</p>
<h2 id="why-xuma"><a class="header" href="#why-xuma">Why x.uma?</a></h2>
<p><strong>Domain-agnostic core.</strong> The same matcher logic works for HTTP routing, event filtering, access control, or your custom domain. Add a new domain by implementing <code>DataInput</code> for your context type.</p>
<p><strong>Type-safe composition.</strong> Predicates compose with AND/OR/NOT. Matchers nest. Actions are exclusive (action XOR nested matcher, never both).</p>
<p><strong>Battle-tested semantics.</strong> Built on the same xDS protocol Envoy uses at Google scale. First-match-wins, nested matcher failure propagation, depth limits â€” all enforced by design.</p>
<p><strong>Multi-language.</strong> Same API across Rust, Python, and TypeScript. Write matchers once, run anywhere.</p>
<p><strong>Performance.</strong> Sub-microsecond evaluation. Linear-time regex (Rust implementations). Zero-copy where possible.</p>
<p><strong>Security.</strong> ReDoS protection via linear-time regex. Depth limits (max 32 levels). Fail-closed validation.</p>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Section</th><th>What youâ€™ll learn</th></tr>
</thead>
<tbody>
<tr><td><strong>Getting Started</strong></td><td></td></tr>
<tr><td><a href="#choose-your-implementation">Choose Your Implementation</a></td><td>Which variant fits your use case</td></tr>
<tr><td><a href="#rust-quick-start">Rust Quick Start</a></td><td>Get rumi running in 5 minutes</td></tr>
<tr><td><a href="#python-quick-start">Python Quick Start</a></td><td>Get puma running in 5 minutes</td></tr>
<tr><td><a href="#typescript-quick-start">TypeScript Quick Start</a></td><td>Get bumi running in 5 minutes</td></tr>
<tr><td><strong>Tutorials</strong></td><td></td></tr>
<tr><td><a href="#build-an-http-router">Build an HTTP Router</a></td><td>Step-by-step routing example</td></tr>
<tr><td><strong>Core Concepts</strong></td><td></td></tr>
<tr><td><a href="#the-matching-pipeline">The Matching Pipeline</a></td><td>How evaluation works</td></tr>
<tr><td><a href="#type-erasure-and-ports">Type Erasure and Ports</a></td><td>Why DataInput/InputMatcher split exists</td></tr>
<tr><td><a href="#predicate-composition">Predicate Composition</a></td><td>AND/OR/NOT logic trees</td></tr>
<tr><td><a href="#first-match-wins-semantics">First-Match-Wins Semantics</a></td><td>Evaluation order and fallback</td></tr>
<tr><td><strong>Performance &amp; Security</strong></td><td></td></tr>
<tr><td><a href="#performance-guide">Performance Guide</a></td><td>Optimization techniques</td></tr>
<tr><td><a href="#benchmark-results">Benchmark Results</a></td><td>Cross-language numbers</td></tr>
<tr><td><a href="#security-model">Security Model</a></td><td>Threat model and mitigations</td></tr>
<tr><td><a href="#redos-protection-1">ReDoS Protection</a></td><td>Linear-time regex guarantees</td></tr>
<tr><td><strong>Understanding x.uma</strong></td><td></td></tr>
<tr><td><a href="#architecture-1">Architecture</a></td><td>Why itâ€™s built this way</td></tr>
<tr><td><a href="#why-aces">Why ACES</a></td><td>Design philosophy deep dive</td></tr>
<tr><td><a href="#when-to-use-xuma">When to Use x.uma</a></td><td>x.uma vs OPA vs Cedar vs Zanzibar</td></tr>
<tr><td><a href="#policy-landscape">Policy Landscape</a></td><td>Where x.uma fits in the ecosystem</td></tr>
<tr><td><strong>Reference</strong></td><td></td></tr>
<tr><td><a href="#proto-api-reference">Proto API</a></td><td>xDS protocol definitions</td></tr>
<tr><td><a href="#rust-api-reference">Rust API</a></td><td>rumi API reference</td></tr>
<tr><td><a href="#python-api-reference">Python API</a></td><td>puma API reference</td></tr>
<tr><td><a href="#typescript-api-reference">TypeScript API</a></td><td>bumi API reference</td></tr>
<tr><td><a href="#http-domain-reference">HTTP Domain</a></td><td>HTTP matching across languages</td></tr>
</tbody>
</table>
</div>
<h2 id="status"><a class="header" href="#status">Status</a></h2>
<p>x.uma is alpha software. The API is under active development and will change.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Phase</th><th>Focus</th><th>Status</th></tr>
</thead>
<tbody>
<tr><td>5</td><td>puma (Python)</td><td>âœ… Done (v0.1.0)</td></tr>
<tr><td>6</td><td>bumi (TypeScript)</td><td>âœ… Done (v0.1.0)</td></tr>
<tr><td>7</td><td>puma-crusty (PyO3 bindings)</td><td>âœ… Done</td></tr>
<tr><td>8</td><td>bumi-crusty (WASM bindings)</td><td>âœ… Done</td></tr>
<tr><td>9</td><td>Cross-language benchmarks</td><td>ğŸš§ In Progress</td></tr>
<tr><td>10</td><td>Semantic matching (cosine similarity)</td><td>Planned</td></tr>
<tr><td>11</td><td>RE2 migration (linear-time regex natively)</td><td>Planned</td></tr>
</tbody>
</table>
</div>
<p>See <a href="#roadmap">Roadmap</a> for details.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="choose-your-implementation"><a class="header" href="#choose-your-implementation">Choose Your Implementation</a></h1>
<p>You have five choices. Which one do you need?</p>
<p>x.uma runs in Rust, Python, and TypeScript. Each has a <strong>pure implementation</strong> (native to that language) and a <strong>crusty implementation</strong> (Rust core accessed via FFI). The pure variants are faster for typical workloads. The crusty variants protect against ReDoS attacks when matching untrusted regex patterns.</p>
<h2 id="quick-decision-tree"><a class="header" href="#quick-decision-tree">Quick Decision Tree</a></h2>
<p>Start here:</p>
<pre><code>What language are you using?
â”œâ”€ Rust â†’ rumi (always)
â”œâ”€ Python â†’ Do you match untrusted regex input?
â”‚   â”œâ”€ Yes â†’ puma-crusty (ReDoS protection)
â”‚   â””â”€ No â†’ puma (1.5x faster than crusty)
â””â”€ TypeScript â†’ Do you match untrusted regex input?
    â”œâ”€ Yes â†’ bumi-crusty (ReDoS protection, accepts 100x slowdown)
    â””â”€ No â†’ bumi (100x faster than crusty)
</code></pre>
<h2 id="the-five-variants"><a class="header" href="#the-five-variants">The Five Variants</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Variant</th><th>Language</th><th>Regex Engine</th><th>ReDoS Safe?</th><th>FFI Overhead</th></tr>
</thead>
<tbody>
<tr><td><strong>rumi</strong></td><td>Rust</td><td><code>regex</code> crate (linear)</td><td>Yes</td><td>None</td></tr>
<tr><td><strong>puma</strong></td><td>Python</td><td><code>re</code> module (backtracking)</td><td>No</td><td>None</td></tr>
<tr><td><strong>bumi</strong></td><td>TypeScript/Bun</td><td><code>RegExp</code> (backtracking)</td><td>No</td><td>None</td></tr>
<tr><td><strong>puma-crusty</strong></td><td>Python â†’ Rust</td><td><code>regex</code> crate via PyO3</td><td>Yes</td><td>Minimal (1.3-1.6x)</td></tr>
<tr><td><strong>bumi-crusty</strong></td><td>TypeScript â†’ Rust</td><td><code>regex</code> crate via WASM</td><td>Yes</td><td>Heavy (30-450x)</td></tr>
</tbody>
</table>
</div>
<p>All five pass the same 194-test conformance suite. They implement identical behavior with different performance characteristics.</p>
<h2 id="performance-spectrum"><a class="header" href="#performance-spectrum">Performance Spectrum</a></h2>
<p>At 200 routing rules (worst case: last rule matches):</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Variant</th><th>Latency</th><th>Throughput/core</th></tr>
</thead>
<tbody>
<tr><td>bumi</td><td>2.1 Âµs</td><td>475k req/sec</td></tr>
<tr><td>rumi</td><td>3.5 Âµs</td><td>285k req/sec</td></tr>
<tr><td>puma</td><td>20 Âµs</td><td>50k req/sec</td></tr>
<tr><td>puma-crusty</td><td>13 Âµs</td><td>77k req/sec</td></tr>
<tr><td>bumi-crusty</td><td>240 Âµs</td><td>4k req/sec</td></tr>
</tbody>
</table>
</div>
<p>These numbers tell half the story. The other half is ReDoS.</p>
<h2 id="the-redos-problem"><a class="header" href="#the-redos-problem">The ReDoS Problem</a></h2>
<p>Regular Expression Denial of Service exploits backtracking regex engines. An attacker sends input designed to trigger exponential backtracking. At N=20 characters, the pathological pattern <code>(a+)+$</code> causes:</p>
<ul>
<li><strong>rumi</strong>: 11 nanoseconds (linear-time Thompson NFA)</li>
<li><strong>bumi</strong>: 11 milliseconds (backtracking engine)</li>
<li><strong>puma</strong>: 72 milliseconds (backtracking engine)</li>
</ul>
<p>At N=25, both puma and bumi hang indefinitely. One malicious request ties up a worker thread forever.</p>
<p>Rustâ€™s <code>regex</code> crate (based on RE2 semantics) guarantees linear time. No backtracking, no exponential blowup, no vulnerability. The crusty variants give you this protection in Python and TypeScript.</p>
<h2 id="when-to-use-each"><a class="header" href="#when-to-use-each">When to Use Each</a></h2>
<h3 id="rumi-rust"><a class="header" href="#rumi-rust">rumi (Rust)</a></h3>
<p><strong>Use when:</strong></p>
<ul>
<li>Building a proxy, load balancer, or high-throughput router</li>
<li>Maximum throughput per core matters</li>
<li>Matching untrusted regex patterns (ReDoS mandatory)</li>
<li>Already writing Rust</li>
</ul>
<p><strong>Donâ€™t use when:</strong></p>
<ul>
<li>Your team doesnâ€™t know Rust</li>
<li>Python or TypeScript would integrate better with existing stack</li>
</ul>
<p><strong>Install:</strong></p>
<pre><code class="language-toml">[dependencies]
rumi = "0.1"
rumi-http = "0.1"
</code></pre>
<h3 id="puma-python"><a class="header" href="#puma-python">puma (Python)</a></h3>
<p><strong>Use when:</strong></p>
<ul>
<li>Integrating with Python web frameworks (FastAPI, Flask, Django)</li>
<li>Developer ergonomics matter more than raw speed</li>
<li>You control all regex patterns (no untrusted input)</li>
<li>50k requests per second per core is fast enough</li>
</ul>
<p><strong>Donâ€™t use when:</strong></p>
<ul>
<li>Users can supply regex patterns</li>
<li>You need to route more than 50k req/sec on a single core</li>
</ul>
<p><strong>Install:</strong></p>
<pre><code class="language-bash">uv add puma
</code></pre>
<h3 id="bumi-typescriptbun"><a class="header" href="#bumi-typescriptbun">bumi (TypeScript/Bun)</a></h3>
<p><strong>Use when:</strong></p>
<ul>
<li>Building frontend routing or edge workers (Cloudflare Workers, Deno Deploy)</li>
<li>Sub-microsecond latency matters for simple matches</li>
<li>You control all regex patterns (no untrusted input)</li>
<li>TypeScript ecosystem integration is valuable</li>
</ul>
<p><strong>Donâ€™t use when:</strong></p>
<ul>
<li>Users can supply regex patterns</li>
<li>Running on Node.js (bumi requires Bun runtime)</li>
</ul>
<p><strong>Install:</strong></p>
<pre><code class="language-bash">bun add @x.uma/bumi
</code></pre>
<h3 id="puma-crusty-python--rust-ffi"><a class="header" href="#puma-crusty-python--rust-ffi">puma-crusty (Python + Rust FFI)</a></h3>
<p><strong>Use when:</strong></p>
<ul>
<li>Need ReDoS protection in an existing Python codebase</li>
<li>Regex-heavy workloads where 1.5x speedup matters</li>
<li>Willing to add a native extension dependency</li>
<li>Python wheels for your platform exist</li>
</ul>
<p><strong>Donâ€™t use when:</strong></p>
<ul>
<li>Deployment platform doesnâ€™t support native extensions</li>
<li>Pure Python is fast enough and you control regex patterns</li>
</ul>
<p><strong>Install:</strong></p>
<pre><code class="language-bash">uv add puma-crusty
</code></pre>
<h3 id="bumi-crusty-typescript--wasm-ffi"><a class="header" href="#bumi-crusty-typescript--wasm-ffi">bumi-crusty (TypeScript + WASM FFI)</a></h3>
<p><strong>Use when:</strong></p>
<ul>
<li>MUST have linear-time regex in TypeScript (threat model requires it)</li>
<li>Matching untrusted regex input at the edge</li>
<li>The 100x slowdown is acceptable (low request rate, high security requirement)</li>
</ul>
<p><strong>Donâ€™t use when:</strong></p>
<ul>
<li>You control the regex patterns (use pure bumi instead)</li>
<li>Performance matters (pure bumi is faster in every scenario)</li>
</ul>
<p><strong>Install:</strong></p>
<pre><code class="language-bash">bun add @x.uma/bumi-crusty
</code></pre>
<p>The WASM boundary serialization overhead dominates at 2-3 microseconds per call. This variant exists for threat scenarios, not performance optimization.</p>
<h2 id="mixing-variants"><a class="header" href="#mixing-variants">Mixing Variants</a></h2>
<p>You can use different variants in different parts of your system:</p>
<ul>
<li><strong>Edge router</strong> (untrusted traffic): rumi or puma-crusty</li>
<li><strong>Internal service mesh</strong> (trusted traffic): puma or bumi</li>
<li><strong>Config validation</strong> (build time): any variant, performance doesnâ€™t matter</li>
</ul>
<p>The conformance test suite guarantees identical behavior. A matcher compiled with puma will make the same decisions as the same matcher in rumi.</p>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Choose your language:</p>
<ul>
<li><a href="#rust-quick-start">Rust Quick Start</a></li>
<li><a href="#python-quick-start">Python Quick Start</a></li>
<li><a href="#typescript-quick-start">TypeScript Quick Start</a></li>
</ul>
<p>Or dive deeper:</p>
<ul>
<li><a href="#benchmark-results">Benchmark Results</a> â€” full performance analysis</li>
<li><a href="#redos-protection-1">ReDoS Protection</a> â€” threat model and mitigations</li>
<li><a href="#architecture-1">Architecture</a> â€” how x.uma works under the hood</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rust-quick-start"><a class="header" href="#rust-quick-start">Rust Quick Start</a></h1>
<p>Build an HTTP route matcher in 10 lines.</p>
<p>x.umaâ€™s Rust implementation (<code>rumi</code>) translates Gateway API route configuration into efficient runtime matchers. Routes defined at config time become compiled trees evaluated at request time.</p>
<h2 id="install"><a class="header" href="#install">Install</a></h2>
<p>Add <code>rumi-http</code> to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
rumi = "0.1"
rumi-http = "0.1"
</code></pre>
<p>The HTTP extension (<code>rumi-http</code>) brings in the core (<code>rumi</code>) as a transitive dependency.</p>
<h2 id="your-first-matcher"><a class="header" href="#your-first-matcher">Your First Matcher</a></h2>
<p>Match GET requests to <code>/api/*</code> and POST requests to <code>/admin/*</code>:</p>
<pre class="playground"><code class="language-rust">use rumi_http::prelude::*;

fn main() {
    // Define routes using Gateway API syntax
    let routes = vec![
        HttpRouteMatch {
            path: Some(HttpPathMatch::PathPrefix { value: "/api".into() }),
            method: Some(HttpMethod::Get),
            ..Default::default()
        },
        HttpRouteMatch {
            path: Some(HttpPathMatch::PathPrefix { value: "/admin".into() }),
            method: Some(HttpMethod::Post),
            ..Default::default()
        },
    ];

    // Compile routes into a matcher
    let matcher = compile_route_matches(
        &amp;routes,
        "allowed",      // action when any route matches
        Some("denied"), // action when no routes match
    );

    // Evaluate against requests
    let request = HttpRequest::builder()
        .method("GET")
        .path("/api/users")
        .build();

    let result = matcher.evaluate(&amp;request);
    assert_eq!(result, Some(&amp;"allowed"));

    let request = HttpRequest::builder()
        .method("DELETE")
        .path("/api/users")
        .build();

    let result = matcher.evaluate(&amp;request);
    assert_eq!(result, Some(&amp;"denied")); // DELETE not in routes
}</code></pre>
<p>The <code>compile_route_matches</code> function is the high-level API. It takes a list of <code>HttpRouteMatch</code> configs and produces a <code>Matcher&lt;HttpRequest, A&gt;</code> that runs in microseconds.</p>
<h2 id="how-compilation-works"><a class="header" href="#how-compilation-works">How Compilation Works</a></h2>
<p>Gateway API route configuration is declarative. You specify what to match, not how to evaluate it:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let route = HttpRouteMatch {
    path: Some(HttpPathMatch::PathPrefix { value: "/api".into() }),
    method: Some(HttpMethod::Get),
    headers: Some(vec![
        HttpHeaderMatch::Exact {
            name: "content-type".into(),
            value: "application/json".into(),
        },
    ]),
    ..Default::default()
};
<span class="boring">}</span></code></pre>
<p>All conditions within a single <code>HttpRouteMatch</code> are ANDed together. When you pass multiple <code>HttpRouteMatch</code> entries to <code>compile_route_matches</code>, they are ORed.</p>
<p>The compiler produces a tree of predicates:</p>
<pre><code>Matcher
â””â”€â”€ FieldMatcher
    â””â”€â”€ Predicate::Or
        â”œâ”€â”€ And(path=/api, method=GET, header=content-type)
        â””â”€â”€ And(path=/admin, method=POST)
</code></pre>
<p>At evaluation time, the tree walks first-match-wins until a predicate succeeds.</p>
<h2 id="under-the-hood-manual-construction"><a class="header" href="#under-the-hood-manual-construction">Under the Hood: Manual Construction</a></h2>
<p>The Gateway API compiler is syntactic sugar. Hereâ€™s what it generates:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rumi_http::prelude::*;

// Manual construction of the same matcher
let matcher = Matcher::new(
    vec![
        FieldMatcher::new(
            Predicate::And(vec![
                Predicate::Single(SinglePredicate::new(
                    Box::new(SimplePathInput),
                    Box::new(PrefixMatcher::new("/api")),
                )),
                Predicate::Single(SinglePredicate::new(
                    Box::new(SimpleMethodInput),
                    Box::new(ExactMatcher::new("GET")),
                )),
            ]),
            OnMatch::Action("allowed"),
        ),
        FieldMatcher::new(
            Predicate::Single(SinglePredicate::new(
                Box::new(SimplePathInput),
                Box::new(PrefixMatcher::new("/admin")),
            )),
            OnMatch::Action("allowed"),
        ),
    ],
    Some(OnMatch::Action("denied")),
);
<span class="boring">}</span></code></pre>
<p>This is verbose but explicit. You control the exact tree structure.</p>
<p><strong>When to use manual construction:</strong></p>
<ul>
<li>Building matchers programmatically from non-Gateway-API configs</li>
<li>Implementing custom <code>DataInput</code> or <code>InputMatcher</code> types</li>
<li>Debugging compilation behavior</li>
</ul>
<p><strong>When to use the compiler:</strong></p>
<ul>
<li>Standard HTTP routing (99% of use cases)</li>
<li>Gateway API configurations from Kubernetes</li>
<li>Less code, same performance</li>
</ul>
<h2 id="matching-against-real-requests"><a class="header" href="#matching-against-real-requests">Matching Against Real Requests</a></h2>
<p>The examples above use <code>HttpRequest</code>, a lightweight test context. Production systems process gRPC <code>ProcessingRequest</code> messages from Envoyâ€™s external processor protocol.</p>
<p>Convert <code>ProcessingRequest</code> to <code>HttpMessage</code> for O(1) lookups:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rumi_http::prelude::*;

// Production: indexed context from ext_proc
let processing_req: ProcessingRequest = /* from Envoy */;
let message = HttpMessage::from(&amp;processing_req);

let result = matcher.evaluate(&amp;message);
<span class="boring">}</span></code></pre>
<p><code>HttpMessage</code> pre-indexes headers, query parameters, and pseudo-headers at construction time. Every <code>DataInput::get()</code> call becomes a <code>HashMap</code> lookup instead of a linear scan.</p>
<p>For more on the ext_proc integration, see <a href="#build-an-http-router">Build an HTTP Router</a>.</p>
<h2 id="actions-beyond-strings"><a class="header" href="#actions-beyond-strings">Actions: Beyond Strings</a></h2>
<p>The examples use <code>&amp;str</code> actions for simplicity. In production, actions are often enums or structs:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, PartialEq)]
enum RouteAction {
    Forward { backend: String, weight: u32 },
    Redirect { location: String, status: u16 },
    Deny { reason: String },
}

let matcher = compile_route_matches(
    &amp;routes,
    RouteAction::Forward {
        backend: "api-service".into(),
        weight: 100,
    },
    Some(RouteAction::Deny {
        reason: "no route matched".into(),
    }),
);
<span class="boring">}</span></code></pre>
<p>The action type must be <code>Clone + Send + Sync + 'static</code>. Beyond that, use whatever makes sense for your domain.</p>
<h2 id="validation-and-safety"><a class="header" href="#validation-and-safety">Validation and Safety</a></h2>
<p>Matchers enforce safety constraints:</p>
<ul>
<li><strong>Depth limit</strong>: Nested matchers cannot exceed 32 levels (prevents stack overflow)</li>
<li><strong>ReDoS protection</strong>: <code>regex</code> crate guarantees linear-time matching (no exponential backtracking)</li>
<li><strong>Type safety</strong>: Invalid matcher trees fail at compile time, not runtime</li>
</ul>
<p>Call <code>matcher.validate()</code> to check depth limits:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match matcher.validate() {
    Ok(()) =&gt; println!("Matcher is valid"),
    Err(MatcherError::DepthExceeded { max, actual }) =&gt; {
        eprintln!("Matcher too deep: {} &gt; {}", actual, max);
    }
}
<span class="boring">}</span></code></pre>
<p>The Gateway API compiler produces valid trees. Manual construction can violate depth limits if you nest <code>OnMatch::Matcher</code> recursively.</p>
<h2 id="performance-notes"><a class="header" href="#performance-notes">Performance Notes</a></h2>
<p>At 200 routing rules, <code>rumi</code> evaluates worst-case (last rule matches) in 3.5 microseconds on Apple M1 Max. Thatâ€™s 285,000 requests per second per core.</p>
<p>The matcher is thread-safe (<code>Send + Sync</code>). Share one instance across threads:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Arc;

let matcher = Arc::new(compile_route_matches(&amp;routes, "allowed", None));

// Clone the Arc, not the matcher
let m = matcher.clone();
std::thread::spawn(move || {
    let result = m.evaluate(&amp;request);
});
<span class="boring">}</span></code></pre>
<p><code>Arc</code> adds one atomic reference count operation. The matcher itself has no internal mutability and requires no locking.</p>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<ul>
<li><a href="#build-an-http-router">Build an HTTP Router</a> â€” full ext_proc integration</li>
<li><a href="#predicate-composition">Predicate Composition</a> â€” AND/OR/NOT logic</li>
<li><a href="#benchmark-results">Benchmark Results</a> â€” performance deep dive</li>
<li><a href="#rust-api-reference">Rust API Reference</a> â€” complete type documentation</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="python-quick-start"><a class="header" href="#python-quick-start">Python Quick Start</a></h1>
<p>Build an HTTP route matcher in 10 lines.</p>
<p>x.umaâ€™s Python implementation (<code>puma</code>) translates Gateway API route configuration into efficient runtime matchers. Routes defined at config time become compiled trees evaluated at request time.</p>
<h2 id="install-1"><a class="header" href="#install-1">Install</a></h2>
<p>Add <code>puma</code> to your project:</p>
<pre><code class="language-bash">uv add puma
</code></pre>
<p>If youâ€™re not using <code>uv</code>, <code>pip</code> works too:</p>
<pre><code class="language-bash">pip install puma
</code></pre>
<p><strong>Requires Python 3.12+</strong> for PEP 695 type parameter syntax (<code>class Matcher[Ctx, A]</code>).</p>
<h2 id="your-first-matcher-1"><a class="header" href="#your-first-matcher-1">Your First Matcher</a></h2>
<p>Match GET requests to <code>/api/*</code> and POST requests to <code>/admin/*</code>:</p>
<pre><code class="language-python">from puma.http import (
    HttpRouteMatch,
    HttpPathMatch,
    HttpRequest,
    compile_route_matches,
)

# Define routes using Gateway API syntax
routes = [
    HttpRouteMatch(
        path=HttpPathMatch(type="PathPrefix", value="/api"),
        method="GET",
    ),
    HttpRouteMatch(
        path=HttpPathMatch(type="PathPrefix", value="/admin"),
        method="POST",
    ),
]

# Compile routes into a matcher
matcher = compile_route_matches(
    matches=routes,
    action="allowed",      # when any route matches
    on_no_match="denied",  # when no routes match
)

# Evaluate against requests
request = HttpRequest(method="GET", raw_path="/api/users")
result = matcher.evaluate(request)
assert result == "allowed"

request = HttpRequest(method="DELETE", raw_path="/api/users")
result = matcher.evaluate(request)
assert result == "denied"  # DELETE not in routes
</code></pre>
<p>The <code>compile_route_matches</code> function is the high-level API. It takes a list of <code>HttpRouteMatch</code> configs and produces a <code>Matcher[HttpRequest, A]</code> that runs in microseconds.</p>
<h2 id="how-compilation-works-1"><a class="header" href="#how-compilation-works-1">How Compilation Works</a></h2>
<p>Gateway API route configuration is declarative. You specify what to match, not how to evaluate it:</p>
<pre><code class="language-python">from puma.http import HttpRouteMatch, HttpPathMatch, HttpHeaderMatch

route = HttpRouteMatch(
    path=HttpPathMatch(type="PathPrefix", value="/api"),
    method="GET",
    headers=[
        HttpHeaderMatch(
            type="Exact",
            name="content-type",
            value="application/json",
        ),
    ],
)
</code></pre>
<p>All conditions within a single <code>HttpRouteMatch</code> are ANDed together. When you pass multiple <code>HttpRouteMatch</code> entries to <code>compile_route_matches</code>, they are ORed.</p>
<p>The compiler produces a tree of predicates:</p>
<pre><code>Matcher
â””â”€â”€ FieldMatcher
    â””â”€â”€ Or
        â”œâ”€â”€ And(path=/api, method=GET, header=content-type)
        â””â”€â”€ And(path=/admin, method=POST)
</code></pre>
<p>At evaluation time, the tree walks first-match-wins until a predicate succeeds.</p>
<h2 id="under-the-hood-manual-construction-1"><a class="header" href="#under-the-hood-manual-construction-1">Under the Hood: Manual Construction</a></h2>
<p>The Gateway API compiler is syntactic sugar. Hereâ€™s what it generates:</p>
<pre><code class="language-python">from puma import Matcher, FieldMatcher, Action, SinglePredicate, And
from puma import ExactMatcher, PrefixMatcher
from puma.http import HttpRequest, PathInput, MethodInput

# Manual construction of the same matcher
matcher = Matcher(
    matcher_list=(
        FieldMatcher(
            predicate=And(
                predicates=(
                    SinglePredicate(
                        input=PathInput(),
                        matcher=PrefixMatcher("/api"),
                    ),
                    SinglePredicate(
                        input=MethodInput(),
                        matcher=ExactMatcher("GET"),
                    ),
                )
            ),
            on_match=Action("allowed"),
        ),
        FieldMatcher(
            predicate=SinglePredicate(
                input=PathInput(),
                matcher=PrefixMatcher("/admin"),
            ),
            on_match=Action("allowed"),
        ),
    ),
    on_no_match=Action("denied"),
)
</code></pre>
<p>This is verbose but explicit. You control the exact tree structure.</p>
<p><strong>When to use manual construction:</strong></p>
<ul>
<li>Building matchers programmatically from non-Gateway-API configs</li>
<li>Implementing custom <code>DataInput</code> or <code>InputMatcher</code> protocols</li>
<li>Debugging compilation behavior</li>
</ul>
<p><strong>When to use the compiler:</strong></p>
<ul>
<li>Standard HTTP routing (99% of use cases)</li>
<li>Gateway API configurations from Kubernetes</li>
<li>Less code, same performance</li>
</ul>
<h2 id="the-httprequest-context"><a class="header" href="#the-httprequest-context">The HttpRequest Context</a></h2>
<p><code>HttpRequest</code> is a frozen dataclass with parsed query parameters and lowercased headers:</p>
<pre><code class="language-python">from puma.http import HttpRequest

# Query string parsed from raw_path
request = HttpRequest(
    method="GET",
    raw_path="/search?q=hello&amp;lang=en",
    headers={"Content-Type": "application/json"},
)

assert request.path == "/search"
assert request.query_param("q") == "hello"
assert request.query_param("lang") == "en"

# Headers are case-insensitive
assert request.header("content-type") == "application/json"
assert request.header("Content-Type") == "application/json"
</code></pre>
<p>The query string is parsed once at construction time (O(n) scan). Every <code>query_param()</code> lookup is O(1) dictionary access.</p>
<p>Headers are stored lowercased to avoid repeated string operations during matching.</p>
<h2 id="actions-beyond-strings-1"><a class="header" href="#actions-beyond-strings-1">Actions: Beyond Strings</a></h2>
<p>The examples use <code>str</code> actions for simplicity. In production, actions are often dataclasses or enums:</p>
<pre><code class="language-python">from dataclasses import dataclass
from enum import Enum

class RouteTarget(Enum):
    API_SERVICE = "api-service"
    ADMIN_SERVICE = "admin-service"

@dataclass(frozen=True)
class RouteAction:
    target: RouteTarget
    weight: int
    timeout_ms: int

matcher = compile_route_matches(
    matches=routes,
    action=RouteAction(
        target=RouteTarget.API_SERVICE,
        weight=100,
        timeout_ms=5000,
    ),
    on_no_match=None,  # return None when no match
)
</code></pre>
<p>The action type can be any Python object. puma returns it by reference when a match succeeds.</p>
<h2 id="validation-and-safety-1"><a class="header" href="#validation-and-safety-1">Validation and Safety</a></h2>
<p>Matchers enforce safety constraints:</p>
<ul>
<li><strong>Depth limit</strong>: Nested matchers cannot exceed 32 levels (prevents stack overflow)</li>
<li><strong>Immutability</strong>: All types are <code>frozen=True</code> dataclasses (no accidental mutation)</li>
<li><strong>Type safety</strong>: Type checkers like <code>mypy</code> catch mismatches at analysis time</li>
</ul>
<p>Check depth limits with <code>validate()</code>:</p>
<pre><code class="language-python">try:
    matcher.validate()
    print("Matcher is valid")
except ValueError as e:
    print(f"Validation failed: {e}")
</code></pre>
<p>The Gateway API compiler produces valid trees. Manual construction can violate depth limits if you nest <code>NestedMatcher</code> recursively.</p>
<h2 id="performance-notes-1"><a class="header" href="#performance-notes-1">Performance Notes</a></h2>
<p>At 200 routing rules, <code>puma</code> evaluates worst-case (last rule matches) in 20 microseconds on Apple M1 Max. Thatâ€™s 50,000 requests per second per core.</p>
<p>Pythonâ€™s GIL limits parallelism, but the matcher is thread-safe:</p>
<pre><code class="language-python">import threading

def worker(matcher, request):
    result = matcher.evaluate(request)
    print(f"Result: {result}")

threads = [
    threading.Thread(target=worker, args=(matcher, request))
    for _ in range(10)
]

for t in threads:
    t.start()
for t in threads:
    t.join()
</code></pre>
<p>Each thread acquires the GIL during <code>evaluate()</code>. If you need true parallelism, consider:</p>
<ul>
<li><strong>Multiple processes</strong> with <code>multiprocessing</code> (one matcher per process)</li>
<li><strong>puma-crusty</strong> (Rust core via PyO3, releases GIL during evaluation)</li>
</ul>
<p>For ReDoS protection with untrusted regex input, use <code>puma-crusty</code> instead of pure <code>puma</code>. See <a href="#redos-protection-1">ReDoS Protection</a>.</p>
<h2 id="integration-examples"><a class="header" href="#integration-examples">Integration Examples</a></h2>
<h3 id="fastapi-middleware"><a class="header" href="#fastapi-middleware">FastAPI Middleware</a></h3>
<pre><code class="language-python">from fastapi import FastAPI, Request, Response
from puma.http import HttpRequest, compile_route_matches

app = FastAPI()
matcher = compile_route_matches(...)

@app.middleware("http")
async def route_matcher_middleware(request: Request, call_next):
    req = HttpRequest(
        method=request.method,
        raw_path=str(request.url.path),
        headers=dict(request.headers),
    )

    action = matcher.evaluate(req)

    if action == "denied":
        return Response("Access denied", status_code=403)

    return await call_next(request)
</code></pre>
<h3 id="flask-before-request"><a class="header" href="#flask-before-request">Flask Before Request</a></h3>
<pre><code class="language-python">from flask import Flask, request, abort
from puma.http import HttpRequest, compile_route_matches

app = Flask(__name__)
matcher = compile_route_matches(...)

@app.before_request
def check_route():
    req = HttpRequest(
        method=request.method,
        raw_path=request.path,
        headers=dict(request.headers),
    )

    action = matcher.evaluate(req)

    if action == "denied":
        abort(403)
</code></pre>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<ul>
<li><a href="#build-an-http-router">Build an HTTP Router</a> â€” full routing patterns</li>
<li><a href="#predicate-composition">Predicate Composition</a> â€” AND/OR/NOT logic</li>
<li><a href="#benchmark-results">Benchmark Results</a> â€” performance deep dive</li>
<li><a href="#python-api-reference">Python API Reference</a> â€” complete type documentation</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="typescript-quick-start"><a class="header" href="#typescript-quick-start">TypeScript Quick Start</a></h1>
<p>Build an HTTP route matcher in 10 lines.</p>
<p>x.umaâ€™s TypeScript implementation (<code>bumi</code>) translates Gateway API route configuration into efficient runtime matchers. Routes defined at config time become compiled trees evaluated at request time.</p>
<h2 id="install-2"><a class="header" href="#install-2">Install</a></h2>
<p>Add <code>bumi</code> to your project:</p>
<pre><code class="language-bash">bun add @x.uma/bumi
</code></pre>
<p><strong>Requires Bun runtime</strong> â€” bumi uses Bunâ€™s fast startup and zero-overhead module system. It will not run on Node.js without transpilation.</p>
<p>Alternatively, import from source if youâ€™re working in the x.uma monorepo:</p>
<pre><code class="language-typescript">import { Matcher, compile_route_matches } from "bumi";
</code></pre>
<h2 id="your-first-matcher-2"><a class="header" href="#your-first-matcher-2">Your First Matcher</a></h2>
<p>Match GET requests to <code>/api/*</code> and POST requests to <code>/admin/*</code>:</p>
<pre><code class="language-typescript">import {
	type HttpRouteMatch,
	HttpRequest,
	compileRouteMatches,
} from "@x.uma/bumi/http";

// Define routes using Gateway API syntax
const routes: HttpRouteMatch[] = [
	{
		path: { type: "PathPrefix", value: "/api" },
		method: "GET",
	},
	{
		path: { type: "PathPrefix", value: "/admin" },
		method: "POST",
	},
];

// Compile routes into a matcher
const matcher = compileRouteMatches(
	routes,
	"allowed",  // action when any route matches
	"denied",   // action when no routes match
);

// Evaluate against requests
let request = new HttpRequest("GET", "/api/users");
let result = matcher.evaluate(request);
console.assert(result === "allowed");

request = new HttpRequest("DELETE", "/api/users");
result = matcher.evaluate(request);
console.assert(result === "denied"); // DELETE not in routes
</code></pre>
<p>The <code>compileRouteMatches</code> function is the high-level API. It takes a list of <code>HttpRouteMatch</code> configs and produces a <code>Matcher&lt;HttpRequest, A&gt;</code> that runs in microseconds.</p>
<h2 id="how-compilation-works-2"><a class="header" href="#how-compilation-works-2">How Compilation Works</a></h2>
<p>Gateway API route configuration is declarative. You specify what to match, not how to evaluate it:</p>
<pre><code class="language-typescript">import type {
	HttpRouteMatch,
	HttpPathMatch,
	HttpHeaderMatch,
} from "@x.uma/bumi/http";

const route: HttpRouteMatch = {
	path: { type: "PathPrefix", value: "/api" },
	method: "GET",
	headers: [
		{
			type: "Exact",
			name: "content-type",
			value: "application/json",
		},
	],
};
</code></pre>
<p>All conditions within a single <code>HttpRouteMatch</code> are ANDed together. When you pass multiple <code>HttpRouteMatch</code> entries to <code>compileRouteMatches</code>, they are ORed.</p>
<p>The compiler produces a tree of predicates:</p>
<pre><code>Matcher
â””â”€â”€ FieldMatcher
    â””â”€â”€ Or
        â”œâ”€â”€ And(path=/api, method=GET, header=content-type)
        â””â”€â”€ And(path=/admin, method=POST)
</code></pre>
<p>At evaluation time, the tree walks first-match-wins until a predicate succeeds.</p>
<h2 id="under-the-hood-manual-construction-2"><a class="header" href="#under-the-hood-manual-construction-2">Under the Hood: Manual Construction</a></h2>
<p>The Gateway API compiler is syntactic sugar. Hereâ€™s what it generates:</p>
<pre><code class="language-typescript">import {
	Matcher,
	FieldMatcher,
	Action,
	SinglePredicate,
	And,
} from "@x.uma/bumi";
import {
	ExactMatcher,
	PrefixMatcher,
} from "@x.uma/bumi";
import {
	HttpRequest,
	PathInput,
	MethodInput,
} from "@x.uma/bumi/http";

// Manual construction of the same matcher
const matcher = new Matcher&lt;HttpRequest, string&gt;([
	new FieldMatcher(
		new And([
			new SinglePredicate(
				new PathInput(),
				new PrefixMatcher("/api"),
			),
			new SinglePredicate(
				new MethodInput(),
				new ExactMatcher("GET"),
			),
		]),
		new Action("allowed"),
	),
	new FieldMatcher(
		new SinglePredicate(
			new PathInput(),
			new PrefixMatcher("/admin"),
		),
		new Action("allowed"),
	),
], new Action("denied"));
</code></pre>
<p>This is verbose but explicit. You control the exact tree structure.</p>
<p><strong>When to use manual construction:</strong></p>
<ul>
<li>Building matchers programmatically from non-Gateway-API configs</li>
<li>Implementing custom <code>DataInput</code> or <code>InputMatcher</code> interfaces</li>
<li>Debugging compilation behavior</li>
</ul>
<p><strong>When to use the compiler:</strong></p>
<ul>
<li>Standard HTTP routing (99% of use cases)</li>
<li>Gateway API configurations from Kubernetes</li>
<li>Less code, same performance</li>
</ul>
<h2 id="the-httprequest-context-1"><a class="header" href="#the-httprequest-context-1">The HttpRequest Context</a></h2>
<p><code>HttpRequest</code> is a readonly class with parsed query parameters and lowercased headers:</p>
<pre><code class="language-typescript">import { HttpRequest } from "@x.uma/bumi/http";

// Query string parsed from rawPath
const request = new HttpRequest(
	"GET",
	"/search?q=hello&amp;lang=en",
	{ "Content-Type": "application/json" },
);

console.assert(request.path === "/search");
console.assert(request.queryParam("q") === "hello");
console.assert(request.queryParam("lang") === "en");

// Headers are case-insensitive
console.assert(request.header("content-type") === "application/json");
console.assert(request.header("Content-Type") === "application/json");
</code></pre>
<p>The query string is parsed once at construction time (O(n) scan). Every <code>queryParam()</code> lookup is O(1) dictionary access.</p>
<p>Headers are stored lowercased to avoid repeated string operations during matching.</p>
<h2 id="the-readonly-pattern"><a class="header" href="#the-readonly-pattern">The Readonly Pattern</a></h2>
<p>bumi uses readonly classes instead of interfaces to ensure immutability:</p>
<pre><code class="language-typescript">export class Matcher&lt;Ctx, A&gt; {
	constructor(
		readonly matcherList: readonly FieldMatcher&lt;Ctx, A&gt;[],
		readonly onNoMatch: Action&lt;A&gt; | null = null,
	) {}

	evaluate(ctx: Ctx): A | null {
		// ...
	}
}
</code></pre>
<p>Every field is <code>readonly</code>. Arrays are <code>readonly T[]</code>. This prevents accidental mutation after construction.</p>
<p>TypeScriptâ€™s type system enforces immutability at compile time. At runtime, thereâ€™s no additional overhead compared to mutable objects.</p>
<h2 id="actions-beyond-strings-2"><a class="header" href="#actions-beyond-strings-2">Actions: Beyond Strings</a></h2>
<p>The examples use <code>string</code> actions for simplicity. In production, actions are often objects or discriminated unions:</p>
<pre><code class="language-typescript">type RouteAction =
	| { type: "forward"; backend: string; weight: number }
	| { type: "redirect"; location: string; status: number }
	| { type: "deny"; reason: string };

const matcher = compileRouteMatches(
	routes,
	{ type: "forward", backend: "api-service", weight: 100 },
	{ type: "deny", reason: "no route matched" },
);

const result = matcher.evaluate(request);
if (result?.type === "forward") {
	console.log(`Forwarding to ${result.backend}`);
}
</code></pre>
<p>The action type can be any TypeScript type. The matcher returns it by reference when a match succeeds.</p>
<h2 id="validation-and-safety-2"><a class="header" href="#validation-and-safety-2">Validation and Safety</a></h2>
<p>Matchers enforce safety constraints:</p>
<ul>
<li><strong>Depth limit</strong>: Nested matchers cannot exceed 32 levels (prevents stack overflow)</li>
<li><strong>Immutability</strong>: All types are readonly (no accidental mutation)</li>
<li><strong>Type safety</strong>: TypeScript catches type mismatches at compile time</li>
</ul>
<p>Check depth limits with <code>validate()</code>:</p>
<pre><code class="language-typescript">try {
	matcher.validate();
	console.log("Matcher is valid");
} catch (e) {
	if (e instanceof MatcherError) {
		console.error(`Validation failed: ${e.message}`);
	}
}
</code></pre>
<p>The Gateway API compiler produces valid trees. Manual construction can violate depth limits if you nest <code>NestedMatcher</code> recursively.</p>
<h2 id="performance-notes-2"><a class="header" href="#performance-notes-2">Performance Notes</a></h2>
<p>At 200 routing rules, <code>bumi</code> evaluates worst-case (last rule matches) in 2.1 microseconds on Apple M1 Max. Thatâ€™s 475,000 requests per second per core.</p>
<p><strong>Why is TypeScript faster than Rust?</strong> This isnâ€™t a language speed contest. The Rust implementation uses <code>Box&lt;dyn InputMatcher&gt;</code> for extensibility, which requires vtable dispatch. The TypeScript JIT (JavaScriptCore in Bun) sees the monomorphic call site and inlines the comparison directly.</p>
<p>For simple operations (exact string match), bumi is 3.5x faster than rumi. For regex matching or complex predicates, the gap narrows. At ReDoS-vulnerable patterns, Rustâ€™s linear-time regex is 6.5 million times faster.</p>
<p><strong>Thread safety</strong>: Bun is single-threaded. If you need parallelism, spawn worker threads:</p>
<pre><code class="language-typescript">import { Worker } from "bun";

const worker = new Worker("./matcher-worker.ts");
worker.postMessage({ method: "GET", path: "/api/users" });
</code></pre>
<p>Each worker gets its own JavaScript heap and its own matcher instance.</p>
<p>For ReDoS protection with untrusted regex input, use <code>bumi-crusty</code> instead of pure <code>bumi</code>. See <a href="#redos-protection-1">ReDoS Protection</a>.</p>
<h2 id="integration-examples-1"><a class="header" href="#integration-examples-1">Integration Examples</a></h2>
<h3 id="cloudflare-workers"><a class="header" href="#cloudflare-workers">Cloudflare Workers</a></h3>
<pre><code class="language-typescript">import { compileRouteMatches, HttpRequest } from "@x.uma/bumi/http";

const matcher = compileRouteMatches([
	{ path: { type: "PathPrefix", value: "/api" }, method: "GET" },
], "allowed", "denied");

export default {
	async fetch(request: Request): Promise&lt;Response&gt; {
		const url = new URL(request.url);
		const req = new HttpRequest(
			request.method,
			url.pathname,
			Object.fromEntries(request.headers),
		);

		const action = matcher.evaluate(req);

		if (action === "denied") {
			return new Response("Access denied", { status: 403 });
		}

		return new Response("OK");
	},
};
</code></pre>
<h3 id="bun-http-server"><a class="header" href="#bun-http-server">Bun HTTP Server</a></h3>
<pre><code class="language-typescript">import { compileRouteMatches, HttpRequest } from "@x.uma/bumi/http";

const matcher = compileRouteMatches([
	{ path: { type: "PathPrefix", value: "/api" }, method: "GET" },
], "allowed", "denied");

Bun.serve({
	port: 3000,
	fetch(req) {
		const url = new URL(req.url);
		const request = new HttpRequest(
			req.method,
			url.pathname + url.search,
			Object.fromEntries(req.headers),
		);

		const action = matcher.evaluate(request);

		if (action === "denied") {
			return new Response("Access denied", { status: 403 });
		}

		return new Response("OK");
	},
});
</code></pre>
<h2 id="next-steps-3"><a class="header" href="#next-steps-3">Next Steps</a></h2>
<ul>
<li><a href="#build-an-http-router">Build an HTTP Router</a> â€” full routing patterns</li>
<li><a href="#predicate-composition">Predicate Composition</a> â€” AND/OR/NOT logic</li>
<li><a href="#benchmark-results">Benchmark Results</a> â€” performance deep dive</li>
<li><a href="#typescript-api-reference">TypeScript API Reference</a> â€” complete type documentation</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="build-an-http-router"><a class="header" href="#build-an-http-router">Build an HTTP Router</a></h1>
<p>Route HTTP requests to handlers in under 50 lines. Start simple, add complexity progressively.</p>
<h2 id="step-1-three-path-prefixes"><a class="header" href="#step-1-three-path-prefixes">Step 1: Three Path Prefixes</a></h2>
<p>Route requests based on path prefix:</p>
<ul>
<li><code>/api/*</code> â†’ <code>"api_backend"</code></li>
<li><code>/admin/*</code> â†’ <code>"admin_backend"</code></li>
<li><code>/health</code> â†’ <code>"health_check"</code></li>
</ul>
<p><strong>Python:</strong></p>
<pre><code class="language-python">from puma.http import HttpRouteMatch, HttpPathMatch, compile_route_matches, HttpRequest

# Define routes with Gateway API syntax
routes = [
    HttpRouteMatch(path=HttpPathMatch(type="PathPrefix", value="/api")),
    HttpRouteMatch(path=HttpPathMatch(type="PathPrefix", value="/admin")),
    HttpRouteMatch(path=HttpPathMatch(type="Exact", value="/health")),
]

# Compile to a matcher (returns action or None)
matcher = compile_route_matches(routes, action="matched", on_no_match="not_found")

# Evaluate requests
assert matcher.evaluate(HttpRequest(raw_path="/api/users")) == "matched"
assert matcher.evaluate(HttpRequest(raw_path="/admin/config")) == "matched"
assert matcher.evaluate(HttpRequest(raw_path="/health")) == "matched"
assert matcher.evaluate(HttpRequest(raw_path="/other")) == "not_found"
</code></pre>
<p><strong>Rust:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rumi_http::{HttpRouteMatch, HttpPathMatch, compile_route_matches, HttpMessage};

let routes = vec![
    HttpRouteMatch {
        path: Some(HttpPathMatch::PathPrefix { value: "/api".into() }),
        ..Default::default()
    },
    HttpRouteMatch {
        path: Some(HttpPathMatch::PathPrefix { value: "/admin".into() }),
        ..Default::default()
    },
    HttpRouteMatch {
        path: Some(HttpPathMatch::Exact { value: "/health".into() }),
        ..Default::default()
    },
];

let matcher = compile_route_matches(&amp;routes, "matched", Some("not_found"));

assert_eq!(matcher.evaluate(&amp;http_message), Some("matched"));
<span class="boring">}</span></code></pre>
<p>Gateway API <code>HttpRouteMatch</code> is the config layer. The compiler builds the matcher tree for you.</p>
<h2 id="step-2-add-method-matching"><a class="header" href="#step-2-add-method-matching">Step 2: Add Method Matching</a></h2>
<p>Route GET and POST differently:</p>
<ul>
<li><code>GET /api/*</code> â†’ <code>"api_read"</code></li>
<li><code>POST /api/*</code> â†’ <code>"api_write"</code></li>
</ul>
<p><strong>Python:</strong></p>
<pre><code class="language-python">from puma.http import HttpRouteMatch, HttpPathMatch, HttpRequest

routes = [
    HttpRouteMatch(
        path=HttpPathMatch(type="PathPrefix", value="/api"),
        method="GET"
    ),
    HttpRouteMatch(
        path=HttpPathMatch(type="PathPrefix", value="/api"),
        method="POST"
    ),
]

# Different actions per route
matchers = [route.compile(action) for route, action in zip(routes, ["api_read", "api_write"])]

# Combine into one matcher with on_no_match
from puma import Matcher, FieldMatcher, Or, NestedMatcher, Action

combined = Matcher(
    matcher_list=tuple(
        FieldMatcher(
            predicate=route.to_predicate(),
            on_match=Action(action)
        )
        for route, action in zip(routes, ["api_read", "api_write"])
    ),
    on_no_match=Action("method_not_allowed")
)

# Test
assert combined.evaluate(HttpRequest(method="GET", raw_path="/api/users")) == "api_read"
assert combined.evaluate(HttpRequest(method="POST", raw_path="/api/users")) == "api_write"
assert combined.evaluate(HttpRequest(method="DELETE", raw_path="/api/users")) == "method_not_allowed"
</code></pre>
<p>Within a single <code>HttpRouteMatch</code>, all conditions are ANDed (path AND method). Multiple <code>HttpRouteMatch</code> entries are ORed.</p>
<p><strong>Rust:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rumi_http::{HttpRouteMatch, HttpPathMatch, HttpMessage};

let routes = vec![
    HttpRouteMatch {
        path: Some(HttpPathMatch::PathPrefix { value: "/api".into() }),
        method: Some("GET".into()),
        ..Default::default()
    },
    HttpRouteMatch {
        path: Some(HttpPathMatch::PathPrefix { value: "/api".into() }),
        method: Some("POST".into()),
        ..Default::default()
    },
];

// Build separate matchers or use compile_route_matches with action types
<span class="boring">}</span></code></pre>
<h2 id="step-3-add-header-conditions"><a class="header" href="#step-3-add-header-conditions">Step 3: Add Header Conditions</a></h2>
<p>Require authentication for POST requests:</p>
<ul>
<li><code>POST /api/*</code> with <code>Authorization: Bearer *</code> â†’ <code>"api_authenticated"</code></li>
<li><code>POST /api/*</code> without auth â†’ <code>"unauthorized"</code></li>
</ul>
<p><strong>Python:</strong></p>
<pre><code class="language-python">from puma.http import HttpRouteMatch, HttpPathMatch, HttpHeaderMatch, HttpRequest

auth_route = HttpRouteMatch(
    path=HttpPathMatch(type="PathPrefix", value="/api"),
    method="POST",
    headers=[
        HttpHeaderMatch(type="RegularExpression", name="authorization", value=r"^Bearer .+$")
    ]
)

noauth_route = HttpRouteMatch(
    path=HttpPathMatch(type="PathPrefix", value="/api"),
    method="POST"
)

# Order matters: more specific (auth required) comes first
routes = [auth_route, noauth_route]
actions = ["api_authenticated", "unauthorized"]

matcher = Matcher(
    matcher_list=tuple(
        FieldMatcher(predicate=route.to_predicate(), on_match=Action(action))
        for route, action in zip(routes, actions)
    ),
    on_no_match=Action("not_found")
)

# Test
request = HttpRequest(
    method="POST",
    raw_path="/api/users",
    headers={"authorization": "Bearer token123"}
)
assert matcher.evaluate(request) == "api_authenticated"

request = HttpRequest(method="POST", raw_path="/api/users", headers={})
assert matcher.evaluate(request) == "unauthorized"
</code></pre>
<p>First-match-wins semantics: the auth route matches first if the header is present. If it doesnâ€™t match, evaluation continues to the noauth route.</p>
<p><strong>Rust:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rumi_http::{HttpRouteMatch, HttpPathMatch, HttpHeaderMatch};

let auth_route = HttpRouteMatch {
    path: Some(HttpPathMatch::PathPrefix { value: "/api".into() }),
    method: Some("POST".into()),
    headers: Some(vec![
        HttpHeaderMatch::RegularExpression {
            name: "authorization".into(),
            value: r"^Bearer .+$".into(),
        }
    ]),
    ..Default::default()
};
<span class="boring">}</span></code></pre>
<h2 id="step-4-add-query-parameter-matching"><a class="header" href="#step-4-add-query-parameter-matching">Step 4: Add Query Parameter Matching</a></h2>
<p>Route based on query parameters:</p>
<ul>
<li><code>/search?version=2</code> â†’ <code>"search_v2"</code></li>
<li><code>/search?version=1</code> â†’ <code>"search_v1"</code></li>
<li><code>/search</code> (no version) â†’ <code>"search_latest"</code></li>
</ul>
<p><strong>Python:</strong></p>
<pre><code class="language-python">from puma.http import HttpRouteMatch, HttpPathMatch, HttpQueryParamMatch, HttpRequest

routes = [
    HttpRouteMatch(
        path=HttpPathMatch(type="Exact", value="/search"),
        query_params=[
            HttpQueryParamMatch(type="Exact", name="version", value="2")
        ]
    ),
    HttpRouteMatch(
        path=HttpPathMatch(type="Exact", value="/search"),
        query_params=[
            HttpQueryParamMatch(type="Exact", name="version", value="1")
        ]
    ),
    HttpRouteMatch(
        path=HttpPathMatch(type="Exact", value="/search")
    ),
]

actions = ["search_v2", "search_v1", "search_latest"]

matcher = Matcher(
    matcher_list=tuple(
        FieldMatcher(predicate=route.to_predicate(), on_match=Action(action))
        for route, action in zip(routes, actions)
    )
)

# Test
assert matcher.evaluate(HttpRequest(raw_path="/search?version=2")) == "search_v2"
assert matcher.evaluate(HttpRequest(raw_path="/search?version=1")) == "search_v1"
assert matcher.evaluate(HttpRequest(raw_path="/search")) == "search_latest"
assert matcher.evaluate(HttpRequest(raw_path="/search?other=param")) == "search_latest"
</code></pre>
<p>Query parameters are parsed from <code>raw_path</code> automatically. Order matters: version-specific routes come before the no-version route.</p>
<p><strong>Rust:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rumi_http::{HttpRouteMatch, HttpPathMatch, HttpQueryParamMatch};

let v2_route = HttpRouteMatch {
    path: Some(HttpPathMatch::Exact { value: "/search".into() }),
    query_params: Some(vec![
        HttpQueryParamMatch::Exact {
            name: "version".into(),
            value: "2".into(),
        }
    ]),
    ..Default::default()
};
<span class="boring">}</span></code></pre>
<h2 id="step-5-multiple-routes-with-fallback"><a class="header" href="#step-5-multiple-routes-with-fallback">Step 5: Multiple Routes with Fallback</a></h2>
<p>Combine everything into a production-ready router:</p>
<p><strong>Python:</strong></p>
<pre><code class="language-python">from puma.http import (
    HttpRouteMatch, HttpPathMatch, HttpHeaderMatch, HttpQueryParamMatch,
    compile_route_matches, HttpRequest
)

# Define routes
api_auth = HttpRouteMatch(
    path=HttpPathMatch(type="PathPrefix", value="/api"),
    method="POST",
    headers=[HttpHeaderMatch(type="RegularExpression", name="authorization", value=r"^Bearer .+$")]
)

api_get = HttpRouteMatch(
    path=HttpPathMatch(type="PathPrefix", value="/api"),
    method="GET"
)

admin = HttpRouteMatch(
    path=HttpPathMatch(type="PathPrefix", value="/admin"),
    headers=[HttpHeaderMatch(type="Exact", name="x-admin-key", value="secret")]
)

health = HttpRouteMatch(
    path=HttpPathMatch(type="Exact", value="/health")
)

# Build matcher
routes = [api_auth, api_get, admin, health]
actions = ["api_write", "api_read", "admin_panel", "health_check"]

matcher = Matcher(
    matcher_list=tuple(
        FieldMatcher(predicate=route.to_predicate(), on_match=Action(action))
        for route, action in zip(routes, actions)
    ),
    on_no_match=Action("not_found")
)

# Test all cases
assert matcher.evaluate(
    HttpRequest(method="POST", raw_path="/api/users", headers={"authorization": "Bearer token"})
) == "api_write"

assert matcher.evaluate(
    HttpRequest(method="GET", raw_path="/api/users")
) == "api_read"

assert matcher.evaluate(
    HttpRequest(raw_path="/admin", headers={"x-admin-key": "secret"})
) == "admin_panel"

assert matcher.evaluate(HttpRequest(raw_path="/health")) == "health_check"

assert matcher.evaluate(HttpRequest(raw_path="/unknown")) == "not_found"
</code></pre>
<p>This is a complete HTTP router in 30 lines of config. No framework. No DSL. Pure Gateway API.</p>
<p><strong>Rust equivalent:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rumi::prelude::*;
use rumi_http::{HttpRouteMatch, HttpPathMatch, HttpHeaderMatch, HttpMessage};

let routes = vec![
    HttpRouteMatch {
        path: Some(HttpPathMatch::PathPrefix { value: "/api".into() }),
        method: Some("POST".into()),
        headers: Some(vec![HttpHeaderMatch::RegularExpression {
            name: "authorization".into(),
            value: r"^Bearer .+$".into(),
        }]),
        ..Default::default()
    },
    HttpRouteMatch {
        path: Some(HttpPathMatch::PathPrefix { value: "/api".into() }),
        method: Some("GET".into()),
        ..Default::default()
    },
    HttpRouteMatch {
        path: Some(HttpPathMatch::PathPrefix { value: "/admin".into() }),
        headers: Some(vec![HttpHeaderMatch::Exact {
            name: "x-admin-key".into(),
            value: "secret".into(),
        }]),
        ..Default::default()
    },
    HttpRouteMatch {
        path: Some(HttpPathMatch::Exact { value: "/health".into() }),
        ..Default::default()
    },
];

// Build matcher per route with different actions
// Or use custom action enum to distinguish routes
<span class="boring">}</span></code></pre>
<h2 id="whats-next"><a class="header" href="#whats-next">Whatâ€™s Next</a></h2>
<p>This tutorial showed the Gateway API compiler pattern. You can also build matchers manually for finer control:</p>
<p><strong>Manual matcher construction:</strong></p>
<pre><code class="language-python">from puma import Matcher, FieldMatcher, SinglePredicate, PrefixMatcher, Action
from puma.http import PathInput

# Bypass the compiler, build the tree directly
matcher = Matcher(
    matcher_list=(
        FieldMatcher(
            predicate=SinglePredicate(PathInput(), PrefixMatcher("/api")),
            on_match=Action("api_backend")
        ),
    )
)
</code></pre>
<p>Manual construction is more verbose but gives you full control over the matcher tree structure.</p>
<p><strong>Learn more:</strong></p>
<ul>
<li><a href="#the-matching-pipeline">The Matching Pipeline</a> â€” How data flows through the matcher</li>
<li><a href="#type-erasure-and-ports">Type Erasure and Ports</a> â€” Why matchers are reusable</li>
<li><a href="#predicate-composition">Predicate Composition</a> â€” AND, OR, NOT in detail</li>
<li><a href="#first-match-wins-semantics">First-Match-Wins Semantics</a> â€” Evaluation order and fallbacks</li>
<li><a href="#adding-a-domain">Adding a Domain</a> â€” Create matchers for CloudEvents, gRPC, etc.</li>
</ul>
<p><strong>Performance:</strong></p>
<ul>
<li>Matchers are immutable and thread-safe â€” share them across threads</li>
<li>Regex compilation happens at construction time â€” no per-request overhead</li>
<li>First-match-wins means early rules short-circuit evaluation</li>
<li>For production workloads, consider <code>puma-crusty</code> (Rust-backed) for 10x+ speedup</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="the-matching-pipeline"><a class="header" href="#the-matching-pipeline">The Matching Pipeline</a></h1>
<p>Every matcher is a pipeline. Data flows in one end, a decision comes out the other. Understanding this flow is understanding x.uma.</p>
<h2 id="the-flow"><a class="header" href="#the-flow">The Flow</a></h2>
<p>Hereâ€™s what happens when you evaluate a request:</p>
<pre><code class="language-text">HttpRequest
    â†“
PathInput.get()        â† "Extract the path"
    â†“
"/api/users"          â† MatchingValue (type-erased)
    â†“
PrefixMatcher.matches() â† "Does it start with /api?"
    â†“
true                  â† boolean result
    â†“
Predicate.evaluate()   â† "Combine with other conditions"
    â†“
true                  â† combined result
    â†“
Matcher.evaluate()     â† "Find the first matching rule"
    â†“
"api_backend"         â† Action (your decision)
</code></pre>
<p>Each step is a port. Domain-specific adapters (like <code>PathInput</code>) plug in at the edges. The core (like <code>PrefixMatcher</code>) is domain-agnostic and reusable.</p>
<h2 id="http-example"><a class="header" href="#http-example">HTTP Example</a></h2>
<p>Route GET requests to <code>/api/*</code> to the API backend:</p>
<p><strong>Python:</strong></p>
<pre><code class="language-python">from puma import SinglePredicate, PrefixMatcher, Matcher, FieldMatcher, Action
from puma.http import HttpRequest, PathInput

# Step 1: Define extraction + matching
predicate = SinglePredicate(
    input=PathInput(),
    matcher=PrefixMatcher("/api")
)

# Step 2: Build the matcher tree
matcher = Matcher(
    matcher_list=(
        FieldMatcher(predicate=predicate, on_match=Action("api_backend")),
    )
)

# Step 3: Evaluate against requests
request = HttpRequest(method="GET", raw_path="/api/users")
result = matcher.evaluate(request)
assert result == "api_backend"
</code></pre>
<p><strong>Rust:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rumi::prelude::*;
use rumi_http::{HttpMessage, PathInput};

// Step 1: Define extraction + matching
let predicate = SinglePredicate::new(
    PathInput,
    PrefixMatcher::new("/api"),
);

// Step 2: Build the matcher tree
let matcher = Matcher::new(
    vec![FieldMatcher::new(predicate, OnMatch::Action("api_backend"))],
    None,
);

// Step 3: Evaluate against requests
let result = matcher.evaluate(&amp;http_message);
assert_eq!(result, Some("api_backend"));
<span class="boring">}</span></code></pre>
<h2 id="the-same-pipeline-different-domain"><a class="header" href="#the-same-pipeline-different-domain">The Same Pipeline, Different Domain</a></h2>
<p>The power of type erasure: the same <code>PrefixMatcher</code> works for HTTP paths and CloudEvent types.</p>
<p><strong>CloudEvent example (custom domain):</strong></p>
<pre><code class="language-python">from dataclasses import dataclass
from puma import SinglePredicate, PrefixMatcher, Matcher, FieldMatcher, Action, DataInput, MatchingData

# Define your context type
@dataclass
class CloudEvent:
    type: str
    source: str
    data: dict

# Define your extraction adapter
@dataclass
class EventTypeInput:
    def get(self, ctx: CloudEvent) -&gt; MatchingData:
        return ctx.type

# Use the SAME PrefixMatcher
predicate = SinglePredicate(
    input=EventTypeInput(),
    matcher=PrefixMatcher("com.example.")  # Same matcher, different domain!
)

matcher = Matcher(
    matcher_list=(
        FieldMatcher(predicate=predicate, on_match=Action("route_to_handler")),
    )
)

# Evaluate against events
event = CloudEvent(type="com.example.user.created", source="api", data={})
result = matcher.evaluate(event)
assert result == "route_to_handler"
</code></pre>
<p>The <code>PrefixMatcher</code> doesnâ€™t know or care whether itâ€™s matching HTTP paths or event types. It operates on <code>MatchingData</code> (the type-erased value), not the original context type.</p>
<p><strong>This is the core insight:</strong> domain adapters (<code>PathInput</code>, <code>EventTypeInput</code>) are context-specific. Core matchers (<code>PrefixMatcher</code>, <code>ExactMatcher</code>) are domain-agnostic. The pipeline connects them.</p>
<h2 id="pipeline-stages"><a class="header" href="#pipeline-stages">Pipeline Stages</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Stage</th><th>Role</th><th>Generic?</th><th>Examples</th></tr>
</thead>
<tbody>
<tr><td><strong>Context</strong></td><td>Your domain data</td><td>Yes (<code>Ctx</code>)</td><td><code>HttpRequest</code>, <code>CloudEvent</code>, <code>GrpcRequest</code></td></tr>
<tr><td><strong>DataInput</strong></td><td>Extract data</td><td>Yes (<code>Ctx</code>)</td><td><code>PathInput</code>, <code>EventTypeInput</code>, <code>HeaderInput</code></td></tr>
<tr><td><strong>MatchingValue</strong></td><td>Type-erased data</td><td>No</td><td><code>str</code>, <code>int</code>, <code>bool</code>, <code>bytes</code>, <code>None</code></td></tr>
<tr><td><strong>InputMatcher</strong></td><td>Match the value</td><td>No</td><td><code>ExactMatcher</code>, <code>PrefixMatcher</code>, <code>RegexMatcher</code></td></tr>
<tr><td><strong>Predicate</strong></td><td>Boolean composition</td><td>Yes (<code>Ctx</code>)</td><td><code>SinglePredicate</code>, <code>And</code>, <code>Or</code>, <code>Not</code></td></tr>
<tr><td><strong>Matcher</strong></td><td>First-match-wins tree</td><td>Yes (<code>Ctx</code>, <code>A</code>)</td><td>Routes to actions</td></tr>
<tr><td><strong>Action</strong></td><td>Your decision</td><td>Yes (<code>A</code>)</td><td><code>"api_backend"</code>, <code>42</code>, custom types</td></tr>
</tbody>
</table>
</div>
<p>The middle stage (<code>MatchingValue</code> â†’ <code>InputMatcher</code> â†’ <code>bool</code>) is where domain-agnostic magic happens. Same matchers, different domains.</p>
<h2 id="next-steps-4"><a class="header" href="#next-steps-4">Next Steps</a></h2>
<ul>
<li><a href="#type-erasure-and-ports">Type Erasure and Ports</a> â€” Why InputMatcher is non-generic</li>
<li><a href="#predicate-composition">Predicate Composition</a> â€” Combining conditions with AND/OR/NOT</li>
<li><a href="#first-match-wins-semantics">First-Match-Wins Semantics</a> â€” Evaluation order and nested matchers</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="type-erasure-and-ports"><a class="header" href="#type-erasure-and-ports">Type Erasure and Ports</a></h1>
<p>Why does the same <code>ExactMatcher</code> work for HTTP headers and event types? Type erasure at the data level.</p>
<h2 id="the-problem"><a class="header" href="#the-problem">The Problem</a></h2>
<p>If <code>InputMatcher</code> were generic over the context type, you couldnâ€™t share matchers across domains:</p>
<pre><code class="language-python"># If InputMatcher were generic (DON'T DO THIS)
class InputMatcher[Ctx]:
    def matches(self, ctx: Ctx) -&gt; bool: ...

# Now you need different matchers for each domain
http_matcher = ExactMatcher[HttpRequest]("/api")
event_matcher = ExactMatcher[CloudEvent]("com.example.user")

# Can't put them in the same list!
matchers = [http_matcher, event_matcher]  # Type error!
</code></pre>
<p>Every domain would need its own matcher implementations. No code reuse. Thatâ€™s not scalable.</p>
<h2 id="the-solution"><a class="header" href="#the-solution">The Solution</a></h2>
<p>Erase the type at the <strong>data level</strong>, not the matcher level. Extract the value first, then match against the type-erased value.</p>
<pre><code class="language-python"># InputMatcher is non-generic
class InputMatcher:
    def matches(self, value: MatchingData) -&gt; bool: ...

# DataInput is generic and domain-specific
class DataInput[Ctx]:
    def get(self, ctx: Ctx) -&gt; MatchingData: ...
</code></pre>
<p>Now one <code>ExactMatcher</code> works for all domains:</p>
<pre><code class="language-python"># Same matcher works for HTTP paths
path_predicate = SinglePredicate(
    input=PathInput(),           # Extracts str from HttpRequest
    matcher=ExactMatcher("/api") # Matches the str
)

# And for event types
event_predicate = SinglePredicate(
    input=EventTypeInput(),      # Extracts str from CloudEvent
    matcher=ExactMatcher("/api") # SAME matcher!
)
</code></pre>
<h2 id="matchingvalue-the-erased-type"><a class="header" href="#matchingvalue-the-erased-type">MatchingValue: The Erased Type</a></h2>
<p><code>MatchingValue</code> is the bridge between domain-specific and domain-agnostic code.</p>
<p><strong>Python:</strong></p>
<pre><code class="language-python">type MatchingValue = str | int | bool | bytes | None
</code></pre>
<p><strong>Rust:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum MatchingData {
    None,
    String(String),
    Int(i64),
    Bool(bool),
    Bytes(Vec&lt;u8&gt;),
}
<span class="boring">}</span></code></pre>
<p><strong>TypeScript:</strong></p>
<pre><code class="language-typescript">type MatchingData = string | number | boolean | Uint8Array | null;
</code></pre>
<p>Same concept, idiomatic types for each language. Rust uses an enum. Python and TypeScript use union types.</p>
<h2 id="example-sharing-matchers-across-domains"><a class="header" href="#example-sharing-matchers-across-domains">Example: Sharing Matchers Across Domains</a></h2>
<p>The same <code>ExactMatcher</code> matches HTTP headers and CloudEvent attributes:</p>
<pre><code class="language-python">from puma import SinglePredicate, ExactMatcher
from puma.http import HttpRequest, HeaderInput
from dataclasses import dataclass

# HTTP domain
http_predicate = SinglePredicate(
    input=HeaderInput("content-type"),
    matcher=ExactMatcher("application/json")  # Match header value
)

http_request = HttpRequest(headers={"content-type": "application/json"})
assert http_predicate.evaluate(http_request) == True

# CloudEvent domain
@dataclass
class CloudEvent:
    content_type: str
    data: dict

@dataclass
class ContentTypeInput:
    def get(self, ctx: CloudEvent):
        return ctx.content_type

event_predicate = SinglePredicate(
    input=ContentTypeInput(),
    matcher=ExactMatcher("application/json")  # SAME matcher!
)

event = CloudEvent(content_type="application/json", data={})
assert event_predicate.evaluate(event) == True
</code></pre>
<p>One <code>ExactMatcher</code> implementation. Two domains. This is type erasure in action.</p>
<h2 id="port-architecture"><a class="header" href="#port-architecture">Port Architecture</a></h2>
<p>Type erasure creates two ports:</p>
<pre><code class="language-text">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Domain-Specific Layer           â”‚
â”‚  (knows about Ctx: HttpRequest, etc.)   â”‚
â”‚                                         â”‚
â”‚  PathInput, HeaderInput, EventTypeInput â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚ get() returns MatchingValue
               â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Domain-Agnostic Layer           â”‚
â”‚  (knows only about MatchingValue)       â”‚
â”‚                                         â”‚
â”‚  ExactMatcher, PrefixMatcher, Regex...  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<p><strong>Extraction port (<code>DataInput</code>):</strong> Converts <code>Ctx</code> â†’ <code>MatchingValue</code>. Domain-specific.</p>
<p><strong>Matching port (<code>InputMatcher</code>):</strong> Converts <code>MatchingValue</code> â†’ <code>bool</code>. Domain-agnostic.</p>
<p>The boundary is <code>MatchingValue</code>. Cross it once, and matchers work everywhere.</p>
<h2 id="cross-language-comparison"><a class="header" href="#cross-language-comparison">Cross-Language Comparison</a></h2>
<p>All three implementations use type erasure. The syntax differs, but the pattern is identical.</p>
<p><strong>Rust:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Type-erased data
pub enum MatchingData {
    String(String),
    Int(i64),
    // ...
}

// Domain-specific extraction (generic)
pub trait DataInput&lt;Ctx&gt;: Send + Sync {
    fn get(&amp;self, ctx: &amp;Ctx) -&gt; MatchingData;
}

// Domain-agnostic matching (non-generic)
pub trait InputMatcher: Send + Sync {
    fn matches(&amp;self, value: &amp;MatchingData) -&gt; bool;
}
<span class="boring">}</span></code></pre>
<p><strong>Python:</strong></p>
<pre><code class="language-python"># Type-erased data
type MatchingValue = str | int | bool | bytes | None

# Domain-specific extraction (generic)
class DataInput[Ctx](Protocol):
    def get(self, ctx: Ctx) -&gt; MatchingValue: ...

# Domain-agnostic matching (non-generic)
class InputMatcher(Protocol):
    def matches(self, value: MatchingValue) -&gt; bool: ...
</code></pre>
<p><strong>TypeScript:</strong></p>
<pre><code class="language-typescript">// Type-erased data
type MatchingData = string | number | boolean | Uint8Array | null;

// Domain-specific extraction (generic)
interface DataInput&lt;Ctx&gt; {
  get(ctx: Ctx): MatchingData;
}

// Domain-agnostic matching (non-generic)
interface InputMatcher {
  matches(value: MatchingData): boolean;
}
</code></pre>
<p>Same structure. Same insight. Type erasure at the data level enables matcher reuse.</p>
<h2 id="performance-note"><a class="header" href="#performance-note">Performance Note</a></h2>
<p>Type erasure uses dynamic dispatch (<code>Box&lt;dyn InputMatcher&gt;</code> in Rust, protocol conformance in Python, vtable lookup in TypeScript). This has a small runtime cost.</p>
<p><strong>Benchmark (simple exact match):</strong></p>
<ul>
<li>TypeScript (JIT-optimized): 9.3 ns/op</li>
<li>Rust (vtable dispatch): 33 ns/op</li>
<li>Python (protocol check): ~100 ns/op</li>
</ul>
<p>For simple operations, TypeScriptâ€™s JIT can beat Rustâ€™s vtable dispatch. For complex operations (regex, deep trees), Rustâ€™s compiled code dominates. The point: dynamic dispatch is fast enough. The flexibility is worth the cost.</p>
<h2 id="next-steps-5"><a class="header" href="#next-steps-5">Next Steps</a></h2>
<ul>
<li><a href="#the-matching-pipeline">The Matching Pipeline</a> â€” How data flows through the system</li>
<li><a href="#predicate-composition">Predicate Composition</a> â€” Building complex conditions</li>
<li><a href="#adding-a-domain">Adding a Domain</a> â€” Create your own DataInput types</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="predicate-composition"><a class="header" href="#predicate-composition">Predicate Composition</a></h1>
<p>Real matchers combine conditions. AND, OR, NOT â€” compose them freely.</p>
<h2 id="singlepredicate-the-building-block"><a class="header" href="#singlepredicate-the-building-block">SinglePredicate: The Building Block</a></h2>
<p>A predicate is extraction plus matching in one step:</p>
<pre><code class="language-python">from puma import SinglePredicate, PrefixMatcher
from puma.http import PathInput

# "Does the path start with /api?"
predicate = SinglePredicate(
    input=PathInput(),
    matcher=PrefixMatcher("/api")
)
</code></pre>
<p>When evaluated, it extracts the path and checks if it starts with <code>/api</code>. One step.</p>
<h2 id="and-all-must-match"><a class="header" href="#and-all-must-match">AND: All Must Match</a></h2>
<p>Combine multiple conditions. All must be true.</p>
<pre><code class="language-python">from puma import And, SinglePredicate, PrefixMatcher, ExactMatcher
from puma.http import PathInput, MethodInput

# "Is it GET /api/*?"
predicate = And((
    SinglePredicate(PathInput(), PrefixMatcher("/api")),
    SinglePredicate(MethodInput(), ExactMatcher("GET")),
))
</code></pre>
<p><strong>Short-circuits:</strong> Stops evaluating on the first false condition. If the path check fails, the method check never runs.</p>
<p><strong>Rust equivalent:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rumi::prelude::*;
use rumi_http::{PathInput, MethodInput};

let predicate = Predicate::and(vec![
    SinglePredicate::new(PathInput, PrefixMatcher::new("/api")),
    SinglePredicate::new(MethodInput, ExactMatcher::new("GET")),
]);
<span class="boring">}</span></code></pre>
<p><strong>TypeScript equivalent:</strong></p>
<pre><code class="language-typescript">import { And, SinglePredicate, PrefixMatcher, ExactMatcher } from '@x.uma/buma';
import { PathInput, MethodInput } from '@x.uma/buma/http';

const predicate = new And([
  new SinglePredicate(new PathInput(), new PrefixMatcher('/api')),
  new SinglePredicate(new MethodInput(), new ExactMatcher('GET')),
]);
</code></pre>
<h2 id="or-any-must-match"><a class="header" href="#or-any-must-match">OR: Any Must Match</a></h2>
<p>At least one condition must be true.</p>
<pre><code class="language-python">from puma import Or, SinglePredicate, PrefixMatcher
from puma.http import PathInput

# "Does the path start with /api or /admin?"
predicate = Or((
    SinglePredicate(PathInput(), PrefixMatcher("/api")),
    SinglePredicate(PathInput(), PrefixMatcher("/admin")),
))
</code></pre>
<p><strong>Short-circuits:</strong> Stops evaluating on the first true condition. If the first prefix matches, the second check never runs.</p>
<h2 id="not-invert-the-result"><a class="header" href="#not-invert-the-result">NOT: Invert the Result</a></h2>
<p>Negate any predicate.</p>
<pre><code class="language-python">from puma import Not, SinglePredicate, ExactMatcher
from puma.http import MethodInput

# "Is it NOT a POST request?"
predicate = Not(
    SinglePredicate(MethodInput(), ExactMatcher("POST"))
)
</code></pre>
<p>Useful for exclusion rules (match everything except X).</p>
<h2 id="nesting-combine-freely"><a class="header" href="#nesting-combine-freely">Nesting: Combine Freely</a></h2>
<p>Predicates nest arbitrarily up to <code>MAX_DEPTH</code> (32 levels).</p>
<pre><code class="language-python">from puma import And, Or, SinglePredicate, PrefixMatcher, ExactMatcher
from puma.http import PathInput, MethodInput, HeaderInput

# "(GET /api/* OR POST /api/*) AND has auth header"
predicate = And((
    Or((
        And((
            SinglePredicate(MethodInput(), ExactMatcher("GET")),
            SinglePredicate(PathInput(), PrefixMatcher("/api")),
        )),
        And((
            SinglePredicate(MethodInput(), ExactMatcher("POST")),
            SinglePredicate(PathInput(), PrefixMatcher("/api")),
        )),
    )),
    SinglePredicate(HeaderInput("authorization"), PrefixMatcher("Bearer ")),
))
</code></pre>
<p>This reads like: â€œAccept GET or POST to <code>/api/*</code>, but only if the request has an authorization header starting with <code>Bearer </code>.â€</p>
<p><strong>Depth validation:</strong> Trees exceeding 32 levels raise <code>MatcherError</code> at construction time. This protects against stack overflow and enforces a reasonable complexity limit.</p>
<h2 id="gateway-api-compiler"><a class="header" href="#gateway-api-compiler">Gateway API Compiler</a></h2>
<p>Manual predicate construction is verbose. The HTTP domain provides a compiler that builds predicates from Gateway API config:</p>
<pre><code class="language-python">from puma.http import HttpRouteMatch, HttpPathMatch, HttpHeaderMatch

# Human-friendly config
route = HttpRouteMatch(
    path=HttpPathMatch(type="PathPrefix", value="/api"),
    method="GET",
    headers=[
        HttpHeaderMatch(type="Exact", name="content-type", value="application/json")
    ],
)

# Compiler builds the predicate tree for you
predicate = route.to_predicate()
</code></pre>
<p>This generates an <code>And</code> with three conditions (path, method, header). You donâ€™t write the nesting manually.</p>
<p><strong>Rust equivalent:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rumi_http::{HttpRouteMatch, HttpPathMatch, HttpHeaderMatch};

let route = HttpRouteMatch {
    path: Some(HttpPathMatch::PathPrefix { value: "/api".into() }),
    method: Some("GET".into()),
    headers: Some(vec![
        HttpHeaderMatch::Exact {
            name: "content-type".into(),
            value: "application/json".into(),
        }
    ]),
    ..Default::default()
};

let predicate = route.to_predicate();
<span class="boring">}</span></code></pre>
<h2 id="empty-and-and-or"><a class="header" href="#empty-and-and-or">Empty AND and OR</a></h2>
<p>Edge cases with empty lists:</p>
<p><strong>Empty AND:</strong> Returns <code>true</code> (vacuous truth). No conditions to fail means success.</p>
<pre><code class="language-python">from puma import And

predicate = And(())  # Empty tuple
assert predicate.evaluate(request) == True
</code></pre>
<p><strong>Empty OR:</strong> Returns <code>false</code>. No conditions to pass means failure.</p>
<pre><code class="language-python">from puma import Or

predicate = Or(())  # Empty tuple
assert predicate.evaluate(request) == False
</code></pre>
<p>These match standard boolean algebra. In practice, you rarely construct empty predicates directly.</p>
<h2 id="the-none--false-invariant"><a class="header" href="#the-none--false-invariant">The None â†’ False Invariant</a></h2>
<p>If a <code>DataInput</code> returns <code>None</code>, the predicate evaluates to <code>False</code> without calling the matcher.</p>
<pre><code class="language-python">from puma import SinglePredicate, ExactMatcher
from puma.http import HttpRequest, HeaderInput

predicate = SinglePredicate(
    input=HeaderInput("x-api-key"),
    matcher=ExactMatcher("secret")
)

# Header not present â†’ DataInput returns None â†’ predicate returns False
request = HttpRequest(headers={})
assert predicate.evaluate(request) == False
</code></pre>
<p>The matcher never sees <code>None</code>. The predicate handles it upstream. This simplifies matcher implementations (they only handle present values).</p>
<h2 id="cross-language-predicate-types"><a class="header" href="#cross-language-predicate-types">Cross-Language Predicate Types</a></h2>
<p>All three implementations provide the same predicate types with identical semantics.</p>
<p><strong>Rust:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Predicate&lt;Ctx&gt; {
    Single(SinglePredicate&lt;Ctx&gt;),
    And(Vec&lt;Predicate&lt;Ctx&gt;&gt;),
    Or(Vec&lt;Predicate&lt;Ctx&gt;&gt;),
    Not(Box&lt;Predicate&lt;Ctx&gt;&gt;),
}
<span class="boring">}</span></code></pre>
<p><strong>Python:</strong></p>
<pre><code class="language-python">type Predicate[Ctx] = SinglePredicate[Ctx] | And[Ctx] | Or[Ctx] | Not[Ctx]
</code></pre>
<p><strong>TypeScript:</strong></p>
<pre><code class="language-typescript">type Predicate&lt;Ctx&gt; =
  | SinglePredicate&lt;Ctx&gt;
  | And&lt;Ctx&gt;
  | Or&lt;Ctx&gt;
  | Not&lt;Ctx&gt;;
</code></pre>
<p>Same structure. Same short-circuit behavior. Same depth limits. Write once in any language, the logic transfers.</p>
<h2 id="next-steps-6"><a class="header" href="#next-steps-6">Next Steps</a></h2>
<ul>
<li><a href="#the-matching-pipeline">The Matching Pipeline</a> â€” Where predicates fit in the flow</li>
<li><a href="#first-match-wins-semantics">First-Match-Wins Semantics</a> â€” How matchers use predicates</li>
<li><a href="#build-an-http-router">Build an HTTP Router</a> â€” Predicates in action</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="first-match-wins-semantics"><a class="header" href="#first-match-wins-semantics">First-Match-Wins Semantics</a></h1>
<p>Evaluation order matters. The first match wins, and nested failures propagate.</p>
<h2 id="the-rules"><a class="header" href="#the-rules">The Rules</a></h2>
<p>x.uma follows xDS matcher semantics. Six rules govern evaluation:</p>
<ol>
<li>First-match-wins</li>
<li>OnMatch exclusivity</li>
<li>Nested matcher failure propagation</li>
<li>on_no_match fallback</li>
<li>None â†’ false invariant</li>
<li>Depth validation</li>
</ol>
<p>Each rule affects what happens when you evaluate a matcher tree. Get these wrong, and your routes wonâ€™t behave as expected.</p>
<h2 id="rule-1-first-match-wins"><a class="header" href="#rule-1-first-match-wins">Rule 1: First-Match-Wins</a></h2>
<p>Matchers evaluate field matchers in order. The first matching predicate wins. Later matches are never consulted.</p>
<pre><code class="language-python">from puma import Matcher, FieldMatcher, SinglePredicate, PrefixMatcher, Action
from puma.http import HttpRequest, PathInput

matcher = Matcher(
    matcher_list=(
        FieldMatcher(
            predicate=SinglePredicate(PathInput(), PrefixMatcher("/api")),
            on_match=Action("api_backend")
        ),
        FieldMatcher(
            predicate=SinglePredicate(PathInput(), PrefixMatcher("/api/v2")),
            on_match=Action("api_v2_backend")  # NEVER REACHED!
        ),
    )
)

request = HttpRequest(raw_path="/api/v2/users")
result = matcher.evaluate(request)
assert result == "api_backend"  # First match wins
</code></pre>
<p>The path <code>/api/v2/users</code> matches both rules, but the first rule wins. The second rule is shadowed.</p>
<p><strong>Order matters.</strong> More specific rules must come first:</p>
<pre><code class="language-python"># Correct order: specific before general
matcher = Matcher(
    matcher_list=(
        FieldMatcher(
            predicate=SinglePredicate(PathInput(), PrefixMatcher("/api/v2")),
            on_match=Action("api_v2_backend")
        ),
        FieldMatcher(
            predicate=SinglePredicate(PathInput(), PrefixMatcher("/api")),
            on_match=Action("api_backend")
        ),
    )
)

request = HttpRequest(raw_path="/api/v2/users")
result = matcher.evaluate(request)
assert result == "api_v2_backend"  # Correct!
</code></pre>
<h2 id="rule-2-onmatch-exclusivity"><a class="header" href="#rule-2-onmatch-exclusivity">Rule 2: OnMatch Exclusivity</a></h2>
<p>Each <code>OnMatch</code> is either an action (terminal) or a nested matcher (continue evaluation), never both.</p>
<pre><code class="language-python">from puma import Action, NestedMatcher

# Valid: action
on_match = Action("route_here")

# Valid: nested matcher
on_match = NestedMatcher(matcher=sub_matcher)

# Invalid: can't have both
# (Not representable in the type system)
</code></pre>
<p>The type system enforces this. You canâ€™t accidentally create an <code>OnMatch</code> that does both. This prevents ambiguity: when a predicate matches, the outcome is clear.</p>
<p><strong>Rust makes this explicit with an enum:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum OnMatch&lt;Ctx, A&gt; {
    Action(A),
    Matcher(Box&lt;Matcher&lt;Ctx, A&gt;&gt;),
}
<span class="boring">}</span></code></pre>
<p><strong>Python uses a union type:</strong></p>
<pre><code class="language-python">type OnMatch[Ctx, A] = Action[A] | NestedMatcher[Ctx, A]
</code></pre>
<p>Same constraint, different syntax. Illegal states are unrepresentable.</p>
<h2 id="rule-3-nested-matcher-failure-propagation"><a class="header" href="#rule-3-nested-matcher-failure-propagation">Rule 3: Nested Matcher Failure Propagation</a></h2>
<p>If a nested matcher returns <code>None</code>, evaluation continues to the next field matcher. There is no implicit fallback to <code>on_no_match</code>.</p>
<pre><code class="language-python">from puma import Matcher, FieldMatcher, NestedMatcher, SinglePredicate, ExactMatcher, Action
from puma.http import HttpRequest, MethodInput, PathInput

# Nested matcher that only matches POST
nested = Matcher(
    matcher_list=(
        FieldMatcher(
            predicate=SinglePredicate(MethodInput(), ExactMatcher("POST")),
            on_match=Action("create_resource")
        ),
    ),
    on_no_match=None  # No fallback!
)

# Parent matcher
matcher = Matcher(
    matcher_list=(
        FieldMatcher(
            predicate=SinglePredicate(PathInput(), PrefixMatcher("/api")),
            on_match=NestedMatcher(nested)  # Continue into nested matcher
        ),
        FieldMatcher(
            predicate=SinglePredicate(PathInput(), PrefixMatcher("/health")),
            on_match=Action("health_check")
        ),
    )
)

# GET /api â†’ nested matcher evaluates, returns None, parent continues to next rule
request = HttpRequest(method="GET", raw_path="/api/users")
result = matcher.evaluate(request)
assert result == None  # /health doesn't match, no fallback

# GET /health â†’ second rule matches
request = HttpRequest(method="GET", raw_path="/health")
result = matcher.evaluate(request)
assert result == "health_check"
</code></pre>
<p><strong>Common mistake:</strong> Expecting nested matcher failure to use the parentâ€™s <code>on_no_match</code>. It doesnâ€™t. Nested failure means â€œthis branch didnâ€™t match, try the next field matcher.â€</p>
<h2 id="rule-4-on_no_match-fallback"><a class="header" href="#rule-4-on_no_match-fallback">Rule 4: on_no_match Fallback</a></h2>
<p>If no predicate matches, the matcher consults <code>on_no_match</code>. If absent, the matcher returns <code>None</code>.</p>
<pre><code class="language-python">from puma import Matcher, FieldMatcher, SinglePredicate, PrefixMatcher, Action
from puma.http import HttpRequest, PathInput

# With fallback
matcher = Matcher(
    matcher_list=(
        FieldMatcher(
            predicate=SinglePredicate(PathInput(), PrefixMatcher("/api")),
            on_match=Action("api_backend")
        ),
    ),
    on_no_match=Action("default_backend")  # Fallback for non-matches
)

request = HttpRequest(raw_path="/other")
result = matcher.evaluate(request)
assert result == "default_backend"

# Without fallback
matcher = Matcher(
    matcher_list=(
        FieldMatcher(
            predicate=SinglePredicate(PathInput(), PrefixMatcher("/api")),
            on_match=Action("api_backend")
        ),
    ),
    on_no_match=None  # No fallback
)

request = HttpRequest(raw_path="/other")
result = matcher.evaluate(request)
assert result == None
</code></pre>
<p><code>on_no_match</code> applies only when no predicate in <code>matcher_list</code> matches. It doesnâ€™t apply when a nested matcher fails (Rule 3).</p>
<h2 id="rule-5-none--false-invariant"><a class="header" href="#rule-5-none--false-invariant">Rule 5: None â†’ False Invariant</a></h2>
<p>If a <code>DataInput</code> returns <code>None</code>, the predicate evaluates to <code>False</code> without calling the matcher.</p>
<pre><code class="language-python">from puma import SinglePredicate, ExactMatcher
from puma.http import HttpRequest, HeaderInput

predicate = SinglePredicate(
    input=HeaderInput("x-api-key"),
    matcher=ExactMatcher("secret")
)

# Header not present â†’ input returns None â†’ predicate returns False
request = HttpRequest(headers={})
assert predicate.evaluate(request) == False

# Header present â†’ input returns str â†’ predicate evaluates normally
request = HttpRequest(headers={"x-api-key": "wrong"})
assert predicate.evaluate(request) == False

request = HttpRequest(headers={"x-api-key": "secret"})
assert predicate.evaluate(request) == True
</code></pre>
<p>This simplifies matcher implementations. They only handle present values. Missing values are handled upstream by the predicate.</p>
<h2 id="rule-6-depth-validation"><a class="header" href="#rule-6-depth-validation">Rule 6: Depth Validation</a></h2>
<p>Matcher trees exceeding <code>MAX_DEPTH</code> (32 levels) are rejected at construction time.</p>
<pre><code class="language-python">from puma import Matcher, FieldMatcher, NestedMatcher, SinglePredicate, ExactMatcher, Action, MatcherError
from puma.http import HttpRequest, PathInput

# Build a deeply nested matcher
def build_nested(depth):
    if depth == 0:
        return Matcher(
            matcher_list=(
                FieldMatcher(
                    predicate=SinglePredicate(PathInput(), ExactMatcher("/deep")),
                    on_match=Action("leaf")
                ),
            )
        )
    return Matcher(
        matcher_list=(
            FieldMatcher(
                predicate=SinglePredicate(PathInput(), ExactMatcher("/")),
                on_match=NestedMatcher(build_nested(depth - 1))
            ),
        )
    )

# Depth 32 is ok
matcher = build_nested(31)  # 32 levels total
assert matcher.depth() == 32

# Depth 33 raises error
try:
    matcher = build_nested(32)  # 33 levels total
    assert False, "Should have raised MatcherError"
except MatcherError as e:
    assert "depth exceeds MAX_DEPTH" in str(e)
</code></pre>
<p>Validation happens in <code>__post_init__</code> (Python) or constructor (Rust). You canâ€™t accidentally create invalid trees.</p>
<p><strong>Why 32?</strong> Balance between flexibility and safety. Deep nesting risks stack overflow (when iterative evaluation is deferred) and signals overly complex config. Most real-world matchers use 3-5 levels.</p>
<h2 id="evaluation-example"><a class="header" href="#evaluation-example">Evaluation Example</a></h2>
<p>Combine all rules in one matcher:</p>
<pre><code class="language-python">from puma import Matcher, FieldMatcher, NestedMatcher, SinglePredicate, And, PrefixMatcher, ExactMatcher, Action
from puma.http import HttpRequest, PathInput, MethodInput, HeaderInput

# Nested matcher: POST with auth header
auth_required = Matcher(
    matcher_list=(
        FieldMatcher(
            predicate=And((
                SinglePredicate(MethodInput(), ExactMatcher("POST")),
                SinglePredicate(HeaderInput("authorization"), PrefixMatcher("Bearer ")),
            )),
            on_match=Action("authenticated_api")
        ),
    ),
    on_no_match=None  # Fail if not POST with auth
)

# Top-level matcher
matcher = Matcher(
    matcher_list=(
        FieldMatcher(
            predicate=SinglePredicate(PathInput(), PrefixMatcher("/api")),
            on_match=NestedMatcher(auth_required)  # Nested evaluation
        ),
        FieldMatcher(
            predicate=SinglePredicate(PathInput(), PrefixMatcher("/health")),
            on_match=Action("health_check")
        ),
    ),
    on_no_match=Action("not_found")  # Fallback
)

# Test cases
# 1. POST /api with auth â†’ nested matches
request = HttpRequest(method="POST", raw_path="/api/users", headers={"authorization": "Bearer token"})
assert matcher.evaluate(request) == "authenticated_api"

# 2. GET /api â†’ nested fails (not POST), continues to next field matcher, then fallback
request = HttpRequest(method="GET", raw_path="/api/users")
assert matcher.evaluate(request) == "not_found"

# 3. GET /health â†’ second rule matches
request = HttpRequest(method="GET", raw_path="/health")
assert matcher.evaluate(request) == "health_check"

# 4. GET /other â†’ no match, uses fallback
request = HttpRequest(method="GET", raw_path="/other")
assert matcher.evaluate(request) == "not_found"
</code></pre>
<p>Walk through case 2:</p>
<ol>
<li>First field matcher: path matches <code>/api</code> â†’ predicate is <code>True</code></li>
<li>OnMatch is nested matcher â†’ evaluate <code>auth_required</code></li>
<li>Nested matcher: method is GET (not POST) â†’ predicate is <code>False</code></li>
<li>Nested matcher returns <code>None</code> (Rule 4: no <code>on_no_match</code>)</li>
<li>Nested failure propagates (Rule 3) â†’ continue to next field matcher</li>
<li>Second field matcher: path doesnâ€™t match <code>/health</code> â†’ predicate is <code>False</code></li>
<li>No more field matchers â†’ use <code>on_no_match</code> (Rule 4)</li>
<li>Return <code>"not_found"</code></li>
</ol>
<h2 id="next-steps-7"><a class="header" href="#next-steps-7">Next Steps</a></h2>
<ul>
<li><a href="#the-matching-pipeline">The Matching Pipeline</a> â€” Where evaluation fits in the flow</li>
<li><a href="#predicate-composition">Predicate Composition</a> â€” Building the conditions that drive evaluation</li>
<li><a href="#build-an-http-router">Build an HTTP Router</a> â€” Apply these semantics to real routing</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="adding-a-domain"><a class="header" href="#adding-a-domain">Adding a Domain</a></h1>
<p>Create domain-specific matchers for HTTP, gRPC, CloudEvents, or your custom protocol.</p>
<p>A â€œdomainâ€ in x.uma is a context type with associated <code>DataInput</code> implementations and a compiler that turns config into matchers.</p>
<p><strong>Every domain ships four things:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Deliverable</th><th>What</th><th>Example (HTTP)</th></tr>
</thead>
<tbody>
<tr><td><strong>Context type</strong></td><td>The runtime data structure</td><td><code>HttpRequest</code>, <code>HttpMessage</code></td></tr>
<tr><td><strong>DataInputs</strong></td><td>Extract fields from context</td><td><code>PathInput</code>, <code>HeaderInput</code></td></tr>
<tr><td><strong>Config types</strong></td><td>User-friendly match specification</td><td><code>HttpRouteMatch</code>, <code>HttpPathMatch</code></td></tr>
<tr><td><strong>Compiler</strong></td><td>Config â†’ Matcher tree</td><td><code>compile_route_matches()</code></td></tr>
</tbody>
</table>
</div>
<p>The compiler is the user-facing API. Without it, users must construct matcher trees by hand.</p>
<p>This guide shows how to add a domain in Rust (rumi), Python (puma), and TypeScript (bumi).</p>
<h2 id="concept-cloudevent-matching"><a class="header" href="#concept-cloudevent-matching">Concept: CloudEvent Matching</a></h2>
<p>Weâ€™ll build a matcher for <a href="https://cloudevents.io/">CloudEvents</a> â€” a CNCF spec for event metadata.</p>
<pre><code class="language-json">{
  "specversion": "1.0",
  "type": "com.example.user.created",
  "source": "api-server",
  "id": "abc-123",
  "subject": "user/42"
}
</code></pre>
<p><strong>Goal:</strong> Match events by type, source, or subject.</p>
<h2 id="python-implementation-puma"><a class="header" href="#python-implementation-puma">Python Implementation (puma)</a></h2>
<h3 id="step-1-define-the-context-type"><a class="header" href="#step-1-define-the-context-type">Step 1: Define the Context Type</a></h3>
<pre><code class="language-python"># my_events.py
from dataclasses import dataclass

@dataclass(frozen=True, slots=True)
class CloudEvent:
    """CloudEvents v1.0 context."""
    type: str
    source: str
    id: str
    subject: str | None = None
</code></pre>
<h3 id="step-2-implement-datainput"><a class="header" href="#step-2-implement-datainput">Step 2: Implement DataInput</a></h3>
<pre><code class="language-python">from puma import DataInput, MatchingValue

@dataclass(frozen=True, slots=True)
class EventTypeInput:
    """Extract event type."""
    def get(self, ctx: CloudEvent, /) -&gt; MatchingValue:
        return ctx.type

@dataclass(frozen=True, slots=True)
class EventSourceInput:
    """Extract event source."""
    def get(self, ctx: CloudEvent, /) -&gt; MatchingValue:
        return ctx.source

@dataclass(frozen=True, slots=True)
class EventSubjectInput:
    """Extract event subject (may be None)."""
    def get(self, ctx: CloudEvent, /) -&gt; MatchingValue:
        return ctx.subject  # None triggers None â†’ false invariant
</code></pre>
<h3 id="step-3-build-matchers"><a class="header" href="#step-3-build-matchers">Step 3: Build Matchers</a></h3>
<pre><code class="language-python">from puma import (
    Matcher, FieldMatcher, SinglePredicate, Action,
    ExactMatcher, PrefixMatcher, And,
)

# Match user creation events from api-server
user_created_matcher = Matcher(
    matcher_list=(
        FieldMatcher(
            predicate=And((
                SinglePredicate(
                    EventTypeInput(),
                    PrefixMatcher("com.example.user.")
                ),
                SinglePredicate(
                    EventSourceInput(),
                    ExactMatcher("api-server")
                ),
            )),
            on_match=Action("handle_user_event"),
        ),
    ),
    on_no_match=Action("ignore"),
)

# Evaluate
event = CloudEvent(
    type="com.example.user.created",
    source="api-server",
    id="abc-123",
)
action = user_created_matcher.evaluate(event)
assert action == "handle_user_event"
</code></pre>
<h3 id="step-4-add-a-compiler-user-facing-api"><a class="header" href="#step-4-add-a-compiler-user-facing-api">Step 4: Add a Compiler (User-Facing API)</a></h3>
<p>The compiler is the user-facing API for your domain. Every x.uma domain ships one:</p>
<ul>
<li>HTTP: <code>compile_route_matches()</code> turns <code>HttpRouteMatch</code> config into a <code>Matcher</code></li>
<li>Claude: <code>compile_hook_matches()</code> turns <code>HookMatch</code> config into a <code>Matcher</code></li>
</ul>
<p>Without a compiler, users must construct matcher trees by hand. The compiler is what makes a domain usable.</p>
<pre><code class="language-python">from dataclasses import dataclass, field
from typing import Literal
from puma import Predicate, SinglePredicate, ExactMatcher, PrefixMatcher, Matcher, FieldMatcher, Action

@dataclass(frozen=True, slots=True)
class EventMatch:
    """Config-time event match specification."""
    type: str | None = None
    source: str | None = None
    subject: str | None = None

    def to_predicate(self) -&gt; Predicate[CloudEvent]:
        """Compile to predicate tree."""
        predicates: list[SinglePredicate[CloudEvent]] = []

        if self.type is not None:
            predicates.append(
                SinglePredicate(EventTypeInput(), ExactMatcher(self.type))
            )
        if self.source is not None:
            predicates.append(
                SinglePredicate(EventSourceInput(), ExactMatcher(self.source))
            )
        if self.subject is not None:
            predicates.append(
                SinglePredicate(EventSubjectInput(), ExactMatcher(self.subject))
            )

        if not predicates:
            # Match everything
            return SinglePredicate(EventTypeInput(), PrefixMatcher(""))

        if len(predicates) == 1:
            return predicates[0]

        return And(tuple(predicates))

    def compile[A](self, action: A) -&gt; Matcher[CloudEvent, A]:
        """Compile to matcher."""
        return Matcher(
            matcher_list=(FieldMatcher(self.to_predicate(), Action(action)),),
        )

# Usage
match_config = EventMatch(type="com.example.user.created", source="api-server")
matcher = match_config.compile("handle_user_event")
</code></pre>
<p>Thatâ€™s it. The same string matchers, predicates, and matcher tree logic work for CloudEvents.</p>
<h2 id="rust-implementation-rumi"><a class="header" href="#rust-implementation-rumi">Rust Implementation (rumi)</a></h2>
<h3 id="step-1-define-proto-optional"><a class="header" href="#step-1-define-proto-optional">Step 1: Define Proto (Optional)</a></h3>
<p>If using xDS proto extension mechanism:</p>
<pre><code class="language-protobuf">// proto/xuma/events/v1/inputs.proto
syntax = "proto3";
package xuma.events.v1;

message EventTypeInput {}
message EventSourceInput {}
message EventSubjectInput {}
</code></pre>
<p>Generate Rust bindings:</p>
<pre><code class="language-bash">just gen
</code></pre>
<h3 id="step-2-define-the-context-type"><a class="header" href="#step-2-define-the-context-type">Step 2: Define the Context Type</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// rumi/ext/events/src/lib.rs
use std::collections::HashMap;

#[derive(Debug, Clone)]
pub struct CloudEvent {
    pub event_type: String,
    pub source: String,
    pub id: String,
    pub subject: Option&lt;String&gt;,
}
<span class="boring">}</span></code></pre>
<h3 id="step-3-implement-datainput"><a class="header" href="#step-3-implement-datainput">Step 3: Implement DataInput</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rumi::{DataInput, MatchingData};

#[derive(Debug)]
pub struct EventTypeInput;

impl DataInput&lt;CloudEvent&gt; for EventTypeInput {
    fn get(&amp;self, ctx: &amp;CloudEvent) -&gt; MatchingData {
        MatchingData::String(ctx.event_type.clone())
    }
}

#[derive(Debug)]
pub struct EventSourceInput;

impl DataInput&lt;CloudEvent&gt; for EventSourceInput {
    fn get(&amp;self, ctx: &amp;CloudEvent) -&gt; MatchingData {
        MatchingData::String(ctx.source.clone())
    }
}

#[derive(Debug)]
pub struct EventSubjectInput;

impl DataInput&lt;CloudEvent&gt; for EventSubjectInput {
    fn get(&amp;self, ctx: &amp;CloudEvent) -&gt; MatchingData {
        ctx.subject
            .as_ref()
            .map(|s| MatchingData::String(s.clone()))
            .unwrap_or(MatchingData::None)
    }
}
<span class="boring">}</span></code></pre>
<h3 id="step-4-build-matchers"><a class="header" href="#step-4-build-matchers">Step 4: Build Matchers</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rumi::prelude::*;

// Match user creation events from api-server
let user_created_matcher = Matcher::new(
    vec![
        FieldMatcher::new(
            Predicate::And {
                predicates: vec![
                    Predicate::Single(SinglePredicate::new(
                        Box::new(EventTypeInput),
                        Box::new(PrefixMatcher::new("com.example.user.")),
                    )),
                    Predicate::Single(SinglePredicate::new(
                        Box::new(EventSourceInput),
                        Box::new(ExactMatcher::new("api-server")),
                    )),
                ],
            },
            OnMatch::Action("handle_user_event"),
        ),
    ],
    Some(OnMatch::Action("ignore")),
)?;

// Evaluate
let event = CloudEvent {
    event_type: "com.example.user.created".into(),
    source: "api-server".into(),
    id: "abc-123".into(),
    subject: None,
};

let action = user_created_matcher.evaluate(&amp;event);
assert_eq!(action, Some("handle_user_event"));
<span class="boring">}</span></code></pre>
<h3 id="step-5-add-a-compiler-user-facing-api"><a class="header" href="#step-5-add-a-compiler-user-facing-api">Step 5: Add a Compiler (User-Facing API)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone)]
pub struct EventMatch {
    pub event_type: Option&lt;String&gt;,
    pub source: Option&lt;String&gt;,
    pub subject: Option&lt;String&gt;,
}

impl EventMatch {
    pub fn compile&lt;A&gt;(self, action: A) -&gt; Result&lt;Matcher&lt;CloudEvent, A&gt;, MatcherError&gt;
    where
        A: Clone,
    {
        let predicate = self.to_predicate();
        Matcher::new(
            vec![FieldMatcher::new(predicate, OnMatch::Action(action))],
            None,
        )
    }

    fn to_predicate(&amp;self) -&gt; Predicate&lt;CloudEvent&gt; {
        let mut predicates = Vec::new();

        if let Some(ref t) = self.event_type {
            predicates.push(Predicate::Single(SinglePredicate::new(
                Box::new(EventTypeInput),
                Box::new(ExactMatcher::new(t)),
            )));
        }
        if let Some(ref s) = self.source {
            predicates.push(Predicate::Single(SinglePredicate::new(
                Box::new(EventSourceInput),
                Box::new(ExactMatcher::new(s)),
            )));
        }
        if let Some(ref subj) = self.subject {
            predicates.push(Predicate::Single(SinglePredicate::new(
                Box::new(EventSubjectInput),
                Box::new(ExactMatcher::new(subj)),
            )));
        }

        if predicates.is_empty() {
            // Match everything
            Predicate::Single(SinglePredicate::new(
                Box::new(EventTypeInput),
                Box::new(PrefixMatcher::new("")),
            ))
        } else if predicates.len() == 1 {
            predicates.into_iter().next().unwrap()
        } else {
            Predicate::And { predicates }
        }
    }
}

// Usage
let match_config = EventMatch {
    event_type: Some("com.example.user.created".into()),
    source: Some("api-server".into()),
    subject: None,
};
let matcher = match_config.compile("handle_user_event")?;
<span class="boring">}</span></code></pre>
<h2 id="typescript-implementation-bumi"><a class="header" href="#typescript-implementation-bumi">TypeScript Implementation (bumi)</a></h2>
<p>The same pattern applies in TypeScript. Classes with <code>readonly</code> fields replace dataclasses.</p>
<h3 id="steps-1-3-context-datainputs-and-matchers"><a class="header" href="#steps-1-3-context-datainputs-and-matchers">Steps 1-3: Context, DataInputs, and Matchers</a></h3>
<pre><code class="language-typescript">import {
    Matcher, FieldMatcher, SinglePredicate, And, Action,
    ExactMatcher, PrefixMatcher,
    type DataInput, type MatchingData,
} from "bumi";

// Step 1: Context type
class CloudEvent {
    constructor(
        readonly type: string,
        readonly source: string,
        readonly id: string,
        readonly subject: string | null = null,
    ) {}
}

// Step 2: DataInputs
class EventTypeInput implements DataInput&lt;CloudEvent&gt; {
    get(ctx: CloudEvent): MatchingData { return ctx.type; }
}

class EventSourceInput implements DataInput&lt;CloudEvent&gt; {
    get(ctx: CloudEvent): MatchingData { return ctx.source; }
}

class EventSubjectInput implements DataInput&lt;CloudEvent&gt; {
    get(ctx: CloudEvent): MatchingData { return ctx.subject; }  // null â†’ false invariant
}

// Step 3: Build matchers
const matcher = new Matcher([
    new FieldMatcher(
        new And([
            new SinglePredicate(new EventTypeInput(), new PrefixMatcher("com.example.user.")),
            new SinglePredicate(new EventSourceInput(), new ExactMatcher("api-server")),
        ]),
        new Action("handle_user_event"),
    ),
], new Action("ignore"));
</code></pre>
<h3 id="steps-4-5-config-types-and-compiler"><a class="header" href="#steps-4-5-config-types-and-compiler">Steps 4-5: Config Types and Compiler</a></h3>
<pre><code class="language-typescript">import { Matcher, FieldMatcher, SinglePredicate, And, Action, ExactMatcher, PrefixMatcher } from "bumi";
import type { Predicate } from "bumi";

interface EventMatch {
    readonly type?: string;
    readonly source?: string;
    readonly subject?: string;
}

function compileEventMatch&lt;A&gt;(config: EventMatch, action: A): Matcher&lt;CloudEvent, A&gt; {
    const predicates: Predicate&lt;CloudEvent&gt;[] = [];

    if (config.type !== undefined) {
        predicates.push(new SinglePredicate(new EventTypeInput(), new ExactMatcher(config.type)));
    }
    if (config.source !== undefined) {
        predicates.push(new SinglePredicate(new EventSourceInput(), new ExactMatcher(config.source)));
    }
    if (config.subject !== undefined) {
        predicates.push(new SinglePredicate(new EventSubjectInput(), new ExactMatcher(config.subject)));
    }

    const predicate = predicates.length === 0
        ? new SinglePredicate(new EventTypeInput(), new PrefixMatcher(""))
        : predicates.length === 1
            ? predicates[0]
            : new And(predicates);

    return new Matcher([new FieldMatcher(predicate, new Action(action))]);
}

// Usage
const matcher = compileEventMatch(
    { type: "com.example.user.created", source: "api-server" },
    "handle_user_event",
);
</code></pre>
<h2 id="add-conformance-tests"><a class="header" href="#add-conformance-tests">Add Conformance Tests</a></h2>
<p>All three implementations should pass the same test fixtures.</p>
<pre><code class="language-yaml"># spec/tests/events/type_exact.yaml
name: "CloudEvent type exact match"
context:
  type: "com.example.user.created"
  source: "api-server"
  id: "abc-123"
cases:
  - description: "matches event type"
    matcher:
      input: { event_type: {} }
      matcher: { exact: "com.example.user.created" }
    expected: { matches: true }

  - description: "rejects wrong type"
    matcher:
      input: { event_type: {} }
      matcher: { exact: "com.example.order.created" }
    expected: { matches: false }
</code></pre>
<p><strong>Test runners:</strong></p>
<ul>
<li>Rust: Parse YAML, construct <code>CloudEvent</code> and <code>Matcher&lt;CloudEvent, _&gt;</code>, assert</li>
<li>Python: Parse YAML, construct <code>CloudEvent</code> and <code>Matcher[CloudEvent, _]</code>, assert</li>
<li>TypeScript: Parse YAML, construct <code>CloudEvent</code> and <code>Matcher&lt;CloudEvent, _&gt;</code>, assert</li>
</ul>
<h2 id="key-patterns"><a class="header" href="#key-patterns">Key Patterns</a></h2>
<h3 id="none-handling"><a class="header" href="#none-handling">None Handling</a></h3>
<p>When a <code>DataInput</code> returns <code>None</code>/<code>null</code>, the predicate evaluates to <code>false</code> without consulting the matcher. This is the <strong>null â†’ false invariant</strong>.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust â€” return MatchingData::None
impl DataInput&lt;CloudEvent&gt; for EventSubjectInput {
    fn get(&amp;self, ctx: &amp;CloudEvent) -&gt; MatchingData {
        ctx.subject
            .as_ref()
            .map(|s| MatchingData::String(s.clone()))
            .unwrap_or(MatchingData::None)  // Triggers null â†’ false
    }
}
<span class="boring">}</span></code></pre>
<pre><code class="language-python"># Python â€” return None
@dataclass(frozen=True, slots=True)
class EventSubjectInput:
    def get(self, ctx: CloudEvent, /) -&gt; MatchingValue:
        return ctx.subject  # None triggers null â†’ false
</code></pre>
<pre><code class="language-typescript">// TypeScript â€” return null
class EventSubjectInput implements DataInput&lt;CloudEvent&gt; {
    get(ctx: CloudEvent): MatchingData { return ctx.subject; }  // null triggers null â†’ false
}
</code></pre>
<h3 id="immutability"><a class="header" href="#immutability">Immutability</a></h3>
<p>All context types should be immutable:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Language</th><th>Pattern</th></tr>
</thead>
<tbody>
<tr><td>Rust</td><td>Donâ€™t provide <code>&amp;mut</code> access, clone when needed</td></tr>
<tr><td>Python</td><td><code>@dataclass(frozen=True)</code></td></tr>
<tr><td>TypeScript</td><td><code>readonly</code> fields</td></tr>
</tbody>
</table>
</div>
<h3 id="type-safety"><a class="header" href="#type-safety">Type Safety</a></h3>
<p>The compiler ensures:</p>
<ul>
<li><code>DataInput&lt;CloudEvent&gt;</code> can only be used with <code>Matcher&lt;CloudEvent, A&gt;</code></li>
<li>You canâ€™t accidentally mix HTTP and CloudEvent inputs in the same matcher</li>
<li><code>OnMatch</code> is exclusive â€” action XOR nested matcher, never both</li>
</ul>
<h2 id="see-also"><a class="header" href="#see-also">See Also</a></h2>
<ul>
<li><a href="#rust-api-reference">Rust API Reference</a> â€” rumi types</li>
<li><a href="#python-api-reference">Python API Reference</a> â€” puma types</li>
<li><a href="#typescript-api-reference">TypeScript API Reference</a> â€” bumi types</li>
<li><a href="#http-domain-reference">HTTP Domain</a> â€” Real-world example</li>
<li><a href="#architecture-1">Architecture</a> â€” Type system deep dive</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="performance-guide"><a class="header" href="#performance-guide">Performance Guide</a></h1>
<p>Which x.uma variant is fastest? It depends on your workload.</p>
<p>The TypeScript implementation (bumi) evaluates an exact string match in 9.3 nanoseconds. The Rust implementation (rumi) takes 33 nanoseconds for the same operation â€” 3.5x slower. Yet for adversarial regex input at N=20, Rust takes 11 nanoseconds while TypeScript takes 11 milliseconds. Thatâ€™s 1 million times faster.</p>
<p>This guide helps you choose the right variant for your performance requirements and security constraints.</p>
<h2 id="the-variants"><a class="header" href="#the-variants">The Variants</a></h2>
<p>x.uma implements the xDS Unified Matcher API in five ways:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Variant</th><th>Language</th><th>When to use</th></tr>
</thead>
<tbody>
<tr><td><strong>rumi</strong></td><td>Rust (native)</td><td>High-throughput routing, untrusted regex, production proxies</td></tr>
<tr><td><strong>puma</strong></td><td>Python (pure)</td><td>Web frameworks, dev ergonomics, trusted patterns</td></tr>
<tr><td><strong>bumi</strong></td><td>TypeScript (pure)</td><td>Edge workers, frontend routing, sub-microsecond latency</td></tr>
<tr><td><strong>puma-crusty</strong></td><td>Python + Rust FFI</td><td>ReDoS protection in Python without full rewrite</td></tr>
<tr><td><strong>bumi-crusty</strong></td><td>TypeScript + WASM</td><td>ReDoS protection in TypeScript (100x slower, use sparingly)</td></tr>
</tbody>
</table>
</div>
<p>All five variants pass the same 194-test conformance suite. They implement identical behavior with different performance characteristics.</p>
<h2 id="decision-matrix"><a class="header" href="#decision-matrix">Decision Matrix</a></h2>
<h3 id="use-rumi-rust-when"><a class="header" href="#use-rumi-rust-when">Use <strong>rumi</strong> (Rust) when</a></h3>
<ul>
<li><strong>Building infrastructure</strong> â€” proxies, load balancers, API gateways where throughput per core matters</li>
<li><strong>Untrusted regex</strong> â€” patterns come from configuration files, user input, or external sources</li>
<li><strong>Maximum throughput</strong> â€” need to handle 100k+ requests per second per core</li>
<li><strong>Already in Rust</strong> â€” integrating with existing Rust services</li>
</ul>
<p><strong>Performance</strong>: 33ns for exact match, 52ns for regex match, 1.8Âµs for 100 rules. Linear-time regex with zero ReDoS risk.</p>
<h3 id="use-puma-python-when"><a class="header" href="#use-puma-python-when">Use <strong>puma</strong> (Python) when</a></h3>
<ul>
<li><strong>Python ecosystem</strong> â€” integrating with FastAPI, Flask, Django, or Python ETL pipelines</li>
<li><strong>Dev speed matters</strong> â€” prototype quickly, optimize later if needed</li>
<li><strong>Trusted patterns</strong> â€” you control all regex patterns (no user input)</li>
<li><strong>50k req/sec is enough</strong> â€” Pythonâ€™s interpreter tax is acceptable for your load</li>
</ul>
<p><strong>Performance</strong>: 325ns for exact match, 452ns for regex match, 10.1Âµs for 100 rules. Backtracking regex vulnerable to ReDoS on adversarial input.</p>
<h3 id="use-bumi-typescript-when"><a class="header" href="#use-bumi-typescript-when">Use <strong>bumi</strong> (TypeScript) when</a></h3>
<ul>
<li><strong>Edge deployment</strong> â€” Cloudflare Workers, Deno Deploy, or frontend routing</li>
<li><strong>Sub-microsecond latency</strong> â€” need single-digit nanosecond overhead</li>
<li><strong>Trusted patterns</strong> â€” you control all regex patterns (no user input)</li>
<li><strong>TypeScript integration</strong> â€” leveraging existing TS tooling and type safety</li>
</ul>
<p><strong>Performance</strong>: 9.3ns for exact match, 24.8ns for regex match, 1.07Âµs for 100 rules. Fastest for simple operations. Backtracking regex vulnerable to ReDoS.</p>
<h3 id="use-puma-crusty-python--rust-ffi-when"><a class="header" href="#use-puma-crusty-python--rust-ffi-when">Use <strong>puma-crusty</strong> (Python + Rust FFI) when</a></h3>
<ul>
<li><strong>ReDoS is a threat</strong> â€” regex patterns come from untrusted sources</li>
<li><strong>Python codebase</strong> â€” canâ€™t rewrite everything in Rust</li>
<li><strong>Regex-heavy</strong> â€” matching logic dominates request processing time</li>
<li><strong>Native deps OK</strong> â€” deployment can handle binary wheels</li>
</ul>
<p><strong>Performance</strong>: 1.3-1.6x faster than pure Python for evaluation. 2.9x faster for simple config compilation. Zero ReDoS risk.</p>
<p><strong>Trade-off</strong>: FFI overhead minimal (PyO3 is highly optimized), but adds native dependency to your deployment.</p>
<h3 id="avoid-bumi-crusty-typescript--wasm-unless"><a class="header" href="#avoid-bumi-crusty-typescript--wasm-unless">Avoid <strong>bumi-crusty</strong> (TypeScript + WASM) unless</a></h3>
<ul>
<li><strong>Must have linear-time regex</strong> â€” ReDoS is critical threat model</li>
<li><strong>TypeScript required</strong> â€” canâ€™t switch to rumi or puma-crusty</li>
<li><strong>Low request rate</strong> â€” can tolerate 100x slowdown (2-3Âµs per match)</li>
<li><strong>Security &gt; speed</strong> â€” preventing denial-of-service is worth the cost</li>
</ul>
<p><strong>Performance</strong>: 30-450x slower than pure TypeScript across all operations. WASM boundary serialization overhead dominates.</p>
<p><strong>Use case</strong>: Edge workers matching untrusted regex where a single malicious request could hang the isolate. Not for general use.</p>
<h2 id="throughput-summary"><a class="header" href="#throughput-summary">Throughput Summary</a></h2>
<p>Operations per second on a single core (M1 Max):</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Variant</th><th>Exact Match</th><th>Regex Match</th><th>100 Rules</th></tr>
</thead>
<tbody>
<tr><td>rumi</td><td>30M ops/sec</td><td>19M ops/sec</td><td>555k ops/sec</td></tr>
<tr><td>bumi</td><td>107M ops/sec</td><td>40M ops/sec</td><td>934k ops/sec</td></tr>
<tr><td>puma</td><td>3M ops/sec</td><td>2.2M ops/sec</td><td>99k ops/sec</td></tr>
<tr><td>puma-crusty</td><td>5.3M ops/sec</td><td>3.3M ops/sec</td><td>1.75M ops/sec</td></tr>
<tr><td>bumi-crusty</td><td>613k ops/sec</td><td>469k ops/sec</td><td>408k ops/sec</td></tr>
</tbody>
</table>
</div>
<p>For HTTP routing in a web framework, even the â€œslowâ€ Python variant handles 50,000 requests per second per core. This is not a bottleneck for most applications.</p>
<p>The real differentiator is ReDoS protection.</p>
<h2 id="redos-the-security-boundary"><a class="header" href="#redos-the-security-boundary">ReDoS: The Security Boundary</a></h2>
<p>At N=20 characters, a malicious regex input causes:</p>
<ul>
<li><strong>rumi</strong>: 11 nanoseconds (linear time)</li>
<li><strong>puma</strong>: 72 milliseconds (6.5 million times slower)</li>
<li><strong>bumi</strong>: 11 milliseconds (1 million times slower)</li>
</ul>
<p>At N=25, both puma and bumi hang indefinitely. A single malicious request ties up a worker thread forever.</p>
<p>This is why rumi mandates the Rust <code>regex</code> crate with linear-time guarantees. The arch-guild review marked this as non-negotiable: <strong>ReDoS protection is a security requirement, not a performance optimization.</strong></p>
<p>See <a href="#redos-protection-1">ReDoS Protection</a> for the full technical deep dive and mitigation strategies.</p>
<h2 id="when-to-switch-variants"><a class="header" href="#when-to-switch-variants">When to Switch Variants</a></h2>
<p>Start with the variant that matches your ecosystem:</p>
<ul>
<li><strong>Rust project</strong> â†’ rumi</li>
<li><strong>Python project</strong> â†’ puma</li>
<li><strong>TypeScript project</strong> â†’ bumi</li>
</ul>
<p>Switch to a crusty variant if:</p>
<ol>
<li>Regex patterns come from untrusted sources (user input, external config)</li>
<li>An attacker could craft malicious patterns to exploit backtracking</li>
<li>You canâ€™t migrate the entire codebase to Rust</li>
</ol>
<p>The FFI overhead is minimal for Python (PyO3 is fast) but significant for TypeScript (WASM boundary is expensive). Measure before switching.</p>
<h2 id="future-phase-11-re2-migration"><a class="header" href="#future-phase-11-re2-migration">Future: Phase 11 (RE2 Migration)</a></h2>
<p>The roadmap includes migrating puma to <code>google-re2</code> (Python bindings to C++ RE2) and bumi to <code>re2js</code> (pure JS port of RE2).</p>
<p>This would provide linear-time regex without FFI overhead:</p>
<ul>
<li><strong>puma</strong>: ReDoS protection via mature C extension</li>
<li><strong>bumi</strong>: ReDoS protection in pure TypeScript</li>
</ul>
<p>At that point, the crusty variants shift from â€œsafety layerâ€ to â€œfull compiled pipelineâ€ for complex configs where the rumi compilerâ€™s optimizations justify the FFI cost.</p>
<p>Until then, use crusty for ReDoS protection or stick with pure implementations if patterns are trusted.</p>
<h2 id="benchmarking-your-workload"><a class="header" href="#benchmarking-your-workload">Benchmarking Your Workload</a></h2>
<p>The numbers in this guide come from micro-benchmarks on isolated operations. Your production performance depends on:</p>
<ul>
<li><strong>Network I/O</strong> â€” often dominates request latency</li>
<li><strong>Upstream latency</strong> â€” database, external APIs, other services</li>
<li><strong>Rule complexity</strong> â€” 10 rules vs 1000 rules changes the picture</li>
<li><strong>Match rate</strong> â€” first rule hits vs last rule hits vs no matches</li>
</ul>
<p>Run benchmarks on representative production configs before making architecture decisions.</p>
<p>All benchmarks use: <code>just bench-all</code></p>
<p>Full data and methodology: <a href="#benchmark-results">Benchmark Results</a></p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Workload</th><th>Recommendation</th></tr>
</thead>
<tbody>
<tr><td>High-throughput infrastructure</td><td>rumi</td></tr>
<tr><td>Python web frameworks (trusted patterns)</td><td>puma</td></tr>
<tr><td>Edge workers (trusted patterns)</td><td>bumi</td></tr>
<tr><td>Python + untrusted regex</td><td>puma-crusty</td></tr>
<tr><td>TypeScript + untrusted regex (rare)</td><td>bumi-crusty</td></tr>
<tr><td>Any + adversarial regex</td><td>rumi or crusty variant</td></tr>
</tbody>
</table>
</div>
<p>The fastest variant is the one that matches your ecosystem and security requirements. Start there, measure, then optimize if needed.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="benchmark-results"><a class="header" href="#benchmark-results">Benchmark Results</a></h1>
<p>Performance analysis of x.uma matcher engine implementations.</p>
<p>This page presents the full benchmark data collected across all five x.uma variants. The story unfolds progressively: simple operations show unexpected results, complex workloads reveal architectural trade-offs, and adversarial input exposes catastrophic failure modes.</p>
<p>All variants passed the same 194-test conformance suite before benchmarking. These arenâ€™t apples-to-oranges comparisons â€” theyâ€™re different implementations of identical behavior.</p>
<h2 id="hardware--methodology"><a class="header" href="#hardware--methodology">Hardware &amp; Methodology</a></h2>
<p><strong>Hardware</strong>: Apple M1 Max (10-core CPU, 64GB RAM)
<strong>Date</strong>: 2026-02-10
<strong>Operating System</strong>: macOS 14.4</p>
<p><strong>Benchmarking Tools</strong>:</p>
<ul>
<li>Rust (rumi): divan 0.1.14</li>
<li>Python (puma): pytest-benchmark 4.0.0</li>
<li>TypeScript (bumi): mitata 1.0.10</li>
</ul>
<p><strong>Execution</strong>:</p>
<pre><code class="language-bash">just bench-all  # runs all benchmarks
</code></pre>
<p>Each benchmark runs for at least 100 iterations to ensure statistical significance. Results show median latency unless otherwise noted.</p>
<h2 id="the-variants-1"><a class="header" href="#the-variants-1">The Variants</a></h2>
<p>x.uma implements the xDS Unified Matcher API in five distinct ways:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Variant</th><th>Language</th><th>Engine</th><th>Regex Implementation</th></tr>
</thead>
<tbody>
<tr><td><strong>rumi</strong></td><td>Rust</td><td>Native</td><td><code>regex</code> crate (linear time, RE2 semantics)</td></tr>
<tr><td><strong>puma</strong></td><td>Python</td><td>Pure Python</td><td><code>re</code> module (backtracking)</td></tr>
<tr><td><strong>bumi</strong></td><td>TypeScript</td><td>Pure TypeScript (Bun)</td><td><code>RegExp</code> (backtracking)</td></tr>
<tr><td><strong>puma-crusty</strong></td><td>Python + Rust</td><td>PyO3 FFI to rumi</td><td><code>regex</code> crate via FFI</td></tr>
<tr><td><strong>bumi-crusty</strong></td><td>TypeScript + Rust</td><td>WASM FFI to rumi</td><td><code>regex</code> crate via WASM</td></tr>
</tbody>
</table>
</div>
<p>The first three (rumi, puma, bumi) are pure implementations in their native languages. The crusty variants wrap the Rust engine with language bindings.</p>
<h2 id="the-simplest-case-exact-string-match"><a class="header" href="#the-simplest-case-exact-string-match">The Simplest Case: Exact String Match</a></h2>
<p>Letâ€™s start with the most basic operation: matching a single exact string.</p>
<p><strong>Scenario</strong>: One rule checks if a path equals <code>/api/users</code>. We test both hit (matches) and miss (doesnâ€™t match) paths.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Variant</th><th>Exact Match Hit</th><th>Exact Match Miss</th></tr>
</thead>
<tbody>
<tr><td>rumi</td><td>33 ns</td><td>25 ns</td></tr>
<tr><td>bumi</td><td>9.3 ns</td><td>10.4 ns</td></tr>
<tr><td>puma</td><td>325 ns</td><td>275 ns</td></tr>
</tbody>
</table>
</div>
<p><strong>The surprise</strong>: TypeScript (bumi) is 3.5x faster than Rust (rumi).</p>
<h3 id="why-typescript-beats-rust-here"><a class="header" href="#why-typescript-beats-rust-here">Why TypeScript Beats Rust Here</a></h3>
<p>This isnâ€™t a language speed contest â€” itâ€™s an architectural one.</p>
<p>The rumi matcher uses <code>Box&lt;dyn InputMatcher&gt;</code> for extensibility. Every match call goes through a vtable dispatch. The TypeScript JIT (JavaScriptCore in Bun) sees the monomorphic call site and inlines the comparison directly.</p>
<p>This is expected and fixable. Rustâ€™s trait dispatch trades single-operation speed for compositional flexibility. Future Rust versions with improved monomorphization may close this gap. For now, itâ€™s the cost of dynamic dispatch.</p>
<p><strong>Python</strong> is 10-30x slower than both â€” no surprise there. Pythonâ€™s interpreter overhead dominates at this scale. But 325ns is still 3 million operations per second on a single core.</p>
<h2 id="adding-complexity-regex-matching"><a class="header" href="#adding-complexity-regex-matching">Adding Complexity: Regex Matching</a></h2>
<p>Now we test pattern matching with <code>^/api/v\d+/users$</code>.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Variant</th><th>Regex Hit</th><th>Regex Miss</th></tr>
</thead>
<tbody>
<tr><td>rumi</td><td>52 ns</td><td>30 ns</td></tr>
<tr><td>bumi</td><td>24.8 ns</td><td>20.7 ns</td></tr>
<tr><td>puma</td><td>452 ns</td><td>311 ns</td></tr>
</tbody>
</table>
</div>
<p>Same pattern: bumiâ€™s JIT-optimized RegExp beats rumiâ€™s vtable dispatch. The hit path is roughly 2x slower than the miss path across all variants (the regex engine does more work on a match).</p>
<p>Python adds interpreter overhead but stays within the same order of magnitude. Still fast enough for most web workloads.</p>
<p>Nothing alarming yet. Letâ€™s make things interesting.</p>
<h2 id="boolean-logic-andor-predicates"><a class="header" href="#boolean-logic-andor-predicates">Boolean Logic: AND/OR Predicates</a></h2>
<p>Real matchers combine conditions. Here we test two predicates composed with AND and OR:</p>
<ul>
<li><strong>AND</strong>: both predicates must match (worst case: evaluates both)</li>
<li><strong>OR</strong>: first match wins (best case: short-circuits on first predicate)</li>
</ul>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Variant</th><th>AND (both match)</th><th>OR (first matches)</th></tr>
</thead>
<tbody>
<tr><td>rumi</td><td>96 ns</td><td>56 ns</td></tr>
<tr><td>bumi</td><td>61.7 ns</td><td>25.4 ns</td></tr>
<tr><td>puma</td><td>637 ns</td><td>454 ns</td></tr>
</tbody>
</table>
</div>
<p>The gap widens. bumiâ€™s short-circuit optimization on OR is particularly efficient (25ns). Rustâ€™s trait dispatch adds overhead for each predicate evaluation.</p>
<p>Python remains 10x slower but scales proportionally. The interpreter tax is constant across operations.</p>
<h2 id="scaling-many-rules"><a class="header" href="#scaling-many-rules">Scaling: Many Rules</a></h2>
<p>Production matchers have dozens or hundreds of rules. We test first-match-wins evaluation where the <strong>last rule matches</strong> (worst case: linear scan through all rules).</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Rules</th><th>rumi</th><th>bumi</th><th>puma</th></tr>
</thead>
<tbody>
<tr><td>10</td><td>245 ns</td><td>118 ns</td><td>1.2 Âµs</td></tr>
<tr><td>50</td><td>1.07 Âµs</td><td>542 ns</td><td>5.3 Âµs</td></tr>
<tr><td>100</td><td>1.80 Âµs</td><td>1.07 Âµs</td><td>10.1 Âµs</td></tr>
<tr><td>200</td><td>3.49 Âµs</td><td>2.10 Âµs</td><td>20.0 Âµs</td></tr>
</tbody>
</table>
</div>
<p>All three scale linearly (as expected â€” first-match-wins is O(n) in the worst case). No cache thrashing, no algorithmic surprises. The JIT advantage persists: bumi is roughly 2x faster than rumi, which is roughly 5x faster than puma.</p>
<h3 id="throughput-at-200-rules"><a class="header" href="#throughput-at-200-rules">Throughput at 200 Rules</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Variant</th><th>Latency</th><th>Requests/sec</th></tr>
</thead>
<tbody>
<tr><td>bumi</td><td>2.1 Âµs</td><td>476,000</td></tr>
<tr><td>rumi</td><td>3.5 Âµs</td><td>286,000</td></tr>
<tr><td>puma</td><td>20 Âµs</td><td>50,000</td></tr>
</tbody>
</table>
</div>
<p>For context, even the â€œslowâ€ Python variant evaluates <strong>50,000 requests per second on a single core</strong>. In a typical web framework with network I/O, database queries, and business logic, the matcher is not a bottleneck.</p>
<p>But thereâ€™s a scenario where these differences become life-or-death.</p>
<h2 id="the-catastrophe-redos"><a class="header" href="#the-catastrophe-redos">The Catastrophe: ReDoS</a></h2>
<p>Regular Expression Denial of Service (ReDoS) exploits backtracking regex engines with adversarial input.</p>
<p><strong>Attack pattern</strong>: <code>(a+)+$</code>
<strong>Adversarial input</strong>: <code>"a" * N + "X"</code></p>
<p>The regex engine tries exponentially many backtracking paths before failing. At N=20, there are over <strong>1 million backtracking attempts</strong>.</p>
<p>Hereâ€™s what happens:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>N</th><th>rumi (linear)</th><th>puma (backtracking)</th><th>bumi (backtracking)</th></tr>
</thead>
<tbody>
<tr><td>5</td><td>10 ns</td><td>2.5 Âµs</td><td>335 ns</td></tr>
<tr><td>10</td><td>10 ns</td><td>71 Âµs</td><td>10.7 Âµs</td></tr>
<tr><td>15</td><td>11 ns</td><td>2.27 ms</td><td>370 Âµs</td></tr>
<tr><td>20</td><td>11 ns</td><td><strong>72.4 ms</strong></td><td><strong>11.1 ms</strong></td></tr>
<tr><td>25</td><td>11 ns</td><td>HANGS</td><td>HANGS</td></tr>
<tr><td>50</td><td>11 ns</td><td>HANGS</td><td>HANGS</td></tr>
<tr><td>100</td><td>11 ns</td><td>HANGS</td><td>HANGS</td></tr>
</tbody>
</table>
</div>
<h3 id="the-numbers-at-n20"><a class="header" href="#the-numbers-at-n20">The Numbers at N=20</a></h3>
<ul>
<li><strong>rumi</strong>: 11 nanoseconds</li>
<li><strong>puma</strong>: 72 milliseconds (6.5 million times slower)</li>
<li><strong>bumi</strong>: 11 milliseconds (1 million times slower)</li>
</ul>
<p>At N=25 and beyond, both puma and bumi <strong>hang indefinitely</strong>. The matcher becomes a denial-of-service vulnerability. An attacker sends a single malicious request and ties up a worker thread forever.</p>
<h3 id="why-rust-survives"><a class="header" href="#why-rust-survives">Why Rust Survives</a></h3>
<p>Rustâ€™s <code>regex</code> crate uses a Thompson NFA implementation (like Googleâ€™s RE2) with guaranteed linear time complexity. No backtracking, no exponential blowup, no vulnerability.</p>
<p>The time complexity is O(n) where n is the input length. Whether you match 5 characters or 100 characters, the cost scales linearly.</p>
<p>This is why the arch-guild review mandated: <strong>Use Rust <code>regex</code> crate only. No <code>fancy-regex</code>. ReDoS protection is non-negotiable.</strong></p>
<p>But what if you need Python or TypeScript? Thatâ€™s where the crusty variants come in.</p>
<h2 id="ffi-head-to-head-puma-vs-puma-crusty"><a class="header" href="#ffi-head-to-head-puma-vs-puma-crusty">FFI Head-to-Head: puma vs puma-crusty</a></h2>
<p>puma-crusty is a Python package that wraps the rumi engine via PyO3. Every matcher call crosses the Python-Rust FFI boundary.</p>
<p>Letâ€™s see what that boundary costs:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Scenario</th><th>puma (pure Python)</th><th>puma-crusty (PyO3)</th><th>Ratio</th></tr>
</thead>
<tbody>
<tr><td>compile_simple</td><td>1.83 Âµs</td><td>625 ns</td><td>crusty 2.9x faster</td></tr>
<tr><td>compile_complex</td><td>4.62 Âµs</td><td>14.0 Âµs</td><td>puma 3x faster</td></tr>
<tr><td>exact_hit</td><td>282 ns</td><td>188 ns</td><td>crusty 1.5x faster</td></tr>
<tr><td>exact_miss</td><td>178 ns</td><td>141 ns</td><td>crusty 1.3x faster</td></tr>
<tr><td>regex_hit</td><td>482 ns</td><td>299 ns</td><td>crusty 1.6x faster</td></tr>
<tr><td>regex_miss</td><td>203 ns</td><td>201 ns</td><td>same</td></tr>
<tr><td>complex_hit</td><td>814 ns</td><td>570 ns</td><td>crusty 1.4x faster</td></tr>
<tr><td>complex_miss</td><td>461 ns</td><td>490 ns</td><td>same</td></tr>
</tbody>
</table>
</div>
<h3 id="the-ffi-overhead"><a class="header" href="#the-ffi-overhead">The FFI Overhead</a></h3>
<p><strong>For evaluation</strong>: crusty is 1.3-1.6x faster on simple operations, breaks even on misses.</p>
<p><strong>For compilation</strong>: crusty wins on simple configs (Rust struct construction beats Python dataclass construction), but loses on complex configs where Pythonâ€™s dynamic typing makes nested object graphs cheaper to construct.</p>
<p>The FFI overhead is minimal because PyO3 has been heavily optimized for this workload. The crossover happens around 1-2 arguments per call.</p>
<h3 id="the-strategic-value"><a class="header" href="#the-strategic-value">The Strategic Value</a></h3>
<p>crusty gives you the ReDoS protection of Rustâ€™s regex engine without rewriting your Python code. For regex-heavy workloads, itâ€™s a 1.5x speedup. For adversarial regex input, itâ€™s the difference between 11ns and hanging forever.</p>
<p>If youâ€™re building a Python service that accepts regex patterns from untrusted sources, puma-crusty is your safety net.</p>
<h2 id="ffi-head-to-head-bumi-vs-bumi-crusty"><a class="header" href="#ffi-head-to-head-bumi-vs-bumi-crusty">FFI Head-to-Head: bumi vs bumi-crusty</a></h2>
<p>bumi-crusty wraps the rumi engine compiled to WebAssembly via wasm-bindgen. Every call crosses the JavaScript-WASM boundary with object serialization via <code>js_sys::Reflect</code>.</p>
<p>Hereâ€™s the brutal truth:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Scenario</th><th>bumi (pure TS)</th><th>bumi-crusty (WASM)</th><th>Ratio</th></tr>
</thead>
<tbody>
<tr><td>compile_simple</td><td>19 ns</td><td>2.17 Âµs</td><td><strong>bumi 113x faster</strong></td></tr>
<tr><td>compile_complex</td><td>107 ns</td><td>47.4 Âµs</td><td><strong>bumi 444x faster</strong></td></tr>
<tr><td>exact_hit</td><td>9.9 ns</td><td>1.63 Âµs</td><td><strong>bumi 164x faster</strong></td></tr>
<tr><td>exact_miss</td><td>10.7 ns</td><td>1.52 Âµs</td><td><strong>bumi 142x faster</strong></td></tr>
<tr><td>regex_hit</td><td>25.9 ns</td><td>2.13 Âµs</td><td><strong>bumi 82x faster</strong></td></tr>
<tr><td>regex_miss</td><td>18.1 ns</td><td>1.66 Âµs</td><td><strong>bumi 92x faster</strong></td></tr>
<tr><td>complex_hit</td><td>82.7 ns</td><td>2.45 Âµs</td><td><strong>bumi 30x faster</strong></td></tr>
<tr><td>complex_miss</td><td>25.7 ns</td><td>2.42 Âµs</td><td><strong>bumi 94x faster</strong></td></tr>
</tbody>
</table>
</div>
<p>Pure TypeScript is faster in <strong>every single scenario</strong>. Not by a little â€” by 30-450x.</p>
<h3 id="the-wasm-boundary-tax"><a class="header" href="#the-wasm-boundary-tax">The WASM Boundary Tax</a></h3>
<p>The WASM boundary serialization overhead dominates. At 2-3 microseconds per call, the FFI cost exceeds the work being done by multiple orders of magnitude.</p>
<p>Unlike PyO3 (which passes raw pointers), wasm-bindgen serializes objects via <code>js_sys::Reflect</code>, which means:</p>
<ol>
<li>Walk the JavaScript object graph</li>
<li>Convert to Rust types</li>
<li>Call the Rust function</li>
<li>Convert result back to JavaScript</li>
<li>Reconstruct JavaScript objects</li>
</ol>
<p>For a 10ns operation, a 2Âµs boundary cost is 200x overhead.</p>
<h3 id="why-bumi-crusty-exists"><a class="header" href="#why-bumi-crusty-exists">Why bumi-crusty Exists</a></h3>
<p>Not for speed. For <strong>ReDoS protection</strong>.</p>
<p>If your matcher uses regex heavily and accepts untrusted input, the pure TypeScript RegExp engine is a vulnerability. bumi-crusty gives you the linear-time guarantees of Rustâ€™s <code>regex</code> crate at the cost of 100x slower baseline performance.</p>
<p>For most workloads, this is a bad trade. But if an attacker can hang your service with a single malicious regex match, 2Âµs is cheaper than 72ms (or infinite time).</p>
<h3 id="when-to-use-bumi-crusty"><a class="header" href="#when-to-use-bumi-crusty">When to Use bumi-crusty</a></h3>
<ul>
<li>Cloudflare Workers or Deno Deploy where regex comes from user config</li>
<li>Low request rate where 2Âµs per match is acceptable</li>
<li>Security-critical edge cases where ReDoS is a real threat</li>
</ul>
<p>For general use, stick with pure bumi and <strong>audit regex patterns at ingress</strong>.</p>
<h2 id="the-strategic-picture"><a class="header" href="#the-strategic-picture">The Strategic Picture</a></h2>
<h3 id="use-rumi-rust-when-1"><a class="header" href="#use-rumi-rust-when-1">Use <strong>rumi</strong> (Rust) when</a></h3>
<ul>
<li>Building a proxy, load balancer, or high-throughput router</li>
<li>You need maximum throughput per core</li>
<li>Regex matching untrusted input (ReDoS protection mandatory)</li>
<li>Youâ€™re already in Rust-land</li>
</ul>
<p><strong>Speed</strong>: Best for complex pipelines. Linear-time regex with zero ReDoS risk.</p>
<h3 id="use-puma-python-when-1"><a class="header" href="#use-puma-python-when-1">Use <strong>puma</strong> (Python) when</a></h3>
<ul>
<li>Integrating with Python web frameworks (FastAPI, Flask, Django)</li>
<li>Developer ergonomics matter more than raw speed</li>
<li>You control the regex patterns (no untrusted input)</li>
<li>50k req/sec per core is fast enough</li>
</ul>
<p><strong>Speed</strong>: 10-30x slower than Rust, but rarely the bottleneck. Backtracking regex vulnerable to ReDoS.</p>
<h3 id="use-bumi-typescript-when-1"><a class="header" href="#use-bumi-typescript-when-1">Use <strong>bumi</strong> (TypeScript) when</a></h3>
<ul>
<li>Building frontend routing or edge workers (Cloudflare, Deno Deploy)</li>
<li>You need sub-microsecond latency for simple matches</li>
<li>You control the regex patterns (no untrusted input)</li>
<li>TypeScript ecosystem integration is valuable</li>
</ul>
<p><strong>Speed</strong>: Fastest for simple operations (JIT beats Rust dispatch). Backtracking regex vulnerable to ReDoS.</p>
<h3 id="use-puma-crusty-python--rust-ffi-when-1"><a class="header" href="#use-puma-crusty-python--rust-ffi-when-1">Use <strong>puma-crusty</strong> (Python + Rust FFI) when</a></h3>
<ul>
<li>You need ReDoS protection in a Python codebase</li>
<li>Regex-heavy workloads where 1.5x speedup matters</li>
<li>Willing to add a native extension dependency</li>
</ul>
<p><strong>Speed</strong>: 1.5x faster than puma for evaluation, 3x slower for complex compilation. Linear-time regex.</p>
<h3 id="avoid-bumi-crusty-typescript--wasm-ffi-unless"><a class="header" href="#avoid-bumi-crusty-typescript--wasm-ffi-unless">Avoid <strong>bumi-crusty</strong> (TypeScript + WASM FFI) unless</a></h3>
<ul>
<li>You MUST have linear-time regex in TypeScript</li>
<li>Youâ€™re matching untrusted regex input at the edge</li>
<li>The 100x slowdown is acceptable (e.g., low request rate)</li>
</ul>
<p><strong>Speed</strong>: 30-450x slower than pure TypeScript. Only use for ReDoS protection when no other option exists.</p>
<h2 id="phase-11-the-re2-alternative"><a class="header" href="#phase-11-the-re2-alternative">Phase 11: The RE2 Alternative</a></h2>
<p>The roadmap includes Phase 11: migrate puma to <code>google-re2</code> (Python bindings to C++ RE2) and bumi to <code>re2js</code> (pure JS port of RE2).</p>
<p>This would give linear-time regex guarantees without FFI overhead:</p>
<ul>
<li><strong>puma</strong> gets ReDoS protection via a mature C extension (comparable to PyO3 overhead)</li>
<li><strong>bumi</strong> gets ReDoS protection in pure TypeScript (no WASM boundary)</li>
</ul>
<p>At that point, the crusty variants shift from â€œsafety layerâ€ to â€œfull compiled pipeline in Rustâ€ for complex configs where the rumi compilerâ€™s optimizations justify the FFI cost.</p>
<p>But thatâ€™s future work. For now, the pure implementations are fastest, and the crusty variants are the ReDoS safety net.</p>
<h2 id="the-bottom-line"><a class="header" href="#the-bottom-line">The Bottom Line</a></h2>
<p>TypeScript JIT beats Rust dynamic dispatch on simple operations. This is expected and not a language-level win â€” itâ€™s the natural outcome of monomorphic inline caching vs vtable indirection.</p>
<p>Python is 10-30x slower than both, which is the expected interpreter tax. Still fast enough for most web workloads.</p>
<p>The real story is <strong>ReDoS</strong>. At N=20, Rustâ€™s linear-time regex is 6.5 million times faster than Pythonâ€™s backtracking engine. At N=25, Python hangs forever. This isnâ€™t a performance optimization â€” itâ€™s a <strong>security boundary</strong>.</p>
<p>The crusty variants let you pay the FFI tax to get Rustâ€™s safety guarantees. For Python, the tax is small (1.5x slower than pure Python). For TypeScript, the tax is huge (100x slower than pure TypeScript). Choose accordingly.</p>
<p>In production:</p>
<ul>
<li>Use <strong>rumi</strong> if you can</li>
<li>Use <strong>puma/bumi</strong> if ergonomics matter more than raw speed</li>
<li>Add <strong>crusty</strong> if untrusted regex input is a threat model</li>
</ul>
<p>And never, ever, let user-supplied regex patterns hit a backtracking engine without sanitization.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="security-model"><a class="header" href="#security-model">Security Model</a></h1>
<p>x.uma is a trust boundary. Hereâ€™s what it guarantees.</p>
<p>A matcher processes untrusted input (HTTP requests, gRPC messages, arbitrary data) and makes routing or policy decisions. A single malicious input should never crash the process, hang a worker thread, or consume unbounded resources.</p>
<p>This page documents the security guarantees and failure modes of the x.uma matcher engine.</p>
<h2 id="threat-model"><a class="header" href="#threat-model">Threat Model</a></h2>
<p>x.uma assumes:</p>
<ul>
<li><strong>Untrusted input data</strong> â€” HTTP paths, headers, query params come from the network</li>
<li><strong>Trusted config</strong> â€” matcher rules come from deployment config (not user input)</li>
<li><strong>Optional: untrusted patterns</strong> â€” in some deployments, regex patterns may come from user config</li>
</ul>
<p>The matcher must remain safe under all input conditions. Adversarial input may cause a match to fail, but it must never cause unbounded resource consumption or undefined behavior.</p>
<h2 id="depth-limits"><a class="header" href="#depth-limits">Depth Limits</a></h2>
<p><strong>Guarantee</strong>: Nested matchers cannot exceed 32 levels.</p>
<p><strong>Implementation</strong>: <code>MAX_DEPTH = 32</code> enforced at config validation time (not runtime).</p>
<h3 id="why-depth-limits-matter"><a class="header" href="#why-depth-limits-matter">Why Depth Limits Matter</a></h3>
<p>xDS matchers support recursion â€” an <code>OnMatch</code> can contain a nested <code>Matcher</code>, which can contain more nested matchers:</p>
<pre><code class="language-protobuf">Matcher {
  matcher_tree {
    on_match {
      matcher {  // level 1
        on_match {
          matcher {  // level 2
            ...
          }
        }
      }
    }
  }
}
</code></pre>
<p>Without limits, an attacker could craft a config with 10,000 nested levels. In recursive implementations, this causes stack overflow. In iterative implementations, it causes O(n) validation cost per request.</p>
<h3 id="enforcement"><a class="header" href="#enforcement">Enforcement</a></h3>
<p>All variants validate depth at <strong>config load time</strong>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// rumi (Rust)
impl Matcher {
    pub fn validate(&amp;self) -&gt; Result&lt;(), MatcherError&gt; {
        self.validate_depth(0, MAX_DEPTH)
    }
}
<span class="boring">}</span></code></pre>
<pre><code class="language-python"># puma (Python)
def validate_depth(matcher: Matcher, current: int = 0) -&gt; None:
    if current &gt; MAX_DEPTH:
        raise ValueError(f"Matcher depth {current} exceeds MAX_DEPTH={MAX_DEPTH}")
</code></pre>
<p>A config that exceeds depth limits is <strong>rejected at construction</strong>. Runtime evaluation never sees invalid configs.</p>
<h2 id="redos-protection"><a class="header" href="#redos-protection">ReDoS Protection</a></h2>
<p><strong>Guarantee</strong>: Varies by implementation.</p>
<p>Regular Expression Denial of Service (ReDoS) exploits backtracking regex engines with adversarial input. A pattern like <code>(a+)+$</code> against input <code>"a" * N + "X"</code> causes exponential backtracking.</p>
<h3 id="protection-by-variant"><a class="header" href="#protection-by-variant">Protection by Variant</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Variant</th><th>Regex Engine</th><th>Complexity</th><th>ReDoS Risk</th></tr>
</thead>
<tbody>
<tr><td><strong>rumi</strong></td><td>Rust <code>regex</code> crate</td><td>O(n) linear</td><td><strong>None</strong> â€” guaranteed safe</td></tr>
<tr><td><strong>puma</strong></td><td>Python <code>re</code> module</td><td>O(2^n) backtracking</td><td><strong>High</strong> â€” vulnerable</td></tr>
<tr><td><strong>bumi</strong></td><td>JavaScript <code>RegExp</code></td><td>O(2^n) backtracking</td><td><strong>High</strong> â€” vulnerable</td></tr>
<tr><td><strong>puma-crusty</strong></td><td>Rust <code>regex</code> via FFI</td><td>O(n) linear</td><td><strong>None</strong> â€” guaranteed safe</td></tr>
<tr><td><strong>bumi-crusty</strong></td><td>Rust <code>regex</code> via WASM</td><td>O(n) linear</td><td><strong>None</strong> â€” guaranteed safe</td></tr>
</tbody>
</table>
</div>
<h3 id="when-it-matters"><a class="header" href="#when-it-matters">When It Matters</a></h3>
<p><strong>Trusted patterns</strong> (you control the regex):</p>
<ul>
<li>puma and bumi are safe â€” you wonâ€™t write exponential patterns</li>
<li>No ReDoS risk because attacker canâ€™t control the pattern</li>
</ul>
<p><strong>Untrusted patterns</strong> (regex comes from user config or external source):</p>
<ul>
<li>puma and bumi are <strong>unsafe</strong> â€” attacker can craft malicious patterns</li>
<li>Must use rumi, puma-crusty, or bumi-crusty for guaranteed linear time</li>
</ul>
<h3 id="example-attack"><a class="header" href="#example-attack">Example Attack</a></h3>
<p>Pattern: <code>(a+)+$</code>
Input: <code>"aaaaaaaaaaaaaaaaaaaaX"</code> (N=20)</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Variant</th><th>Time</th><th>Behavior</th></tr>
</thead>
<tbody>
<tr><td>rumi</td><td>11 ns</td><td>Returns false</td></tr>
<tr><td>puma</td><td>72 ms</td><td>Returns false after 6.5M backtracking attempts</td></tr>
<tr><td>bumi</td><td>11 ms</td><td>Returns false after 1M backtracking attempts</td></tr>
<tr><td>puma-crusty</td><td>11 ns</td><td>Returns false</td></tr>
<tr><td>bumi-crusty</td><td>11 ns</td><td>Returns false</td></tr>
</tbody>
</table>
</div>
<p>At N=25, puma and bumi hang indefinitely. The worker thread never returns.</p>
<p>See <a href="#redos-protection-1">ReDoS Protection</a> for full technical deep dive.</p>
<h2 id="fail-closed-defaults"><a class="header" href="#fail-closed-defaults">Fail-Closed Defaults</a></h2>
<p><strong>Guarantee</strong>: No match never accidentally becomes a match.</p>
<p>The matcher uses <strong>fail-closed semantics</strong>:</p>
<ul>
<li>If a predicate evaluates to false, the match fails</li>
<li>If input data is missing, the predicate evaluates to false</li>
<li>If no rule matches, the matcher returns <code>None</code> (no action)</li>
</ul>
<p>There is no way for missing data or failed predicates to â€œleak throughâ€ and trigger an unintended action.</p>
<h3 id="the-none--false-invariant-1"><a class="header" href="#the-none--false-invariant-1">The None â†’ false Invariant</a></h3>
<p>When a <code>DataInput</code> returns <code>None</code> (missing data), the predicate evaluates to <code>false</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// rumi
impl SinglePredicate {
    fn evaluate(&amp;self, ctx: &amp;Ctx) -&gt; bool {
        let value = self.input.get(ctx);
        if let MatchingData::None = value {
            return false;  // missing data = no match
        }
        self.matcher.matches(&amp;value)
    }
}
<span class="boring">}</span></code></pre>
<p>This prevents bugs where a missing header or query param causes a â€œdefault matchâ€ that bypasses security rules.</p>
<p><strong>Example</strong>: A rule matches requests with <code>x-admin: true</code>. If the header is missing:</p>
<ul>
<li>Predicate evaluates to <code>false</code></li>
<li>Rule does not match</li>
<li>Request is not treated as admin</li>
</ul>
<p>The attacker cannot trigger admin behavior by omitting the header.</p>
<h2 id="input-validation"><a class="header" href="#input-validation">Input Validation</a></h2>
<p><strong>Guarantee</strong>: Configs are validated at construction, not at runtime.</p>
<p>All variants validate matcher configs when theyâ€™re built:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// rumi
let matcher = Matcher::try_from(proto_config)?;  // fails fast on invalid config
<span class="boring">}</span></code></pre>
<pre><code class="language-python"># puma
matcher = Matcher.from_proto(proto_config)  # raises ValueError on invalid config
validate_depth(matcher)  # enforces MAX_DEPTH
</code></pre>
<p>Invalid configs are rejected before the matcher is ever used. Runtime evaluation assumes the config is valid and never checks invariants that should have been validated at construction.</p>
<p>This follows the <strong>parse, donâ€™t validate</strong> principle: once a <code>Matcher</code> object exists, itâ€™s known to be valid.</p>
<h2 id="type-safety-1"><a class="header" href="#type-safety-1">Type Safety</a></h2>
<p><strong>Guarantee</strong>: Matchers are type-safe at the domain level.</p>
<p>A <code>Matcher&lt;HttpMessage, A&gt;</code> only accepts <code>HttpMessage</code> contexts. You cannot pass a <code>GrpcMessage</code> to an HTTP matcher. The type system prevents misuse.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// rumi
let http_matcher: Matcher&lt;HttpMessage, Action&gt; = ...;
let http_req = HttpMessage::from(...);
http_matcher.evaluate(&amp;http_req);  // OK

let grpc_req = GrpcMessage::from(...);
http_matcher.evaluate(&amp;grpc_req);  // compile error: type mismatch
<span class="boring">}</span></code></pre>
<p>In Python and TypeScript, this is enforced at runtime via protocols:</p>
<pre><code class="language-python"># puma
def evaluate(self, ctx: HttpRequest) -&gt; Action | None: ...
</code></pre>
<p>The type hint documents the expected context. Passing the wrong type raises <code>AttributeError</code> when the matcher tries to access missing fields.</p>
<h2 id="thread-safety"><a class="header" href="#thread-safety">Thread Safety</a></h2>
<p><strong>Guarantee</strong>: All matcher types are thread-safe.</p>
<p>Matchers are immutable after construction. All core types implement <code>Send + Sync</code> (Rust) or equivalent thread-safety guarantees in Python and TypeScript.</p>
<p>Multiple threads can evaluate the same matcher concurrently without locking:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// rumi
static MATCHER: Lazy&lt;Matcher&lt;HttpMessage, Action&gt;&gt; = Lazy::new(|| ...);

// Called from multiple threads
fn handle_request(req: HttpRequest) {
    let result = MATCHER.evaluate(&amp;req);  // no lock needed
}
<span class="boring">}</span></code></pre>
<p>This enables zero-overhead concurrent evaluation in multi-threaded servers.</p>
<h2 id="resource-bounds"><a class="header" href="#resource-bounds">Resource Bounds</a></h2>
<p><strong>Guarantee</strong>: Evaluation time is bounded by config size, not input size (except regex).</p>
<p>For non-regex operations, evaluation cost is O(rules) regardless of input size:</p>
<ul>
<li>Exact string match: O(1) comparison</li>
<li>Prefix match: O(1) radix tree lookup</li>
<li>First-match-wins over N rules: O(N) linear scan in worst case</li>
</ul>
<p>The only unbounded operation is regex matching, where cost is O(n) in the input length for rumi/crusty variants, and O(2^n) for puma/bumi on adversarial patterns.</p>
<p><strong>Maximum evaluation time</strong> (trusted patterns, 200 rules):</p>
<ul>
<li>rumi: 3.5 microseconds</li>
<li>bumi: 2.1 microseconds</li>
<li>puma: 20 microseconds</li>
</ul>
<p>For untrusted patterns, use a variant with linear-time regex.</p>
<h2 id="no-unsafe-code-rust"><a class="header" href="#no-unsafe-code-rust">No Unsafe Code (Rust)</a></h2>
<p><strong>Guarantee</strong>: rumi uses zero unsafe code in the core engine.</p>
<p>All <code>Send + Sync</code> implementations are compiler-derived. No manual <code>unsafe impl</code>. The type system enforces thread safety without escape hatches.</p>
<p>The only <code>unsafe</code> in the entire codebase is in FFI boundary layers (puma-crusty and bumi-crusty), where itâ€™s required to cross language boundaries. The core engine is 100% safe Rust.</p>
<h2 id="attack-scenarios"><a class="header" href="#attack-scenarios">Attack Scenarios</a></h2>
<h3 id="scenario-1-stack-overflow-via-deep-nesting"><a class="header" href="#scenario-1-stack-overflow-via-deep-nesting">Scenario 1: Stack Overflow via Deep Nesting</a></h3>
<p><strong>Attack</strong>: Craft a config with 10,000 nested matchers to cause stack overflow.</p>
<p><strong>Mitigation</strong>: <code>MAX_DEPTH = 32</code> enforced at config validation. Invalid config rejected before use.</p>
<p><strong>Result</strong>: Attack prevented. Config never loads.</p>
<h3 id="scenario-2-redos-via-malicious-pattern"><a class="header" href="#scenario-2-redos-via-malicious-pattern">Scenario 2: ReDoS via Malicious Pattern</a></h3>
<p><strong>Attack</strong>: Inject pattern <code>(a+)+$</code> into user-facing config, send input <code>"a" * 30 + "X"</code> to hang the service.</p>
<p><strong>Mitigation</strong>: Use rumi, puma-crusty, or bumi-crusty for untrusted patterns. Linear-time regex prevents exponential backtracking.</p>
<p><strong>Result</strong>: Attack mitigated if using safe variant. puma/bumi vulnerable if attacker controls patterns.</p>
<h3 id="scenario-3-bypass-via-missing-header"><a class="header" href="#scenario-3-bypass-via-missing-header">Scenario 3: Bypass via Missing Header</a></h3>
<p><strong>Attack</strong>: Omit the <code>x-admin</code> header to bypass a rule that checks <code>x-admin: true</code>.</p>
<p><strong>Mitigation</strong>: None â†’ false invariant. Missing header causes predicate to return <code>false</code>, not <code>true</code>.</p>
<p><strong>Result</strong>: Attack prevented. Rule does not match when header is missing.</p>
<h3 id="scenario-4-type-confusion"><a class="header" href="#scenario-4-type-confusion">Scenario 4: Type Confusion</a></h3>
<p><strong>Attack</strong>: Pass a <code>GrpcMessage</code> to an <code>HttpMatcher</code> to trigger undefined behavior.</p>
<p><strong>Mitigation</strong>: Type system enforces context types. Rust prevents this at compile time. Python/TypeScript fail at runtime with <code>AttributeError</code>.</p>
<p><strong>Result</strong>: Attack prevented. Type mismatch detected before evaluation.</p>
<h2 id="security-checklist"><a class="header" href="#security-checklist">Security Checklist</a></h2>
<p>Before deploying a matcher in production:</p>
<ul>
<li><input disabled="" type="checkbox"> Depth limit validated â€” confirm <code>MAX_DEPTH</code> enforcement</li>
<li><input disabled="" type="checkbox"> ReDoS risk assessed â€” untrusted patterns require rumi/crusty variants</li>
<li><input disabled="" type="checkbox"> Fail-closed defaults confirmed â€” missing data evaluates to false</li>
<li><input disabled="" type="checkbox"> Config validated at load time â€” invalid configs rejected</li>
<li><input disabled="" type="checkbox"> Type safety verified â€” context types match matcher expectations</li>
<li><input disabled="" type="checkbox"> Thread safety confirmed â€” concurrent evaluation is safe</li>
</ul>
<p>For untrusted input scenarios, prefer rumi for maximum safety.</p>
<h2 id="related-pages"><a class="header" href="#related-pages">Related Pages</a></h2>
<ul>
<li><a href="#redos-protection-1">ReDoS Protection</a> â€” Deep dive into regex denial-of-service</li>
<li><a href="#benchmark-results">Benchmark Results</a> â€” Performance data including ReDoS scenarios</li>
<li><a href="#performance-guide">Performance Guide</a> â€” Which variant to use for your threat model</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="redos-protection-1"><a class="header" href="#redos-protection-1">ReDoS Protection</a></h1>
<p>At N=20, Python takes 72 milliseconds. At N=25, it hangs forever.</p>
<p>Regular Expression Denial of Service (ReDoS) exploits the exponential time complexity of backtracking regex engines. A single malicious input can hang a worker thread indefinitely, turning a matcher into a denial-of-service vulnerability.</p>
<p>This page explains the attack, shows the data, and documents which x.uma variants are safe.</p>
<h2 id="the-attack-pattern"><a class="header" href="#the-attack-pattern">The Attack Pattern</a></h2>
<p>Consider this regex: <code>(a+)+$</code></p>
<p>Match it against this input: <code>"a" * N + "X"</code></p>
<p>The pattern says â€œone or more aâ€™s, repeated one or more times, followed by end of string.â€ The input is N aâ€™s followed by a single X (which makes the match fail).</p>
<p>A backtracking regex engine explores every possible grouping:</p>
<ul>
<li>Group 1: <code>[aaa]</code>, Group 2: <code>[aa]</code>, Group 3: <code>[a]</code> â€” fail, try next</li>
<li>Group 1: <code>[aa]</code>, Group 2: <code>[aaa]</code>, Group 3: <code>[a]</code> â€” fail, try next</li>
<li>Group 1: <code>[aa]</code>, Group 2: <code>[aa]</code>, Group 3: <code>[aa]</code> â€” fail, try next</li>
<li>â€¦ and so on â€¦</li>
</ul>
<p>The number of backtracking attempts grows exponentially: <strong>O(2^N)</strong>.</p>
<p>At N=10, there are ~1,000 attempts. At N=20, over <strong>1 million</strong>. At N=30, over <strong>1 billion</strong>.</p>
<h2 id="the-data"><a class="header" href="#the-data">The Data</a></h2>
<p>Hereâ€™s what happens when you run this attack against x.uma variants:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>N</th><th>rumi (linear)</th><th>puma (backtracking)</th><th>bumi (backtracking)</th></tr>
</thead>
<tbody>
<tr><td>5</td><td>10 ns</td><td>2.5 Âµs</td><td>335 ns</td></tr>
<tr><td>10</td><td>10 ns</td><td>71 Âµs</td><td>10.7 Âµs</td></tr>
<tr><td>15</td><td>11 ns</td><td>2.27 ms</td><td>370 Âµs</td></tr>
<tr><td>20</td><td>11 ns</td><td><strong>72.4 ms</strong></td><td><strong>11.1 ms</strong></td></tr>
<tr><td>25</td><td>11 ns</td><td>HANGS</td><td>HANGS</td></tr>
<tr><td>30</td><td>11 ns</td><td>HANGS</td><td>HANGS</td></tr>
<tr><td>50</td><td>11 ns</td><td>HANGS</td><td>HANGS</td></tr>
<tr><td>100</td><td>11 ns</td><td>HANGS</td><td>HANGS</td></tr>
</tbody>
</table>
</div>
<h3 id="visualizing-the-catastrophe"><a class="header" href="#visualizing-the-catastrophe">Visualizing the Catastrophe</a></h3>
<p>From N=5 to N=20, pumaâ€™s time grows by <strong>28,960x</strong>:</p>
<ul>
<li>N=5: 2.5 microseconds</li>
<li>N=10: 71 microseconds (28x slower)</li>
<li>N=15: 2.27 milliseconds (32x slower)</li>
<li>N=20: 72.4 milliseconds (32x slower)</li>
</ul>
<p>Each +5 increase in N multiplies the time by 30x. This is the exponential blowup.</p>
<p>At N=25, the benchmark times out. The regex engine enters an effectively infinite loop, trying 33 million+ backtracking paths. The worker thread never returns.</p>
<h3 id="why-rust-survives-1"><a class="header" href="#why-rust-survives-1">Why Rust Survives</a></h3>
<p>Rustâ€™s <code>regex</code> crate uses a <strong>Thompson NFA</strong> implementation (like Googleâ€™s RE2). It compiles the regex to a finite automaton and simulates it in linear time.</p>
<p>Time complexity: <strong>O(n)</strong> where n is the input length.</p>
<p>There is no backtracking. The engine walks the input once, tracking all possible states in parallel. At N=5 or N=100, the cost scales linearly:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>N</th><th>rumi time</th></tr>
</thead>
<tbody>
<tr><td>5</td><td>10 ns</td></tr>
<tr><td>20</td><td>11 ns</td></tr>
<tr><td>50</td><td>11 ns</td></tr>
<tr><td>100</td><td>11 ns</td></tr>
</tbody>
</table>
</div>
<p>The tiny variation (10-11ns) is CPU cache noise. The actual time is constant because the NFA has a fixed number of states regardless of input length.</p>
<h2 id="how-backtracking-works"><a class="header" href="#how-backtracking-works">How Backtracking Works</a></h2>
<p>A backtracking regex engine tries to match by exploring possible paths:</p>
<ol>
<li><strong>Try a match</strong> â€” attempt the first branch</li>
<li><strong>On failure, backtrack</strong> â€” undo the last decision and try the next branch</li>
<li><strong>Repeat</strong> until success or exhaustion</li>
</ol>
<p>For patterns with nested quantifiers like <code>(a+)+</code>, the number of paths explodes:</p>
<pre><code>Input: aaaaaX  (N=5)
Pattern: (a+)+$

Attempt 1: [aaaaa] â€” fail (X doesn't match $)
Attempt 2: [aaaa] [a] â€” fail
Attempt 3: [aaa] [aa] â€” fail
Attempt 4: [aaa] [a] [a] â€” fail
Attempt 5: [aa] [aaa] â€” fail
Attempt 6: [aa] [aa] [a] â€” fail
... 26 more attempts ...
</code></pre>
<p>At N=5, there are <strong>32 paths</strong> (2^5). At N=20, there are <strong>1,048,576 paths</strong> (2^20).</p>
<h2 id="why-thompson-nfa-doesnt-backtrack"><a class="header" href="#why-thompson-nfa-doesnt-backtrack">Why Thompson NFA Doesnâ€™t Backtrack</a></h2>
<p>A Thompson NFA tracks <strong>all possible states simultaneously</strong>. Instead of trying paths sequentially, it evaluates them in parallel:</p>
<pre><code>State set at position 0: {start}
State set at position 1: {group1, group2}
State set at position 2: {group1, group2}
...
State set at position N: {group1, group2}
State set at position N+1: {} â€” no valid transitions, match fails
</code></pre>
<p>The number of states is fixed (determined by the regex structure, not the input length). Walking N characters takes O(n) time.</p>
<p>Thereâ€™s no backtracking because the engine never â€œcommitsâ€ to a single path. It explores all paths at once in a single forward pass.</p>
<h2 id="which-variants-are-safe"><a class="header" href="#which-variants-are-safe">Which Variants Are Safe?</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Variant</th><th>Regex Engine</th><th>Time Complexity</th><th>Safe?</th></tr>
</thead>
<tbody>
<tr><td><strong>rumi</strong></td><td>Rust <code>regex</code> crate</td><td>O(n) linear</td><td>Yes</td></tr>
<tr><td><strong>puma</strong></td><td>Python <code>re</code> module</td><td>O(2^n) backtracking</td><td>No</td></tr>
<tr><td><strong>bumi</strong></td><td>JavaScript <code>RegExp</code></td><td>O(2^n) backtracking</td><td>No</td></tr>
<tr><td><strong>puma-crusty</strong></td><td>Rust <code>regex</code> via PyO3</td><td>O(n) linear</td><td>Yes</td></tr>
<tr><td><strong>bumi-crusty</strong></td><td>Rust <code>regex</code> via WASM</td><td>O(n) linear</td><td>Yes</td></tr>
</tbody>
</table>
</div>
<p>The <strong>crusty variants</strong> wrap the Rust engine with language bindings. They inherit the linear-time guarantees despite running in Python or TypeScript.</p>
<h3 id="ffi-cost-vs-safety"><a class="header" href="#ffi-cost-vs-safety">FFI Cost vs Safety</a></h3>
<p>puma-crusty adds minimal FFI overhead (1.5x slower than pure Python for simple matches) but gains infinite safety on adversarial input:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Scenario</th><th>puma (pure)</th><th>puma-crusty (FFI)</th><th>Difference</th></tr>
</thead>
<tbody>
<tr><td>N=5 (normal)</td><td>2.5 Âµs</td><td>10 ns</td><td>crusty 250x faster</td></tr>
<tr><td>N=20 (attack)</td><td>72 ms</td><td>11 ns</td><td>crusty 6.5M times faster</td></tr>
<tr><td>N=25 (critical)</td><td>HANGS</td><td>11 ns</td><td>crusty prevents DoS</td></tr>
</tbody>
</table>
</div>
<p>bumi-crusty adds significant FFI overhead (100x slower than pure TypeScript) but prevents the hang:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Scenario</th><th>bumi (pure)</th><th>bumi-crusty (FFI)</th><th>Difference</th></tr>
</thead>
<tbody>
<tr><td>N=5 (normal)</td><td>335 ns</td><td>10 ns</td><td>crusty 33x faster</td></tr>
<tr><td>N=20 (attack)</td><td>11 ms</td><td>11 ns</td><td>crusty 1M times faster</td></tr>
<tr><td>N=25 (critical)</td><td>HANGS</td><td>11 ns</td><td>crusty prevents DoS</td></tr>
</tbody>
</table>
</div>
<p>For adversarial input, the FFI overhead is irrelevant. The choice is between 11ns and infinite time.</p>
<h2 id="when-redos-matters"><a class="header" href="#when-redos-matters">When ReDoS Matters</a></h2>
<h3 id="trusted-patterns-you-control-the-regex"><a class="header" href="#trusted-patterns-you-control-the-regex">Trusted Patterns (You Control the Regex)</a></h3>
<p><strong>Safe to use</strong>: puma, bumi</p>
<p>If you write the regex patterns and deploy them with your code, you wonâ€™t accidentally write exponential patterns. Developers rarely write <code>(a+)+</code> unless theyâ€™re explicitly testing ReDoS.</p>
<p>Example trusted scenarios:</p>
<ul>
<li>HTTP routing rules in your application config</li>
<li>Policy rules deployed via CI/CD</li>
<li>Hardcoded matchers in your codebase</li>
</ul>
<p>In these cases, the pure Python or TypeScript implementations are safe and fast.</p>
<h3 id="untrusted-patterns-regex-comes-from-external-source"><a class="header" href="#untrusted-patterns-regex-comes-from-external-source">Untrusted Patterns (Regex Comes from External Source)</a></h3>
<p><strong>Unsafe to use</strong>: puma, bumi
<strong>Must use</strong>: rumi, puma-crusty, or bumi-crusty</p>
<p>If regex patterns come from user input, external config, or any source you donâ€™t control, an attacker can inject malicious patterns.</p>
<p>Example untrusted scenarios:</p>
<ul>
<li>User-facing â€œadvanced searchâ€ with regex support</li>
<li>Multi-tenant SaaS where customers define their own routing rules</li>
<li>Plugin systems where third-party code supplies patterns</li>
</ul>
<p>In these cases, backtracking engines are a <strong>critical vulnerability</strong>. An attacker sends a single request with a malicious pattern and hangs your service.</p>
<h3 id="untrusted-input-data-comes-from-network"><a class="header" href="#untrusted-input-data-comes-from-network">Untrusted Input (Data Comes from Network)</a></h3>
<p><strong>Safe to use</strong>: any variant (if patterns are trusted)</p>
<p>If the input data is untrusted but the patterns are trusted, ReDoS is not a concern. The attacker canâ€™t craft a regex â€” they can only send strings to match against your patterns.</p>
<p>Standard regex patterns like <code>^/api/v\d+/users$</code> are safe even on adversarial input because they donâ€™t have nested quantifiers.</p>
<p>Example:</p>
<ul>
<li>HTTP path matching in a web server (patterns are your routing rules)</li>
<li>Header validation in a proxy (patterns are your security rules)</li>
</ul>
<p>The key distinction: <strong>who controls the pattern?</strong></p>
<h2 id="mitigation-strategies"><a class="header" href="#mitigation-strategies">Mitigation Strategies</a></h2>
<h3 id="1-use-a-safe-variant"><a class="header" href="#1-use-a-safe-variant">1. Use a Safe Variant</a></h3>
<p>The most reliable mitigation is to use rumi, puma-crusty, or bumi-crusty for any matcher that processes untrusted patterns.</p>
<p><strong>Cost</strong>: FFI overhead (minimal for Python, significant for TypeScript)
<strong>Benefit</strong>: Guaranteed linear time, zero ReDoS risk</p>
<h3 id="2-audit-patterns-at-ingress"><a class="header" href="#2-audit-patterns-at-ingress">2. Audit Patterns at Ingress</a></h3>
<p>If you must use puma or bumi with untrusted patterns, validate patterns before they reach the matcher:</p>
<pre><code class="language-python">import re

DANGEROUS_PATTERNS = [
    r'\([^)]+\)\+\+',  # (x++)
    r'\([^)]+\+\)\+',  # (x+)+
    r'\*\+',           # *+
    r'\+\+',           # ++
]

def is_safe_pattern(pattern: str) -&gt; bool:
    for dangerous in DANGEROUS_PATTERNS:
        if re.search(dangerous, pattern):
            return False
    return True

# At ingress
if not is_safe_pattern(user_pattern):
    raise ValueError("Pattern contains exponential quantifiers")
</code></pre>
<p><strong>Cost</strong>: Heuristic may reject valid patterns, maintenance burden
<strong>Benefit</strong>: No FFI overhead, works with pure implementations</p>
<p>This is fragile. Attackers may find patterns your heuristics miss. Use as a defense-in-depth measure, not the primary mitigation.</p>
<h3 id="3-timeout-wrappers"><a class="header" href="#3-timeout-wrappers">3. Timeout Wrappers</a></h3>
<p>Wrap matcher evaluation in a timeout:</p>
<pre><code class="language-python">import signal

def with_timeout(func, timeout_ms):
    def handler(signum, frame):
        raise TimeoutError("Matcher exceeded timeout")

    signal.signal(signal.SIGALRM, handler)
    signal.setitimer(signal.ITIMER_REAL, timeout_ms / 1000.0)
    try:
        return func()
    finally:
        signal.setitimer(signal.ITIMER_REAL, 0)

# Usage
result = with_timeout(lambda: matcher.evaluate(req), timeout_ms=100)
</code></pre>
<p><strong>Cost</strong>: Adds signal overhead, doesnâ€™t prevent resource exhaustion (CPU burns for 100ms)
<strong>Benefit</strong>: Prevents infinite hangs, allows graceful degradation</p>
<p>This limits the blast radius but doesnâ€™t prevent the attack. The CPU still burns cycles on backtracking before the timeout fires.</p>
<h3 id="4-phase-11-re2-migration"><a class="header" href="#4-phase-11-re2-migration">4. Phase 11: RE2 Migration</a></h3>
<p>The roadmap includes migrating puma to <code>google-re2</code> (Python bindings to C++ RE2) and bumi to <code>re2js</code> (pure JavaScript port of RE2).</p>
<p>This would give linear-time regex without FFI overhead:</p>
<ul>
<li><strong>puma</strong>: ReDoS protection via mature C extension (similar perf to PyO3)</li>
<li><strong>bumi</strong>: ReDoS protection in pure TypeScript (no WASM boundary)</li>
</ul>
<p>At that point, all five variants would have linear-time regex. The crusty variants would shift from â€œsafety layerâ€ to â€œfull Rust pipelineâ€ for complex configs.</p>
<p><strong>Timeline</strong>: Phase 11 is planned but not yet scheduled.</p>
<h2 id="real-world-impact"><a class="header" href="#real-world-impact">Real-World Impact</a></h2>
<p>ReDoS is not theoretical. Production systems have been taken down by this attack:</p>
<ul>
<li><strong>Stack Overflow</strong> (2016): ReDoS in regex parsing caused 10-minute outage</li>
<li><strong>Cloudflare</strong> (2019): ReDoS in WAF regex caused global outage</li>
<li><strong>npm</strong> (multiple incidents): Package name validation regex caused service degradation</li>
</ul>
<p>The pattern is always the same:</p>
<ol>
<li>Trusted system uses a backtracking regex</li>
<li>Input grows slightly larger than expected</li>
<li>CPU pins at 100% for seconds/minutes</li>
<li>Worker threads hang, queue backs up, service dies</li>
</ol>
<p>The fix is always the same: migrate to linear-time regex.</p>
<h2 id="the-bottom-line-1"><a class="header" href="#the-bottom-line-1">The Bottom Line</a></h2>
<p>ReDoS is a <strong>security boundary</strong>, not a performance optimization.</p>
<p>For trusted patterns, any variant works. For untrusted patterns, backtracking engines are a <strong>critical vulnerability</strong>.</p>
<p>The data is unambiguous:</p>
<ul>
<li>At N=20: rumi is 6.5 million times faster than puma</li>
<li>At N=25: puma hangs forever, rumi returns in 11 nanoseconds</li>
</ul>
<p>If an attacker can control regex patterns in your matcher, you must use:</p>
<ul>
<li>rumi (Rust native)</li>
<li>puma-crusty (Python + Rust FFI)</li>
<li>bumi-crusty (TypeScript + WASM FFI)</li>
</ul>
<p>If you control all patterns, use the pure implementation for your language. The performance is better and the risk is zero.</p>
<p>And never, ever, let user-supplied regex patterns hit a backtracking engine without sanitization.</p>
<h2 id="related-pages-1"><a class="header" href="#related-pages-1">Related Pages</a></h2>
<ul>
<li><a href="#security-model">Security Model</a> â€” Full security guarantees and attack scenarios</li>
<li><a href="#benchmark-results">Benchmark Results</a> â€” Complete ReDoS benchmark data</li>
<li><a href="#performance-guide">Performance Guide</a> â€” Which variant to use for your threat model</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="architecture-1"><a class="header" href="#architecture-1">Architecture</a></h1>
<p>Why x.uma is built the way it is, and how the same architecture maps across Rust, Python, and TypeScript.</p>
<h2 id="design-philosophy-aces"><a class="header" href="#design-philosophy-aces">Design Philosophy: ACES</a></h2>
<p><strong>A</strong>daptable Â· <strong>C</strong>omposable Â· <strong>E</strong>xtensible Â· <strong>S</strong>ustainable</p>
<pre><code class="language-text">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Domain Adapters             â”‚
â”‚   xuma.http  xuma.claude  xuma.grpc â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              PORTS                  â”‚
â”‚     DataInput       ActionPort      â”‚
â”‚   (extract data)  (emit result)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              CORE                   â”‚
â”‚           Matcher Engine            â”‚
â”‚     Matcher Â· Predicate Â· Tree      â”‚
â”‚       (pure, domain-agnostic)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<p>This architecture applies to <strong>all implementations</strong> â€” rumi (Rust), puma (Python), bumi (TypeScript). The ports and hexagonal design are language-agnostic.</p>
<h2 id="the-extension-seam"><a class="header" href="#the-extension-seam">The Extension Seam</a></h2>
<p><code>TypedExtensionConfig</code> from xDS is the architectural seam:</p>
<pre><code class="language-protobuf">message TypedExtensionConfig {
  string name = 1;                       // adapter identifier
  google.protobuf.Any typed_config = 2;  // adapter config
}
</code></pre>
<p>Every <code>input</code> and <code>action</code> is a port. Adapters are concrete registered types.</p>
<h2 id="why-type-erasure-at-data-level"><a class="header" href="#why-type-erasure-at-data-level">Why Type Erasure at Data Level</a></h2>
<p>Key insight from the spike phase: erase types at the <strong>data level</strong>, not the predicate level.</p>
<h3 id="rust-rumi"><a class="header" href="#rust-rumi">Rust (rumi)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// MatchingData â€” the erased type
pub enum MatchingData { None, String(String), Int(i64), Bool(bool), Bytes(Vec&lt;u8&gt;) }

// DataInput â€” domain-specific, returns erased type
pub trait DataInput&lt;Ctx&gt;: Send + Sync + Debug {
    fn get(&amp;self, ctx: &amp;Ctx) -&gt; MatchingData;
}

// InputMatcher â€” domain-agnostic, NON-GENERIC
pub trait InputMatcher: Send + Sync + Debug {
    fn matches(&amp;self, value: &amp;MatchingData) -&gt; bool;
}
<span class="boring">}</span></code></pre>
<p><strong>Why this works:</strong></p>
<ul>
<li><code>InputMatcher</code> is non-generic â†’ same <code>ExactMatcher</code> works everywhere</li>
<li>No GATs or complex lifetimes</li>
<li>Battle-tested at Google scale (Envoy uses this approach)</li>
</ul>
<h3 id="python-puma"><a class="header" href="#python-puma">Python (puma)</a></h3>
<p>Python gets type erasure for free via union types:</p>
<pre><code class="language-python"># MatchingValue â€” union type replaces Rust's enum
type MatchingValue = str | int | bool | bytes | None

# DataInput â€” protocol with contravariant Ctx
class DataInput(Protocol[Ctx]):
    def get(self, ctx: Ctx, /) -&gt; MatchingValue: ...

# InputMatcher â€” protocol, non-generic
class InputMatcher(Protocol):
    def matches(self, value: MatchingValue, /) -&gt; bool: ...
</code></pre>
<p><strong>Key differences:</strong></p>
<ul>
<li>No enum needed â€” union types are native</li>
<li>Protocols instead of traits (runtime-checkable)</li>
<li><code>MatchingValue</code> is just a type alias, not a wrapped type</li>
</ul>
<h3 id="typescript-bumi"><a class="header" href="#typescript-bumi">TypeScript (bumi)</a></h3>
<pre><code class="language-typescript">// MatchingData â€” union type
type MatchingData = string | number | boolean | Uint8Array | null;

// DataInput â€” generic interface
interface DataInput&lt;Ctx&gt; {
  get(ctx: Ctx): MatchingData;
}

// InputMatcher â€” non-generic interface
interface InputMatcher {
  matches(value: MatchingData): boolean;
}
</code></pre>
<p><strong>Key differences:</strong></p>
<ul>
<li>Interfaces instead of traits/protocols</li>
<li>Structural typing (duck-typed) vs nominal (Rust) vs runtime-checkable (Python)</li>
<li>Union types native like Python</li>
</ul>
<h2 id="type-system-mappings"><a class="header" href="#type-system-mappings">Type System Mappings</a></h2>
<p>How the same architecture translates across languages:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Concept</th><th>Rust (rumi)</th><th>Python (puma)</th><th>TypeScript (bumi)</th></tr>
</thead>
<tbody>
<tr><td><strong>Erased data</strong></td><td><code>enum MatchingData</code></td><td><code>type MatchingValue</code> (union)</td><td><code>type MatchingData</code> (union)</td></tr>
<tr><td><strong>Extraction port</strong></td><td><code>trait DataInput&lt;Ctx&gt;</code></td><td><code>Protocol[Ctx]</code></td><td><code>interface DataInput&lt;Ctx&gt;</code></td></tr>
<tr><td><strong>Matching port</strong></td><td><code>trait InputMatcher</code></td><td><code>Protocol</code></td><td><code>interface InputMatcher</code></td></tr>
<tr><td><strong>Predicate tree</strong></td><td><code>enum Predicate&lt;Ctx&gt;</code></td><td><code>type Predicate[Ctx]</code> (union)</td><td><code>type Predicate&lt;Ctx&gt;</code> (discriminated union)</td></tr>
<tr><td><strong>OnMatch</strong></td><td><code>enum OnMatch&lt;Ctx, A&gt;</code></td><td><code>type OnMatch[Ctx, A]</code> (union)</td><td><code>type OnMatch&lt;Ctx, A&gt;</code> (discriminated union)</td></tr>
<tr><td><strong>Pattern match</strong></td><td><code>match</code> expression</td><td><code>match</code>/<code>case</code> statement</td><td><code>instanceof</code> checks</td></tr>
<tr><td><strong>Immutability</strong></td><td>Owned types, no <code>mut</code></td><td><code>@dataclass(frozen=True)</code></td><td><code>readonly</code> fields</td></tr>
<tr><td><strong>Thread safety</strong></td><td><code>Send + Sync</code> bounds</td><td>Not applicable (GIL)</td><td>Not applicable (single-threaded)</td></tr>
</tbody>
</table>
</div>
<h2 id="predicate-composition-1"><a class="header" href="#predicate-composition-1">Predicate Composition</a></h2>
<p>All three languages express the same Boolean logic:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust
pub enum Predicate&lt;Ctx&gt; {
    Single(SinglePredicate&lt;Ctx&gt;),
    And { predicates: Vec&lt;Predicate&lt;Ctx&gt;&gt; },
    Or { predicates: Vec&lt;Predicate&lt;Ctx&gt;&gt; },
    Not { predicate: Box&lt;Predicate&lt;Ctx&gt;&gt; },
}
<span class="boring">}</span></code></pre>
<pre><code class="language-python"># Python
type Predicate[Ctx] = SinglePredicate[Ctx] | And[Ctx] | Or[Ctx] | Not[Ctx]

@dataclass(frozen=True)
class And[Ctx]:
    predicates: tuple[Predicate[Ctx], ...]
</code></pre>
<pre><code class="language-typescript">// TypeScript â€” classes with instanceof, not discriminated unions
class SinglePredicate&lt;Ctx&gt; {
    constructor(
        readonly input: DataInput&lt;Ctx&gt;,
        readonly matcher: InputMatcher
    ) {}
}

class And&lt;Ctx&gt; {
    constructor(readonly predicates: readonly Predicate&lt;Ctx&gt;[]) {}
}

class Or&lt;Ctx&gt; {
    constructor(readonly predicates: readonly Predicate&lt;Ctx&gt;[]) {}
}

class Not&lt;Ctx&gt; {
    constructor(readonly predicate: Predicate&lt;Ctx&gt;) {}
}

type Predicate&lt;Ctx&gt; = SinglePredicate&lt;Ctx&gt; | And&lt;Ctx&gt; | Or&lt;Ctx&gt; | Not&lt;Ctx&gt;;

// Pattern matching via instanceof
if (p instanceof SinglePredicate) { /* ... */ }
else if (p instanceof And) { /* ... */ }
</code></pre>
<p><strong>Key difference:</strong> TypeScript uses classes with <code>instanceof</code> checks, not objects with <code>type</code> discriminator fields. This matches Pythonâ€™s dataclass approach more closely than traditional TS discriminated unions.</p>
<h2 id="onmatch-exclusivity-xds-semantics"><a class="header" href="#onmatch-exclusivity-xds-semantics">OnMatch Exclusivity (xDS Semantics)</a></h2>
<p>All three enforce the xDS invariant: action XOR nested matcher, never both.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust â€” illegal states unrepresentable
pub enum OnMatch&lt;Ctx, A&gt; {
    Action(A),
    Matcher(Box&lt;Matcher&lt;Ctx, A&gt;&gt;),
}
<span class="boring">}</span></code></pre>
<pre><code class="language-python"># Python â€” union type enforces exclusivity
type OnMatch[Ctx, A] = Action[A] | NestedMatcher[Ctx, A]

@dataclass(frozen=True)
class Action[A]:
    value: A

@dataclass(frozen=True)
class NestedMatcher[Ctx, A]:
    matcher: Matcher[Ctx, A]
</code></pre>
<pre><code class="language-typescript">// TypeScript â€” classes with instanceof
class Action&lt;A&gt; {
    constructor(readonly value: A) {}
}

class NestedMatcher&lt;Ctx, A&gt; {
    constructor(readonly matcher: Matcher&lt;Ctx, A&gt;) {}
}

type OnMatch&lt;Ctx, A&gt; = Action&lt;A&gt; | NestedMatcher&lt;Ctx, A&gt;;

// Check variant
if (onMatch instanceof Action) { return onMatch.value; }
else if (onMatch instanceof NestedMatcher) { return onMatch.matcher.evaluate(ctx); }
</code></pre>
<h2 id="evaluation-semantics"><a class="header" href="#evaluation-semantics">Evaluation Semantics</a></h2>
<p>First-match-wins is identical across all implementations:</p>
<ol>
<li>Evaluate <code>field_matchers</code> in order</li>
<li>Return action from first matching predicate</li>
<li>If nested matcher returns <code>None</code>/<code>null</code>, continue to next field</li>
<li>If no matches, consult <code>on_no_match</code> fallback</li>
<li>If no fallback, return <code>None</code>/<code>null</code></li>
</ol>
<h2 id="cross-language-conformance"><a class="header" href="#cross-language-conformance">Cross-Language Conformance</a></h2>
<p>All implementations pass the same YAML conformance test suite (<code>spec/tests/</code>):</p>
<pre><code class="language-yaml"># spec/tests/predicate/single/exact.yaml
name: "Single predicate with exact match"
cases:
  - input: "hello"
    matcher: { exact: "hello" }
    expected: { matches: true }
</code></pre>
<p><strong>Test runners:</strong></p>
<ul>
<li>Rust: <code>cargo test</code> (rumi-test crate) â€” 195 tests</li>
<li>Python: <code>pytest</code> (puma/tests/) â€” 194 tests</li>
<li>TypeScript: <code>bun test</code> (bumi/tests/) â€” 202 tests</li>
</ul>
<p>Each languageâ€™s test runner parses the same YAML fixtures, constructs matchers in its type system, and asserts the same expected outcomes. Total: <strong>268 tests across 5 variants</strong> (including puma-crusty and bumi-crusty).</p>
<h2 id="cratepackage-structure"><a class="header" href="#cratepackage-structure">Crate/Package Structure</a></h2>
<h3 id="rust-rumi-1"><a class="header" href="#rust-rumi-1">Rust (rumi)</a></h3>
<pre><code class="language-text">rumi/
â”œâ”€â”€ rumi/               # Core engine (package: rumi)
â””â”€â”€ ext/                # Domain extensions
    â”œâ”€â”€ test/           # rumi-test (conformance)
    â”œâ”€â”€ http/           # rumi-http
    â””â”€â”€ claude/         # rumi-claude (Claude Code hooks)
</code></pre>
<p>Dependencies point inward. Core knows nothing about domains.</p>
<h3 id="python-puma-1"><a class="header" href="#python-puma-1">Python (puma)</a></h3>
<pre><code class="language-text">puma/
â””â”€â”€ src/puma/
    â”œâ”€â”€ __init__.py     # Core types (flat exports)
    â”œâ”€â”€ _types.py       # Protocols
    â”œâ”€â”€ _predicate.py   # Predicates
    â”œâ”€â”€ _matcher.py     # Matcher tree
    â”œâ”€â”€ _string_matchers.py
    â””â”€â”€ http/
        â”œâ”€â”€ __init__.py # HTTP domain (flat exports)
        â”œâ”€â”€ _request.py
        â”œâ”€â”€ _inputs.py
        â””â”€â”€ _gateway.py # Gateway API compiler
</code></pre>
<p>Flat exports via <code>__init__.py</code>. Private modules prefixed with <code>_</code>.</p>
<h3 id="typescript-bumi-1"><a class="header" href="#typescript-bumi-1">TypeScript (bumi)</a></h3>
<pre><code class="language-text">bumi/
â””â”€â”€ src/
    â”œâ”€â”€ index.ts        # Core types
    â”œâ”€â”€ types.ts        # Interfaces
    â”œâ”€â”€ predicate.ts
    â”œâ”€â”€ matcher.ts
    â”œâ”€â”€ string-matchers.ts
    â””â”€â”€ http/
        â”œâ”€â”€ index.ts    # HTTP domain
        â”œâ”€â”€ request.ts
        â”œâ”€â”€ inputs.ts
        â””â”€â”€ gateway.ts  # Gateway API compiler
</code></pre>
<p>Standard TypeScript barrel exports.</p>
<h2 id="performance-characteristics"><a class="header" href="#performance-characteristics">Performance Characteristics</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Implementation</th><th>Regex Engine</th><th>Thread Safety</th><th>Memory Model</th><th>FFI Overhead</th></tr>
</thead>
<tbody>
<tr><td>rumi (Rust)</td><td><code>regex</code> crate (linear-time)</td><td>Send + Sync</td><td>Zero-copy where possible</td><td>N/A</td></tr>
<tr><td>puma (Python)</td><td><code>re</code> module (backtracking)</td><td>GIL (not parallel-safe)</td><td>Reference-counted</td><td>N/A</td></tr>
<tr><td>puma-crusty</td><td><code>regex</code> via PyO3 (linear-time)</td><td>GIL</td><td>Crossing FFI boundary</td><td>~200ns/call</td></tr>
<tr><td>bumi (TypeScript)</td><td>JS <code>RegExp</code> (V8 engine)</td><td>Single-threaded</td><td>Garbage-collected</td><td>N/A</td></tr>
<tr><td>bumi-crusty</td><td><code>regex</code> via WASM (linear-time)</td><td>Single-threaded</td><td>Crossing WASM boundary</td><td>~50ns/call</td></tr>
</tbody>
</table>
</div>
<p><strong>Benchmark highlights</strong> (from Phase 9):</p>
<ul>
<li>rumi evaluation: 11ns (native Rust, zero overhead)</li>
<li>puma evaluation: 200ns (Python overhead, CPython 3.14)</li>
<li>bumi evaluation: 9ns (V8 JIT, near-native performance)</li>
<li>puma-crusty: 400ns (Python + FFI crossing)</li>
<li>bumi-crusty: 60ns (WASM + boundary crossing)</li>
</ul>
<p><strong>ReDoS comparison</strong> (<code>(a+)+$</code> pattern, N=20):</p>
<ul>
<li>rumi: 11ns (linear-time regex)</li>
<li>puma: 72ms (exponential backtracking)</li>
<li>bumi: 11ms (V8 optimizations help but still exponential)</li>
<li>puma-crusty: 11ns (Rust regex via FFI)</li>
<li>bumi-crusty: 11ns (Rust regex via WASM)</li>
</ul>
<p>See <a href="#benchmark-results">Performance &gt; Benchmarks</a> for full data.</p>
<h2 id="why-multiple-implementations"><a class="header" href="#why-multiple-implementations">Why Multiple Implementations?</a></h2>
<p><strong>Ecosystem reach:</strong> Deploy matchers where your code lives.</p>
<ul>
<li>Rust: Envoy ext_proc, high-performance services</li>
<li>Python: Data pipelines, ML inference, scripting</li>
<li>TypeScript: Edge workers (Cloudflare, Deno), serverless</li>
</ul>
<p><strong>Reference consistency:</strong> All implementations are ports, not wrappers. Same architecture, same semantics, same test suite.</p>
<p><strong>Learning path:</strong> Pure implementations (rumi, puma, bumi) are readable references. Crusty variants (PyO3, WASM) provide Rust performance when needed.</p>
<h2 id="see-also-1"><a class="header" href="#see-also-1">See Also</a></h2>
<ul>
<li><a href="#roadmap">Roadmap</a> â€” Implementation status</li>
<li><a href="#adding-a-domain">Adding a Domain</a> â€” Extend with custom contexts</li>
<li><a href="#why-aces">Why ACES</a> â€” Design philosophy deep dive</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="why-aces"><a class="header" href="#why-aces">Why ACES</a></h1>
<p>The design principles behind x.uma.</p>
<h2 id="the-problem-1"><a class="header" href="#the-problem-1">The Problem</a></h2>
<p>Matchers are everywhere: routing, filtering, access control, feature flags. But most implementations are:</p>
<ul>
<li><strong>Tightly coupled</strong> to one domain (HTTP only, or gRPC only)</li>
<li><strong>Hard to extend</strong> without forking</li>
<li><strong>Inconsistent</strong> across languages</li>
</ul>
<h2 id="aces-principles"><a class="header" href="#aces-principles">ACES Principles</a></h2>
<h3 id="adaptable"><a class="header" href="#adaptable">Adaptable</a></h3>
<p>New domains plug in without touching core.</p>
<pre><code class="language-text">Adding HTTP support? â†’ Create rumi/ext/http/
Adding Claude Code hooks? â†’ Create rumi/ext/claude/
Core unchanged.
</code></pre>
<h3 id="composable"><a class="header" href="#composable">Composable</a></h3>
<p>Matchers nest. Predicates AND/OR/NOT. Trees recurse.</p>
<pre><code class="language-rust ignore">// Predicates compose naturally with AND/OR/NOT
Predicate::And(vec![
    Predicate::Single(SinglePredicate::new(
        Box::new(PathInput),
        Box::new(PrefixMatcher::new("/api/")),
    )),
    Predicate::Or(vec![
        Predicate::Single(SinglePredicate::new(
            Box::new(MethodInput),
            Box::new(ExactMatcher::new("GET")),
        )),
        Predicate::Single(SinglePredicate::new(
            Box::new(MethodInput),
            Box::new(ExactMatcher::new("POST")),
        )),
    ]),
])</code></pre>
<h3 id="extensible"><a class="header" href="#extensible">Extensible</a></h3>
<p><code>TypedExtensionConfig</code> is the extension seam. Register new types at startup, use them in configs.</p>
<pre><code class="language-yaml">input:
  "@type": "type.googleapis.com/xuma.http.v1.HeaderInput"
  header_name: "authorization"
</code></pre>
<h3 id="sustainable"><a class="header" href="#sustainable">Sustainable</a></h3>
<p>Core is stable. Growth happens at edges.</p>
<ul>
<li><strong>v1.0</strong> â†’ Core traits locked</li>
<li><strong>v1.x</strong> â†’ New domains, new matchers, same core</li>
<li><strong>No rewrites</strong> â†’ Hexagonal architecture pays off</li>
</ul>
<h2 id="inspired-by"><a class="header" href="#inspired-by">Inspired By</a></h2>
<ul>
<li><strong>Envoy</strong> â€” Production-proven matcher implementation at Google scale</li>
<li><strong>xDS</strong> â€” Protocol that powers service mesh configuration</li>
<li><strong>Hexagonal Architecture</strong> â€” Ports and adapters pattern</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="when-to-use-xuma"><a class="header" href="#when-to-use-xuma">When to Use x.uma</a></h1>
<p>x.uma isnâ€™t the right tool for everything. Hereâ€™s when it fits and when other engines are better.</p>
<h2 id="use-xuma-when"><a class="header" href="#use-xuma-when">Use x.uma When</a></h2>
<h3 id="http-routing-and-traffic-control"><a class="header" href="#http-routing-and-traffic-control">HTTP Routing and Traffic Control</a></h3>
<p>Youâ€™re building HTTP routers, API gateways, or traffic shapers. x.uma implements the same matching semantics Envoy uses for routing at Google scale.</p>
<p><strong>Concrete use cases:</strong></p>
<ul>
<li>Multi-tenant API gateways (route by header, method, path)</li>
<li>Feature flags based on request context</li>
<li>A/B testing routing (route users to backend variants)</li>
<li>Traffic splitting for canary deployments</li>
<li>Rate limit rule matching before quota enforcement</li>
</ul>
<p><strong>Why x.uma:</strong> Gateway API compiler built-in. <code>HttpRouteMatch</code> â†’ <code>Matcher</code> translation is a first-class feature. Path prefix matching, header matching, query param matching â€” all tested against 268 conformance fixtures.</p>
<h3 id="event-filtering-and-message-routing"><a class="header" href="#event-filtering-and-message-routing">Event Filtering and Message Routing</a></h3>
<p>Youâ€™re processing event streams (Kafka, Kinesis, message queues) and need first-match-wins routing logic.</p>
<p><strong>Concrete use cases:</strong></p>
<ul>
<li>CloudEvent filtering by type, source, extensions</li>
<li>Message bus routing (AMQP, MQTT)</li>
<li>Webhook dispatchers (route incoming webhooks by headers, payload fields)</li>
<li>Log aggregation pipelines (route by severity, source, tags)</li>
</ul>
<p><strong>Why x.uma:</strong> Domain-agnostic core. Implement <code>DataInput</code> for your event type, reuse all the predicate composition and string matching. The same AND/OR/NOT logic, the same depth limits.</p>
<h3 id="polyglot-codebases"><a class="header" href="#polyglot-codebases">Polyglot Codebases</a></h3>
<p>Your system spans Rust, Python, and TypeScript. You need consistent matching behavior across all three.</p>
<p><strong>Concrete use cases:</strong></p>
<ul>
<li>Rust ext_proc filter + Python control plane + TypeScript edge workers</li>
<li>ML inference pipelines (Python) calling routing services (Rust)</li>
<li>Cloudflare Workers (TypeScript) with backend services (Rust)</li>
</ul>
<p><strong>Why x.uma:</strong> Three native implementations (rumi, puma, bumi) plus Rust bindings (puma-crusty, bumi-crusty). All pass the same test suite. Write matchers once, run anywhere.</p>
<h3 id="envoy-proven-semantics"><a class="header" href="#envoy-proven-semantics">Envoy-Proven Semantics</a></h3>
<p>You want xDS Unified Matcher API semantics without running Envoy. Maybe youâ€™re building a sidecar, a policy engine, or a custom proxy.</p>
<p><strong>Concrete use cases:</strong></p>
<ul>
<li>Custom proxies that need Envoy-compatible route matching</li>
<li>Policy engines that compile xDS <code>Matcher</code> proto into evaluation logic</li>
<li>Testing Envoy configs without spinning up Envoy itself</li>
</ul>
<p><strong>Why x.uma:</strong> Direct implementation of the xDS spec. The proto definitions are the source of truth. Nested matcher failure propagation, on_no_match fallback, first-match-wins â€” all match Envoyâ€™s behavior.</p>
<h2 id="use-opa-when"><a class="header" href="#use-opa-when">Use OPA When</a></h2>
<h3 id="general-purpose-policy-language"><a class="header" href="#general-purpose-policy-language">General-Purpose Policy Language</a></h3>
<p>You need to query complex input documents, join data from multiple sources, or express policies that donâ€™t fit a tree structure.</p>
<p><strong>Example:</strong> â€œAllow if user is in the â€˜engineeringâ€™ team AND the resource has tag â€˜internalâ€™ AND itâ€™s a weekday during business hours.â€</p>
<p>OPAâ€™s Rego is Datalog â€” you can express arbitrary joins and aggregations. x.uma is tree traversal with first-match-wins. Different models.</p>
<h3 id="kubernetes-admission-control"><a class="header" href="#kubernetes-admission-control">Kubernetes Admission Control</a></h3>
<p>Youâ€™re using Gatekeeper to enforce OPA policies as Kubernetes admission webhooks.</p>
<p>The CNCF ecosystem is built around OPA + Gatekeeper. x.uma has no Kubernetes-specific tooling.</p>
<h3 id="compliance-and-audit"><a class="header" href="#compliance-and-audit">Compliance and Audit</a></h3>
<p>You need to generate compliance reports showing which policies matched, which conditions were evaluated, and why a decision was made.</p>
<p>OPA has mature audit tooling. x.uma has trace output (evaluate + explain), but itâ€™s debugging-focused, not compliance-focused.</p>
<h2 id="use-cedar-when"><a class="header" href="#use-cedar-when">Use Cedar When</a></h2>
<h3 id="aws-ecosystem"><a class="header" href="#aws-ecosystem">AWS Ecosystem</a></h3>
<p>Youâ€™re using AWS services (Verified Permissions, Verified Access, Cognito) or building authorization for AWS-integrated apps.</p>
<p>Cedar integrates natively with AWS IAM, Cognito user pools, and resource tags. x.uma has no AWS-specific integrations.</p>
<h3 id="formal-verification"><a class="header" href="#formal-verification">Formal Verification</a></h3>
<p>You need provably correct policies. Cedar uses Dafny to verify policies canâ€™t produce unintended outcomes (no confused deputy bugs, no authorization bypass).</p>
<p>x.uma has type safety and depth limits, but no formal verification.</p>
<h3 id="classic-authorization-parc-model"><a class="header" href="#classic-authorization-parc-model">Classic Authorization (PARC Model)</a></h3>
<p>Your domain maps cleanly to Principal-Action-Resource-Context. Youâ€™re answering â€œCan this user perform this action on this resource?â€</p>
<p>Cedar is purpose-built for this. x.uma is matcher trees â€” you can represent PARC, but Cedar makes it native.</p>
<h2 id="use-zanzibaropenfga-when"><a class="header" href="#use-zanzibaropenfga-when">Use Zanzibar/OpenFGA When</a></h2>
<h3 id="graph-based-permissions"><a class="header" href="#graph-based-permissions">Graph-Based Permissions</a></h3>
<p>Your authorization model is a graph. Users â†’ teams â†’ folders â†’ documents. You need to answer â€œCan alice view doc123?â€ by checking if a path exists.</p>
<p><strong>Example use cases:</strong></p>
<ul>
<li>Google Drive-style sharing (folders inherit permissions)</li>
<li>Organization hierarchies (managers can approve for their reports)</li>
<li>Social graphs (friends-of-friends visibility)</li>
</ul>
<p>x.uma evaluates predicates against structured input. It doesnâ€™t traverse graphs. Wrong tool.</p>
<h2 id="comparison-table"><a class="header" href="#comparison-table">Comparison Table</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>x.uma</th><th>OPA</th><th>Cedar</th><th>Zanzibar/OpenFGA</th></tr>
</thead>
<tbody>
<tr><td><strong>Model</strong></td><td>Tree traversal, first-match-wins</td><td>Datalog queries</td><td>PARC authorization</td><td>Graph traversal</td></tr>
<tr><td><strong>Language</strong></td><td>Matcher proto (compiled)</td><td>Rego</td><td>Cedar</td><td>Tuple-based</td></tr>
<tr><td><strong>Domain</strong></td><td>Agnostic</td><td>Agnostic</td><td>Authorization</td><td>Authorization</td></tr>
<tr><td><strong>Evaluation</strong></td><td>O(depth Ã— predicates)</td><td>O(policy complexity)</td><td>O(policy complexity)</td><td>O(graph traversal)</td></tr>
<tr><td><strong>Cross-language</strong></td><td>Rust, Python, TypeScript (native)</td><td>Go, WASM bindings</td><td>Rust, Java bindings</td><td>Go, varies by impl</td></tr>
<tr><td><strong>Formal verification</strong></td><td>No</td><td>No</td><td>Yes (Dafny)</td><td>No</td></tr>
<tr><td><strong>HTTP routing</strong></td><td>Built-in (Gateway API)</td><td>DIY</td><td>DIY</td><td>Not applicable</td></tr>
<tr><td><strong>Best for</strong></td><td>Routing, filtering, polyglot</td><td>General policy</td><td>AWS, formal correctness</td><td>Social graphs, hierarchies</td></tr>
</tbody>
</table>
</div>
<h2 id="theyre-not-mutually-exclusive"><a class="header" href="#theyre-not-mutually-exclusive">Theyâ€™re Not Mutually Exclusive</a></h2>
<p>Some systems combine engines:</p>
<p><strong>OPA + x.uma:</strong> OPA makes high-level allow/deny decision. If allowed, x.uma routes to specific backend based on request attributes.</p>
<p>Example: OPA checks â€œIs this user authorized for the admin API?â€ (yes/no). x.uma routes to admin-v1 vs admin-v2 based on feature flags in headers.</p>
<p><strong>Cedar + x.uma:</strong> Cedar handles â€œcan this agent invoke this tool?â€ x.uma handles â€œwhich tool variant should execute given these parameters?â€</p>
<p>Example: Cedar checks â€œCan agent use read_file?â€ (yes/no). x.uma routes to sandboxed reader vs full reader based on path prefix.</p>
<p><strong>OpenFGA + x.uma:</strong> OpenFGA answers â€œdoes user have viewer permission on resource?â€ x.uma handles â€œwhich cache strategy for this request?â€</p>
<p>Example: OpenFGA checks graph for userâ†’resource edge. x.uma routes to CDN vs origin based on request headers.</p>
<h2 id="when-xuma-is-wrong"><a class="header" href="#when-xuma-is-wrong">When x.uma Is Wrong</a></h2>
<h3 id="complex-joins-and-aggregations"><a class="header" href="#complex-joins-and-aggregations">Complex Joins and Aggregations</a></h3>
<p>If your policy is â€œallow if user belongs to a team that owns a resource in a project with budget &gt; $1000â€, you need Rego. x.uma is tree traversal, not SQL.</p>
<h3 id="stateful-decisions"><a class="header" href="#stateful-decisions">Stateful Decisions</a></h3>
<p>If your policy depends on â€œnumber of requests in the last 5 minutesâ€ or â€œthis is the 3rd failed attemptâ€, x.uma doesnâ€™t help. It evaluates one request at a time with no state.</p>
<p>Use rate limiters (Envoyâ€™s rate limit service, Redis + Lua) or stateful policy engines (OPA with external data).</p>
<h3 id="graph-queries"><a class="header" href="#graph-queries">Graph Queries</a></h3>
<p>If your policy is â€œallow if thereâ€™s a path in the org chart from user to resource ownerâ€, you need a graph database or Zanzibar-style engine.</p>
<p>x.uma evaluates predicates. It doesnâ€™t traverse relationships.</p>
<h2 id="decision-framework"><a class="header" href="#decision-framework">Decision Framework</a></h2>
<p>Answer these questions:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Question</th><th>Answer</th><th>Recommendation</th></tr>
</thead>
<tbody>
<tr><td>Is this HTTP routing or event filtering?</td><td>Yes</td><td><strong>x.uma</strong></td></tr>
<tr><td>Do I need graph traversal?</td><td>Yes</td><td><strong>OpenFGA/SpiceDB</strong></td></tr>
<tr><td>Is this classic authorization (can user X do Y on Z)?</td><td>Yes</td><td><strong>Cedar</strong> (if AWS) or <strong>OPA</strong></td></tr>
<tr><td>Do I need Datalog-style queries?</td><td>Yes</td><td><strong>OPA</strong></td></tr>
<tr><td>Is my codebase polyglot (Rust + Python + TypeScript)?</td><td>Yes</td><td><strong>x.uma</strong></td></tr>
<tr><td>Do I need formal verification?</td><td>Yes</td><td><strong>Cedar</strong></td></tr>
<tr><td>Am I running in Kubernetes?</td><td>Yes</td><td><strong>OPA + Gatekeeper</strong></td></tr>
</tbody>
</table>
</div>
<h2 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h2>
<p>x.uma is fast (sub-microsecond evaluation, linear-time regex in Rust implementations). But:</p>
<ul>
<li><strong>For complex policies with hundreds of rules:</strong> Compiled Rego (OPA) might be faster. Benchmark your workload.</li>
<li><strong>For high-cardinality attribute checks:</strong> Redis + Lua or custom C++ might be faster. x.uma is general-purpose, not hyper-optimized.</li>
<li><strong>For graph queries:</strong> Specialized graph databases (Zanzibar, SpiceDB) will be orders of magnitude faster.</li>
</ul>
<p>See Performance &gt; Benchmarks for concrete numbers.</p>
<h2 id="sources"><a class="header" href="#sources">Sources</a></h2>
<p><strong>Policy Engines:</strong></p>
<ul>
<li><a href="https://www.openpolicyagent.org/">OPA Documentation</a> â€” CNCF graduated project</li>
<li><a href="https://www.cedarpolicy.com/">Cedar Language Guide</a> â€” AWS authorization language</li>
<li><a href="https://research.google/pubs/zanzibar-googles-consistent-global-authorization-system/">Zanzibar: Googleâ€™s Authorization System</a> â€” ReBAC research</li>
<li><a href="https://openfga.dev/">OpenFGA</a> â€” Open-source Zanzibar implementation</li>
</ul>
<p><strong>x.uma Positioning:</strong></p>
<ul>
<li><a href="https://www.envoyproxy.io/docs/envoy/latest/api-v3/xds/type/matcher/v3/matcher.proto">xDS Unified Matcher API</a> â€” Source protocol</li>
<li><a href="https://gateway-api.sigs.k8s.io/">Gateway API Specification</a> â€” HTTP route matching semantics</li>
<li>x.uma implements xDS for polyglot routing and filtering, not general authorization</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="policy-landscape"><a class="header" href="#policy-landscape">Policy Landscape</a></h1>
<p>Where x.uma fits in the broader policy engine ecosystem, and why agent tool control is greenfield territory.</p>
<h2 id="xuma-is-a-policy-engine"><a class="header" href="#xuma-is-a-policy-engine">x.uma IS a Policy Engine</a></h2>
<p>At its core, x.uma evaluates structured input against composable rules and returns a decision. This is the fundamental contract of every policy engine:</p>
<pre><code class="language-text">Input â†’ Rules â†’ Decision
</code></pre>
<p>x.uma implements the xDS Unified Matcher API â€” the same matching engine Envoy uses for RBAC enforcement, rate limiting, and routing at Google scale. The architecture is proven in production at companies running millions of requests per second.</p>
<p>The mechanics:</p>
<ol>
<li>Structured input (HTTP request, agent context, etc.)</li>
<li>Evaluation against a matcher tree (AND/OR/NOT predicates)</li>
<li>Return a decision (generic action <code>A</code>)</li>
</ol>
<p>This is policy evaluation. The domain-agnostic core means the same engine handles HTTP routing decisions and agent tool control decisions.</p>
<h2 id="the-established-standards"><a class="header" href="#the-established-standards">The Established Standards</a></h2>
<p>The policy engine landscape has mature, well-adopted standards. Each emerged to solve specific problems.</p>
<h3 id="opa-open-policy-agent"><a class="header" href="#opa-open-policy-agent">OPA (Open Policy Agent)</a></h3>
<p><strong>What it is:</strong> CNCF graduated project maintained by Styra. Domain-agnostic policy evaluation using the Rego language (Datalog-based).</p>
<p><strong>Model:</strong> Inputâ†’Rulesâ†’Decision. You write Rego policies that query input documents and produce allow/deny decisions (or complex JSON responses).</p>
<p><strong>Adoption:</strong> Netflix (microservice authorization), Goldman Sachs (compliance), Kubernetes Gatekeeper (admission control).</p>
<p><strong>Strength:</strong> Highly flexible. Works for any domain because Rego is a general-purpose query language.</p>
<h3 id="cedar"><a class="header" href="#cedar">Cedar</a></h3>
<p><strong>What it is:</strong> AWS-developed authorization language, open-sourced in 2023. Purpose-built for access control with formal verification.</p>
<p><strong>Model:</strong> PARC (Principal-Action-Resource-Context). Policies explicitly state which principals can perform which actions on which resources, given context.</p>
<pre><code class="language-cedar">permit(
  principal == User::"alice",
  action == Action::"readFile",
  resource in Folder::"docs"
);
</code></pre>
<p><strong>Adoption:</strong> Amazon Verified Permissions (GA), AWS Verified Access.</p>
<p><strong>Strength:</strong> Formal verification via Dafny â€” provably correct policies. The language design prevents entire classes of authorization bugs.</p>
<h3 id="xacml"><a class="header" href="#xacml">XACML</a></h3>
<p><strong>What it is:</strong> OASIS standard since 2001. XML-based policy language that coined the PEP/PDP/PAP/PIP vocabulary the entire industry uses.</p>
<p><strong>Model:</strong> Policy Decision Point (PDP) evaluates requests from Policy Enforcement Points (PEP). Policies authored in Policy Administration Points (PAP), context from Policy Information Points (PIP).</p>
<p><strong>Adoption:</strong> Government, healthcare, finance (HIPAA compliance workflows).</p>
<p><strong>Strength:</strong> Standardization. When two systems need to interoperate on authorization, XACML is the lingua franca.</p>
<h3 id="zanzibar-and-relationship-engines"><a class="header" href="#zanzibar-and-relationship-engines">Zanzibar and Relationship Engines</a></h3>
<p><strong>What they are:</strong> Googleâ€™s Zanzibar (2019 paper), OpenFGA, SpiceDB. Relationship-based access control (ReBAC) via graph traversal.</p>
<p><strong>Model:</strong> Not rule evaluation. Instead: â€œDoes a path exist in the authorization graph from user to resource?â€</p>
<p>Example: â€œCan alice view doc123?â€ â†’ Check if graph contains <code>alice -[member]â†’ team -[viewer]â†’ doc123</code>.</p>
<p><strong>Adoption:</strong> Google (Drive, Calendar, Cloud), Airbnb (OpenFGA), Auth0 (FGA product).</p>
<p><strong>Strength:</strong> Scales to billions of relationships. Natural fit for social graphs and hierarchical permissions.</p>
<p><strong>Key difference:</strong> ReBAC engines donâ€™t evaluate predicates. They traverse graphs. Different problem space.</p>
<h2 id="the-agent-policy-gap"><a class="header" href="#the-agent-policy-gap">The Agent Policy Gap</a></h2>
<p>As of February 2026, there is no established standard for AI agent tool control policies. The space is fragmented.</p>
<h3 id="what-exists-today"><a class="header" href="#what-exists-today">What Exists Today</a></h3>
<p><strong>AWS Bedrock AgentCore</strong> (re:Invent 2025): Cedar-based policy engine for agent-to-tool interactions. Closest production system. Uses Cedarâ€™s PARC model: agent is principal, tool is action, parameters are context.</p>
<p><strong>OpenAI Agents SDK</strong>: â€œGuardrailsâ€ with binary tripwires. Simple allow/deny on tool invocations based on pattern matching.</p>
<p><strong>NVIDIA NeMo Guardrails</strong>: â€œRailsâ€ DSL (Colang) for conversation flow control. Includes tool call filtering but tightly coupled to NeMo.</p>
<p><strong>Claude Code</strong>: Hooks system with matcher patterns. <code>PreToolUse</code> hooks support allow/deny/ask (ternary decision) plus parameter mutation.</p>
<p><strong>MCP (Model Context Protocol)</strong>: No built-in policy layer. Delegates to host implementation. The protocol itself is policy-agnostic.</p>
<h3 id="industry-recognition-of-the-gap"><a class="header" href="#industry-recognition-of-the-gap">Industry Recognition of the Gap</a></h3>
<p><strong>OWASP Top 10 for Agentic Applications (2026)</strong> identifies â€œTool Misuseâ€ as risk #2. Recommendations:</p>
<ul>
<li>Policy controls at tool boundaries</li>
<li>Principle of Least Agency (minimize tool access)</li>
<li>Audit logging of tool invocations</li>
</ul>
<p><strong>MIT Technology Review</strong> (Feb 2026, â€œFrom Guardrails to Governanceâ€): Advocates treating agents as semi-autonomous users and enforcing rules at boundaries, not just prompting.</p>
<p>The pattern is clear: the industry recognizes the need for policy control but lacks a unified standard. Current approaches are vendor-specific.</p>
<h2 id="where-xuma-fits"><a class="header" href="#where-xuma-fits">Where x.uma Fits</a></h2>
<p>x.uma is uniquely positioned because it was designed domain-agnostic from day one.</p>
<h3 id="why-this-matters"><a class="header" href="#why-this-matters">Why This Matters</a></h3>
<p>Most policy engines are built for one domain and later adapted:</p>
<ul>
<li>OPA: started as microservice authorization, generalized</li>
<li>Cedar: built for AWS resource authorization</li>
<li>Guardrails: built for LLM conversation control</li>
</ul>
<p>x.uma started with the insight that <strong>matching is matching</strong>, whether youâ€™re routing HTTP traffic or controlling agent tool access. The same AND/OR/NOT predicate logic, the same first-match-wins semantics, the same depth limits and ReDoS protection.</p>
<p>The architecture makes this natural:</p>
<pre><code class="language-text">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       Domain Adapters           â”‚
â”‚  xuma.http  xuma.claude  xuma.grpc â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            PORTS                â”‚
â”‚   DataInput      ActionPort     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            CORE                 â”‚
â”‚        Matcher Engine           â”‚
â”‚    (domain-agnostic)            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<p>Adding Claude Code hooks is just another domain adapter. Core unchanged. Adding MCP, OpenAI, or any other agent framework would be another.</p>
<h3 id="cross-language-reality"><a class="header" href="#cross-language-reality">Cross-Language Reality</a></h3>
<p>Real systems are polyglot:</p>
<ul>
<li>ML inference pipelines: Python</li>
<li>Edge workers: TypeScript (Cloudflare, Deno)</li>
<li>High-throughput services: Rust</li>
</ul>
<p>x.uma works natively in all three:</p>
<ul>
<li><strong>rumi</strong> (Rust): Zero-overhead, Send+Sync for concurrency</li>
<li><strong>puma</strong> (Python): Pure Python, no FFI for simple cases</li>
<li><strong>bumi</strong> (TypeScript): Edge-native, runs in V8 isolates</li>
</ul>
<p>Plus Rust-backed bindings (<code>puma-crusty</code>, <code>bumi-crusty</code>) when performance matters.</p>
<p>This isnâ€™t just convenience. Agent systems span languages. Your agent runtime might be Python, your ext_proc filter might be Rust, your edge worker might be TypeScript. One policy standard that works everywhere.</p>
<h3 id="battle-tested-semantics"><a class="header" href="#battle-tested-semantics">Battle-Tested Semantics</a></h3>
<p>x.uma doesnâ€™t invent new policy semantics. It implements xDS Unified Matcher API â€” the protocol Envoy uses. This means:</p>
<ul>
<li><strong>Proven at scale</strong>: Google runs this in production</li>
<li><strong>Well-specified</strong>: xDS proto definitions are the source of truth</li>
<li><strong>Debugged edge cases</strong>: nested matcher failure semantics, on_no_match fallback behavior</li>
</ul>
<p>Youâ€™re not betting on a new policy language. Youâ€™re using Googleâ€™s battle-tested approach in a new domain.</p>
<h2 id="xumaclaude--claude-code-as-first-agent-domain"><a class="header" href="#xumaclaude--claude-code-as-first-agent-domain">xuma.claude â€” Claude Code as First Agent Domain</a></h2>
<p>The <code>xuma.claude.v1</code> domain applies x.umaâ€™s matcher architecture to Claude Codeâ€™s hook event system â€” the first concrete agent adapter.</p>
<h3 id="why-start-with-claude-code"><a class="header" href="#why-start-with-claude-code">Why Start with Claude Code?</a></h3>
<p>Claude Code has a rich hook event model with 9 event types spanning tool lifecycle, agent lifecycle, user interaction, and session management. This makes it an ideal first domain adapter:</p>
<ul>
<li><strong>Structured context</strong>: Every hook receives <code>session_id</code>, <code>cwd</code>, <code>permission_mode</code>, plus event-specific fields</li>
<li><strong>Multiple decision models</strong>: allow/deny/ask + modify (tools), approve/block (stop), feedback (post-tool)</li>
<li><strong>Real enforcement point</strong>: Hooks ARE a Policy Enforcement Point (PEP) â€” x.uma becomes the PDP behind them</li>
</ul>
<h3 id="mapping-the-parc-model"><a class="header" href="#mapping-the-parc-model">Mapping the PARC Model</a></h3>
<p>Cedarâ€™s PARC model (Principal-Action-Resource-Context) maps naturally to agent scenarios:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>PARC Element</th><th>Agent Equivalent</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><strong>Principal</strong></td><td>Agent (or user delegating to agent)</td><td><code>agent:claude-sonnet-4</code></td></tr>
<tr><td><strong>Action</strong></td><td>Tool being invoked</td><td><code>tools:bash</code>, <code>tools:read_file</code></td></tr>
<tr><td><strong>Resource</strong></td><td>What the tool operates on</td><td><code>/etc/passwd</code>, <code>s3://bucket/data</code></td></tr>
<tr><td><strong>Context</strong></td><td>Parameters, session state</td><td><code>{depth: 5, recursive: true}</code></td></tr>
</tbody>
</table>
</div>
<h3 id="decision-model-spectrum"><a class="header" href="#decision-model-spectrum">Decision Model Spectrum</a></h3>
<p>Agent policy engines need to support the full decision spectrum:</p>
<p><strong>Binary:</strong> Allow or deny.</p>
<pre><code class="language-yaml">action: { allow: true }
</code></pre>
<p><strong>Ternary:</strong> Allow, deny, or escalate to human.</p>
<pre><code class="language-yaml">action: { escalate: { reason: "Sensitive file access" } }
</code></pre>
<p><strong>Mutation:</strong> Modify tool input before execution.</p>
<pre><code class="language-yaml">action: {
  modify: {
    max_depth: 3,  # Override requested depth
    exclude_patterns: ["*.key", "*.pem"]
  }
}
</code></pre>
<p>Claude Codeâ€™s hook model (allow/deny/ask + modify) is the richest in the industry. Starting here means the architecture handles simpler models (binary, ternary) by subsumption.</p>
<h3 id="proto-namespace"><a class="header" href="#proto-namespace">Proto Namespace</a></h3>
<p><code>xuma.claude.v1</code> is the proto package for Claude Code hooks.</p>
<p>Type URLs follow the standard pattern:</p>
<ul>
<li><code>type.googleapis.com/xuma.claude.v1.HookContext</code></li>
<li><code>type.googleapis.com/xuma.claude.v1.AllowAction</code></li>
<li><code>type.googleapis.com/xuma.claude.v1.BlockAction</code></li>
</ul>
<p>The hexagonal architecture means adding other agent frameworks is just another domain adapter â€” <code>xuma.mcp.v1</code>, <code>xuma.openai.v1</code>, etc. â€” without touching core or the Claude adapter.</p>
<h2 id="comparison-to-established-engines"><a class="header" href="#comparison-to-established-engines">Comparison to Established Engines</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th></th><th>OPA</th><th>Cedar</th><th>x.uma</th></tr>
</thead>
<tbody>
<tr><td><strong>Language</strong></td><td>Rego (Datalog)</td><td>Cedar (custom)</td><td>Matcher trees (compiled from proto)</td></tr>
<tr><td><strong>Model</strong></td><td>Inputâ†’Rulesâ†’JSON</td><td>PARCâ†’permit/forbid</td><td>Contextâ†’Predicatesâ†’Action</td></tr>
<tr><td><strong>Domain focus</strong></td><td>Agnostic</td><td>Authorization</td><td>Agnostic</td></tr>
<tr><td><strong>Agent-native</strong></td><td>No</td><td>Partial (AgentCore uses it)</td><td>Yes (<code>xuma.claude</code> first, more domains planned)</td></tr>
<tr><td><strong>Cross-language</strong></td><td>Go + WASM bindings</td><td>Rust + Java bindings</td><td>Rust, Python, TypeScript (native + bindings)</td></tr>
<tr><td><strong>Formal verification</strong></td><td>No</td><td>Yes (Dafny proofs)</td><td>Type safety + depth limits + linear-time regex</td></tr>
<tr><td><strong>Extension model</strong></td><td>Rego functions</td><td>Cedar extensions (limited)</td><td><code>TypedExtensionConfig</code> (open)</td></tr>
<tr><td><strong>Evaluation model</strong></td><td>Query language</td><td>Policy search + decision</td><td>Tree traversal (first-match-wins)</td></tr>
</tbody>
</table>
</div>
<h3 id="when-to-use-what"><a class="header" href="#when-to-use-what">When to Use What</a></h3>
<p><strong>Use OPA if:</strong></p>
<ul>
<li>You need a general-purpose policy language</li>
<li>Complex queries over input data</li>
<li>Integration with Kubernetes (Gatekeeper)</li>
</ul>
<p><strong>Use Cedar if:</strong></p>
<ul>
<li>AWS ecosystem</li>
<li>Formal verification is critical</li>
<li>Classic authorization (PARC model is natural)</li>
</ul>
<p><strong>Use x.uma if:</strong></p>
<ul>
<li>Agent event policy is your domain</li>
<li>Polyglot codebase (Rust + Python + TypeScript)</li>
<li>You want Envoy-proven semantics</li>
<li>Domain adapters fit your architecture</li>
</ul>
<p>Theyâ€™re not mutually exclusive. Some systems use OPA for high-level policy and x.uma for low-level matcher logic (HTTP routing, tool filtering).</p>
<h2 id="the-vision"><a class="header" href="#the-vision">The Vision</a></h2>
<p>x.uma is alpha (v0.1). This is the roadmap:</p>
<p><strong>Phase 6-7 (current):</strong> Complete <code>bumi</code> (TypeScript) and Rust bindings (<code>puma-crusty</code>, <code>bumi-crusty</code>).</p>
<p><strong>Phase 8:</strong> Enrich <code>xuma.claude.v1</code> with full hook event model.</p>
<p><strong>Phase 9:</strong> Benchmarks. Prove performance against native implementations.</p>
<p><strong>v1.0:</strong> Lock core traits. Extension ecosystem opens.</p>
<p><strong>Beyond v1.0:</strong> Additional agent domains (<code>xuma.mcp</code>, <code>xuma.openai</code>) as the need materializes. The vendor-agnostic agent policy standard emerges from concrete implementations, not from premature abstraction.</p>
<p>No established standard exists for AI agent tool policy. This is greenfield. x.umaâ€™s approach â€” start concrete with one agent (Claude Code), prove the architecture, then generalize â€” is how standards earn adoption.</p>
<p>The gap exists. The need is recognized (OWASP, MIT Tech Review, AWS AgentCore). x.uma fills it with production-proven architecture, cross-language support, and domain-agnostic design.</p>
<h2 id="sources-1"><a class="header" href="#sources-1">Sources</a></h2>
<p><strong>Policy Standards:</strong></p>
<ul>
<li><a href="https://www.openpolicyagent.org/">OPA Documentation</a> â€” CNCF graduated project</li>
<li><a href="https://www.cedarpolicy.com/">Cedar Language Guide</a> â€” AWS open-source authorization language</li>
<li><a href="https://www.oasis-open.org/committees/xacml/">XACML v3.0 Specification</a> â€” OASIS standard</li>
<li><a href="https://research.google/pubs/zanzibar-googles-consistent-global-authorization-system/">Zanzibar: Googleâ€™s Authorization System</a> â€” ReBAC research paper</li>
</ul>
<p><strong>Agent Policy Landscape:</strong></p>
<ul>
<li><a href="https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/policy.html">AWS Bedrock AgentCore Policy Engine</a> â€” Cedar-based agent authorization</li>
<li><a href="https://openai.github.io/openai-agents-python/guardrails/">OpenAI Agents SDK Guardrails</a> â€” Binary tripwire model</li>
<li><a href="https://github.com/NVIDIA-NeMo/Guardrails">NVIDIA NeMo Guardrails</a> â€” Rails DSL for conversation control</li>
<li><a href="https://docs.anthropic.com/en/docs/claude-code/hooks">Claude Code Hooks</a> â€” PreToolUse matcher patterns</li>
<li><a href="https://modelcontextprotocol.io/specification/2025-11-25">Model Context Protocol</a> â€” Protocol specification</li>
</ul>
<p><strong>Security &amp; Governance:</strong></p>
<ul>
<li><a href="https://genai.owasp.org/resource/owasp-top-10-for-agentic-applications-for-2026/">OWASP Top 10 for Agentic Applications (2026)</a> â€” Tool Misuse as risk #2</li>
<li><a href="https://www.technologyreview.com/2026/02/04/1131014/from-guardrails-to-governance-a-ceos-guide-for-securing-agentic-systems/">MIT Technology Review: From Guardrails to Governance</a> â€” Treating agents as semi-autonomous users</li>
</ul>
<p><strong>xDS &amp; Envoy:</strong></p>
<ul>
<li><a href="https://www.envoyproxy.io/docs/envoy/latest/api-docs/xds_protocol">xDS Protocol</a> â€” Service mesh configuration protocol</li>
<li><a href="https://github.com/envoyproxy/envoy/tree/main/source/common/matcher">Envoy Matcher Implementation</a> â€” Reference C++ implementation</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="proto-api-reference"><a class="header" href="#proto-api-reference">Proto API Reference</a></h1>
<blockquote>
<p>Auto-generated from <code>proto/xuma/**/*.proto</code></p>
</blockquote>
<h2 id="browse"><a class="header" href="#browse">Browse</a></h2>
<iframe src="../generated/proto/index.html" width="100%" height="600px" frameborder="0"></iframe>
<h2 id="packages"><a class="header" href="#packages">Packages</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Package</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>xuma.core.v1</code></td><td>Base types, registry</td></tr>
<tr><td><code>xuma.test.v1</code></td><td>Conformance testing inputs</td></tr>
<tr><td><code>xuma.http.v1</code></td><td>HTTP domain (headers, path, method)</td></tr>
<tr><td><code>xuma.claude.v1</code></td><td>Claude Code hooks domain</td></tr>
</tbody>
</table>
</div>
<h2 id="type-urls"><a class="header" href="#type-urls">Type URLs</a></h2>
<pre><code class="language-text">type.googleapis.com/xuma.core.v1.TypedExtensionConfig
type.googleapis.com/xuma.test.v1.StringInput
type.googleapis.com/xuma.http.v1.HeaderInput
type.googleapis.com/xuma.claude.v1.HookContext
</code></pre>
<h2 id="source"><a class="header" href="#source">Source</a></h2>
<ul>
<li><a href="https://github.com/mox-labs/x.uma/tree/main/proto/xuma">proto/xuma/</a></li>
<li><a href="https://github.com/mox-labs/x.uma/blob/main/buf.yaml">buf.yaml</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rust-api-reference"><a class="header" href="#rust-api-reference">Rust API Reference</a></h1>
<blockquote>
<p>Auto-generated from <code>rumi/**/*.rs</code> via <code>cargo doc</code></p>
</blockquote>
<h2 id="browse-1"><a class="header" href="#browse-1">Browse</a></h2>
<iframe src="../generated/rust/rumi/index.html" width="100%" height="600px" frameborder="0"></iframe>
<h2 id="crates"><a class="header" href="#crates">Crates</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Crate</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><a href="generated/rust/rumi/index.html"><code>rumi</code></a></td><td>Core engine</td></tr>
<tr><td><a href="generated/rust/rumi_test/index.html"><code>rumi-test</code></a></td><td>Conformance testing</td></tr>
<tr><td><a href="generated/rust/rumi_http/index.html"><code>rumi-http</code></a></td><td>HTTP matching</td></tr>
<tr><td><a href="generated/rust/rumi_claude/index.html"><code>rumi-claude</code></a></td><td>Claude Code hooks</td></tr>
</tbody>
</table>
</div>
<h2 id="quick-links"><a class="header" href="#quick-links">Quick Links</a></h2>
<ul>
<li><a href="generated/rust/rumi/trait.DataInput.html"><code>DataInput</code></a> â€” Extract data from context</li>
<li><a href="generated/rust/rumi/trait.InputMatcher.html"><code>InputMatcher</code></a> â€” Match against data</li>
<li><a href="generated/rust/rumi/enum.Predicate.html"><code>Predicate</code></a> â€” Boolean composition</li>
<li><a href="generated/rust/rumi/struct.Matcher.html"><code>Matcher</code></a> â€” Top-level container</li>
</ul>
<h2 id="source-1"><a class="header" href="#source-1">Source</a></h2>
<ul>
<li><a href="https://github.com/mox-labs/x.uma/tree/main/rumi">rumi/</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="python-api-reference"><a class="header" href="#python-api-reference">Python API Reference</a></h1>
<p>puma implements the xDS Unified Matcher API in pure Python. Zero dependencies. Python 3.12+.</p>
<p><strong>Package:</strong> <code>puma</code> (from <code>puma/</code> directory)</p>
<p><strong>Installation:</strong></p>
<pre><code class="language-bash">pip install puma
# or with uv
uv add puma
</code></pre>
<h2 id="import-hierarchy"><a class="header" href="#import-hierarchy">Import Hierarchy</a></h2>
<p>All public types exported flat from top level:</p>
<pre><code class="language-python">from puma import (
    # Protocols
    DataInput, InputMatcher, MatchingData,
    # Predicates
    SinglePredicate, And, Or, Not, Predicate, predicate_depth,
    # Matcher
    Matcher, FieldMatcher, OnMatch, Action, NestedMatcher, MatcherError,
    # String matchers
    ExactMatcher, PrefixMatcher, SuffixMatcher, ContainsMatcher, RegexMatcher,
)

from puma.http import (
    # Context
    HttpRequest,
    # DataInputs
    PathInput, MethodInput, HeaderInput, QueryParamInput,
    # Gateway API types
    HttpPathMatch, HttpHeaderMatch, HttpQueryParamMatch, HttpRouteMatch,
    compile_route_matches,
)
</code></pre>
<h2 id="type-hierarchy"><a class="header" href="#type-hierarchy">Type Hierarchy</a></h2>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          Matcher[Ctx, A]            â”‚
â”‚   Top-level tree, returns A|None    â”‚
â””â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚ contains
    â”œâ”€â”€â–º FieldMatcher[Ctx, A]
    â”‚       predicate + on_match
    â”‚
    â””â”€â”€â–º OnMatch[Ctx, A]  (fallback)
         â”œâ”€ Action[A]
         â””â”€ NestedMatcher[Ctx, A]

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Predicate[Ctx]              â”‚
â”‚      Boolean logic tree             â”‚
â””â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”œâ”€ SinglePredicate[Ctx] â†’ input + matcher
    â”œâ”€ And[Ctx] â†’ all match
    â”œâ”€ Or[Ctx] â†’ any match
    â””â”€ Not[Ctx] â†’ invert

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    DataInput[Ctx] protocol          â”‚
â”‚   extract MatchingData from Ctx    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    InputMatcher protocol            â”‚
â”‚   match MatchingData â†’ bool        â”‚
â””â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”œâ”€ ExactMatcher
    â”œâ”€ PrefixMatcher
    â”œâ”€ SuffixMatcher
    â”œâ”€ ContainsMatcher
    â””â”€ RegexMatcher
</code></pre>
<h2 id="core-protocols"><a class="header" href="#core-protocols">Core Protocols</a></h2>
<h3 id="matchingdata"><a class="header" href="#matchingdata">MatchingData</a></h3>
<pre><code class="language-python">type MatchingData = str | int | bool | bytes | None
</code></pre>
<p>Type-erased value returned by <code>DataInput.get()</code>. Replaces Rustâ€™s <code>MatchingData</code> enum.</p>
<p>Returning <code>None</code> triggers the <strong>None â†’ false invariant</strong>: predicate evaluates to <code>False</code> without consulting the matcher.</p>
<h3 id="datainputctx"><a class="header" href="#datainputctx">DataInput[Ctx]</a></h3>
<pre><code class="language-python">class DataInput(Protocol[Ctx]):
    def get(self, ctx: Ctx, /) -&gt; MatchingData: ...
</code></pre>
<p>Domain-specific extraction port. Implementations:</p>
<ul>
<li><code>PathInput</code> extracts HTTP path</li>
<li><code>HeaderInput</code> extracts HTTP header by name</li>
<li>Custom: implement this protocol for your domain</li>
</ul>
<p><strong>Contravariant in Ctx</strong> â€” accepts <code>Ctx</code> or any supertype.</p>
<h3 id="inputmatcher"><a class="header" href="#inputmatcher">InputMatcher</a></h3>
<pre><code class="language-python">class InputMatcher(Protocol):
    def matches(self, value: MatchingData, /) -&gt; bool: ...
</code></pre>
<p>Domain-agnostic matching port. Non-generic by design â€” same <code>ExactMatcher</code> works for HTTP, CloudEvent, or any custom domain.</p>
<h2 id="predicates"><a class="header" href="#predicates">Predicates</a></h2>
<h3 id="singlepredicatectx"><a class="header" href="#singlepredicatectx">SinglePredicate[Ctx]</a></h3>
<pre><code class="language-python">@dataclass(frozen=True, slots=True)
class SinglePredicate[Ctx]:
    input: DataInput[Ctx]
    matcher: InputMatcher

    def evaluate(self, ctx: Any) -&gt; bool: ...
</code></pre>
<p>Combines extraction + matching. Enforces the <strong>None â†’ false invariant</strong>.</p>
<h3 id="andctx"><a class="header" href="#andctx">And[Ctx]</a></h3>
<pre><code class="language-python">@dataclass(frozen=True, slots=True)
class And[Ctx]:
    predicates: tuple[Predicate[Ctx], ...]

    def evaluate(self, ctx: Any) -&gt; bool: ...
</code></pre>
<p>All predicates must match. Short-circuits on first <code>False</code>. Empty tuple returns <code>True</code> (vacuous truth).</p>
<h3 id="orctx"><a class="header" href="#orctx">Or[Ctx]</a></h3>
<pre><code class="language-python">@dataclass(frozen=True, slots=True)
class Or[Ctx]:
    predicates: tuple[Predicate[Ctx], ...]

    def evaluate(self, ctx: Any) -&gt; bool: ...
</code></pre>
<p>Any predicate must match. Short-circuits on first <code>True</code>. Empty tuple returns <code>False</code>.</p>
<h3 id="notctx"><a class="header" href="#notctx">Not[Ctx]</a></h3>
<pre><code class="language-python">@dataclass(frozen=True, slots=True)
class Not[Ctx]:
    predicate: Predicate[Ctx]

    def evaluate(self, ctx: Any) -&gt; bool: ...
</code></pre>
<p>Inverts inner predicate result.</p>
<h3 id="predicatectx"><a class="header" href="#predicatectx">Predicate[Ctx]</a></h3>
<pre><code class="language-python">type Predicate[Ctx] = SinglePredicate[Ctx] | And[Ctx] | Or[Ctx] | Not[Ctx]
</code></pre>
<p>Union type for pattern matching via <code>match</code>/<code>case</code>.</p>
<h3 id="predicate_depth"><a class="header" href="#predicate_depth">predicate_depth()</a></h3>
<pre><code class="language-python">def predicate_depth(p: Predicate[Any]) -&gt; int: ...
</code></pre>
<p>Calculate nesting depth of predicate tree. Used by <code>Matcher.validate()</code> for depth limit enforcement.</p>
<h2 id="matcher-tree"><a class="header" href="#matcher-tree">Matcher Tree</a></h2>
<h3 id="matcherctx-a"><a class="header" href="#matcherctx-a">Matcher[Ctx, A]</a></h3>
<pre><code class="language-python">@dataclass(frozen=True, slots=True)
class Matcher[Ctx, A]:
    matcher_list: tuple[FieldMatcher[Ctx, A], ...]
    on_no_match: OnMatch[Ctx, A] | None = None

    def evaluate(self, ctx: Any) -&gt; A | None: ...
    def validate(self) -&gt; None: ...
    def depth(self) -&gt; int: ...
</code></pre>
<p>Top-level matcher tree. Evaluates <code>matcher_list</code> in order (first-match-wins). Returns action <code>A</code> or <code>None</code>.</p>
<p><strong>Auto-validation:</strong> <code>validate()</code> is called in <code>__post_init__</code>. Trees exceeding <code>MAX_DEPTH</code> (32) raise <code>MatcherError</code>.</p>
<p><strong>Methods:</strong></p>
<ul>
<li><code>evaluate(ctx)</code> â€” Returns first matching action or <code>None</code></li>
<li><code>validate()</code> â€” Checks depth limit (called automatically)</li>
<li><code>depth()</code> â€” Returns total tree depth</li>
</ul>
<h3 id="fieldmatcherctx-a"><a class="header" href="#fieldmatcherctx-a">FieldMatcher[Ctx, A]</a></h3>
<pre><code class="language-python">@dataclass(frozen=True, slots=True)
class FieldMatcher[Ctx, A]:
    predicate: Predicate[Ctx]
    on_match: OnMatch[Ctx, A]
</code></pre>
<p>Pairs a predicate with an outcome (action or nested matcher).</p>
<h3 id="onmatchctx-a"><a class="header" href="#onmatchctx-a">OnMatch[Ctx, A]</a></h3>
<pre><code class="language-python">type OnMatch[Ctx, A] = Action[A] | NestedMatcher[Ctx, A]
</code></pre>
<p>xDS exclusivity â€” action XOR nested matcher, never both.</p>
<h3 id="actiona"><a class="header" href="#actiona">Action[A]</a></h3>
<pre><code class="language-python">@dataclass(frozen=True, slots=True)
class Action[A]:
    value: A
</code></pre>
<p>Terminal outcome. Returns <code>value</code> when matched.</p>
<h3 id="nestedmatcherctx-a"><a class="header" href="#nestedmatcherctx-a">NestedMatcher[Ctx, A]</a></h3>
<pre><code class="language-python">@dataclass(frozen=True, slots=True)
class NestedMatcher[Ctx, A]:
    matcher: Matcher[Ctx, A]
</code></pre>
<p>Continue evaluation into nested matcher. If nested matcher returns <code>None</code>, evaluation continues to next <code>FieldMatcher</code> (xDS nested matcher failure propagation).</p>
<h3 id="matchererror"><a class="header" href="#matchererror">MatcherError</a></h3>
<pre><code class="language-python">class MatcherError(Exception): ...
</code></pre>
<p>Raised when <code>validate()</code> detects depth exceeding <code>MAX_DEPTH</code>.</p>
<h3 id="max_depth"><a class="header" href="#max_depth">MAX_DEPTH</a></h3>
<pre><code class="language-python">MAX_DEPTH: int = 32
</code></pre>
<p>Maximum allowed matcher tree depth. Enforced at construction time.</p>
<h2 id="string-matchers"><a class="header" href="#string-matchers">String Matchers</a></h2>
<p>All matchers are frozen dataclasses implementing <code>InputMatcher</code> protocol. Return <code>False</code> for non-string or <code>None</code> input.</p>
<h3 id="exactmatcher"><a class="header" href="#exactmatcher">ExactMatcher</a></h3>
<pre><code class="language-python">@dataclass(frozen=True, slots=True)
class ExactMatcher:
    value: str
    ignore_case: bool = False

    def matches(self, value: MatchingData, /) -&gt; bool: ...
</code></pre>
<p>Exact string equality. When <code>ignore_case=True</code>, comparison uses <code>.casefold()</code>.</p>
<p><strong>Optimization:</strong> Pattern is pre-lowercased at construction time (<code>_cmp_value</code> field).</p>
<h3 id="prefixmatcher"><a class="header" href="#prefixmatcher">PrefixMatcher</a></h3>
<pre><code class="language-python">@dataclass(frozen=True, slots=True)
class PrefixMatcher:
    prefix: str
    ignore_case: bool = False

    def matches(self, value: MatchingData, /) -&gt; bool: ...
</code></pre>
<p>String starts with prefix. Pre-lowercased at construction when <code>ignore_case=True</code>.</p>
<h3 id="suffixmatcher"><a class="header" href="#suffixmatcher">SuffixMatcher</a></h3>
<pre><code class="language-python">@dataclass(frozen=True, slots=True)
class SuffixMatcher:
    suffix: str
    ignore_case: bool = False

    def matches(self, value: MatchingData, /) -&gt; bool: ...
</code></pre>
<p>String ends with suffix. Pre-lowercased at construction when <code>ignore_case=True</code>.</p>
<h3 id="containsmatcher"><a class="header" href="#containsmatcher">ContainsMatcher</a></h3>
<pre><code class="language-python">@dataclass(frozen=True, slots=True)
class ContainsMatcher:
    substring: str
    ignore_case: bool = False

    def matches(self, value: MatchingData, /) -&gt; bool: ...
</code></pre>
<p>Substring search. Pre-lowercased at construction when <code>ignore_case=True</code> (Knuth optimization: avoid repeated pattern lowercasing).</p>
<h3 id="regexmatcher"><a class="header" href="#regexmatcher">RegexMatcher</a></h3>
<pre><code class="language-python">@dataclass(frozen=True, slots=True)
class RegexMatcher:
    pattern: str

    def matches(self, value: MatchingData, /) -&gt; bool: ...
</code></pre>
<p>Regular expression search (not fullmatch). Pattern compiled at construction time.</p>
<p><strong>Security:</strong> Uses Python <code>re</code> module (backtracking NFA, ReDoS-vulnerable). See <code>SECURITY.md</code> in the puma package for details. For adversarial input, use <code>puma-crusty</code> (Phase 7).</p>
<h2 id="http-domain"><a class="header" href="#http-domain">HTTP Domain</a></h2>
<h3 id="httprequest"><a class="header" href="#httprequest">HttpRequest</a></h3>
<pre><code class="language-python">@dataclass(frozen=True, slots=True)
class HttpRequest:
    method: str = "GET"
    raw_path: str = "/"
    headers: dict[str, str] = field(default_factory=dict)

    @property
    def path(self) -&gt; str: ...
    @property
    def query_params(self) -&gt; dict[str, str]: ...
    def header(self, name: str) -&gt; str | None: ...
    def query_param(self, name: str) -&gt; str | None: ...
</code></pre>
<p>HTTP request context for matching.</p>
<p><strong>Parsing:</strong> Query string automatically parsed from <code>raw_path</code>. Headers stored lowercased for case-insensitive lookup.</p>
<p><strong>Properties:</strong></p>
<ul>
<li><code>path</code> â€” path without query string</li>
<li><code>query_params</code> â€” parsed query parameters</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>header(name)</code> â€” Case-insensitive header lookup</li>
<li><code>query_param(name)</code> â€” Query parameter lookup</li>
</ul>
<h3 id="datainputs"><a class="header" href="#datainputs">DataInputs</a></h3>
<h4 id="pathinput"><a class="header" href="#pathinput">PathInput</a></h4>
<pre><code class="language-python">@dataclass(frozen=True, slots=True)
class PathInput:
    def get(self, ctx: HttpRequest, /) -&gt; MatchingData: ...
</code></pre>
<p>Extracts <code>ctx.path</code> (without query string).</p>
<h4 id="methodinput"><a class="header" href="#methodinput">MethodInput</a></h4>
<pre><code class="language-python">@dataclass(frozen=True, slots=True)
class MethodInput:
    def get(self, ctx: HttpRequest, /) -&gt; MatchingData: ...
</code></pre>
<p>Extracts HTTP method (case-sensitive).</p>
<h4 id="headerinput"><a class="header" href="#headerinput">HeaderInput</a></h4>
<pre><code class="language-python">@dataclass(frozen=True, slots=True)
class HeaderInput:
    name: str

    def get(self, ctx: HttpRequest, /) -&gt; MatchingData: ...
</code></pre>
<p>Extracts header value by name (case-insensitive lookup). Returns <code>None</code> if header not present.</p>
<h4 id="queryparaminput"><a class="header" href="#queryparaminput">QueryParamInput</a></h4>
<pre><code class="language-python">@dataclass(frozen=True, slots=True)
class QueryParamInput:
    name: str

    def get(self, ctx: HttpRequest, /) -&gt; MatchingData: ...
</code></pre>
<p>Extracts query parameter value by name. Returns <code>None</code> if parameter not present.</p>
<h3 id="gateway-api-types"><a class="header" href="#gateway-api-types">Gateway API Types</a></h3>
<p>Pure Python types mirroring Gateway API spec (no Kubernetes dependency).</p>
<h4 id="httppathmatch"><a class="header" href="#httppathmatch">HttpPathMatch</a></h4>
<pre><code class="language-python">@dataclass(frozen=True, slots=True)
class HttpPathMatch:
    type: Literal["Exact", "PathPrefix", "RegularExpression"]
    value: str
</code></pre>
<p>Path match specification.</p>
<h4 id="httpheadermatch"><a class="header" href="#httpheadermatch">HttpHeaderMatch</a></h4>
<pre><code class="language-python">@dataclass(frozen=True, slots=True)
class HttpHeaderMatch:
    type: Literal["Exact", "RegularExpression"]
    name: str
    value: str
</code></pre>
<p>Header match specification.</p>
<h4 id="httpqueryparammatch"><a class="header" href="#httpqueryparammatch">HttpQueryParamMatch</a></h4>
<pre><code class="language-python">@dataclass(frozen=True, slots=True)
class HttpQueryParamMatch:
    type: Literal["Exact", "RegularExpression"]
    name: str
    value: str
</code></pre>
<p>Query parameter match specification.</p>
<h4 id="httproutematch"><a class="header" href="#httproutematch">HttpRouteMatch</a></h4>
<pre><code class="language-python">@dataclass(frozen=True, slots=True)
class HttpRouteMatch:
    path: HttpPathMatch | None = None
    method: str | None = None
    headers: list[HttpHeaderMatch] = field(default_factory=list)
    query_params: list[HttpQueryParamMatch] = field(default_factory=list)

    def compile[A](self, action: A) -&gt; Matcher[HttpRequest, A]: ...
    def to_predicate(self) -&gt; Predicate[HttpRequest]: ...
</code></pre>
<p>Gateway API route match config. All conditions within a single <code>HttpRouteMatch</code> are ANDed.</p>
<p><strong>Methods:</strong></p>
<ul>
<li><code>compile(action)</code> â€” Build a <code>Matcher</code> with this match â†’ action</li>
<li><code>to_predicate()</code> â€” Convert to predicate tree (used by compiler)</li>
</ul>
<h3 id="compile_route_matches"><a class="header" href="#compile_route_matches">compile_route_matches()</a></h3>
<pre><code class="language-python">def compile_route_matches[A](
    matches: list[HttpRouteMatch],
    action: A,
    on_no_match: A | None = None,
) -&gt; Matcher[HttpRequest, A]: ...
</code></pre>
<p>Compile multiple <code>HttpRouteMatch</code> entries into a single <code>Matcher</code>. Multiple matches are ORed per Gateway API semantics.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-python">matcher = compile_route_matches(
    matches=[api_route, admin_route],
    action="matched",
    on_no_match="404",
)
</code></pre>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<ul>
<li><strong>Python 3.12+</strong> â€” uses PEP 695 type parameter syntax (<code>class Foo[T]:</code>)</li>
<li><strong>Zero dependencies</strong> â€” pure Python stdlib only</li>
<li><strong>py.typed</strong> â€” PEP 561 marker included, downstream type checkers (mypy, pyright) recognize puma as typed</li>
</ul>
<h2 id="security"><a class="header" href="#security">Security</a></h2>
<p>See <code>SECURITY.md</code> in the puma package for ReDoS risk and mitigation.</p>
<p><strong>Summary:</strong></p>
<ul>
<li><code>RegexMatcher</code> uses Python <code>re</code> (backtracking, ReDoS-vulnerable)</li>
<li>Safe for trusted patterns (your route config, known fixtures)</li>
<li>For adversarial input, use <code>puma-crusty</code> (Rust-backed, linear-time regex)</li>
<li>Depth validation automatic at construction (max 32 levels)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="typescript-api-reference"><a class="header" href="#typescript-api-reference">TypeScript API Reference</a></h1>
<p>bumi implements the xDS Unified Matcher API in pure TypeScript. Zero runtime dependencies. Bun runtime. TypeScript 5+.</p>
<p><strong>Package:</strong> <code>bumi</code> (from <code>bumi/</code> directory)</p>
<p><strong>Installation:</strong></p>
<pre><code class="language-bash">bun add bumi
</code></pre>
<h2 id="import-hierarchy-1"><a class="header" href="#import-hierarchy-1">Import Hierarchy</a></h2>
<p>All public types exported flat from top level:</p>
<pre><code class="language-typescript">import {
    // Protocols
    DataInput, InputMatcher, MatchingData,
    // Predicates
    SinglePredicate, And, Or, Not, Predicate, evaluatePredicate, predicateDepth,
    // Matcher
    Matcher, FieldMatcher, OnMatch, Action, NestedMatcher, MatcherError, MAX_DEPTH,
    // String matchers
    ExactMatcher, PrefixMatcher, SuffixMatcher, ContainsMatcher, RegexMatcher,
} from "bumi";

import {
    // Context
    HttpRequest,
    // DataInputs
    PathInput, MethodInput, HeaderInput, QueryParamInput,
    // Gateway API types
    HttpPathMatch, HttpHeaderMatch, HttpQueryParamMatch, HttpRouteMatch,
    compileRouteMatch, compileRouteMatches,
} from "bumi/http";
</code></pre>
<h2 id="type-hierarchy-1"><a class="header" href="#type-hierarchy-1">Type Hierarchy</a></h2>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          Matcher&lt;Ctx, A&gt;            â”‚
â”‚   Top-level tree, returns A|null    â”‚
â””â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚ contains
    â”œâ”€â”€â–º FieldMatcher&lt;Ctx, A&gt;
    â”‚       predicate + onMatch
    â”‚
    â””â”€â”€â–º OnMatch&lt;Ctx, A&gt;  (fallback)
         â”œâ”€ Action&lt;A&gt;
         â””â”€ NestedMatcher&lt;Ctx, A&gt;

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Predicate&lt;Ctx&gt;              â”‚
â”‚      Boolean logic tree             â”‚
â””â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”œâ”€ SinglePredicate&lt;Ctx&gt; â†’ input + matcher
    â”œâ”€ And&lt;Ctx&gt; â†’ all match
    â”œâ”€ Or&lt;Ctx&gt; â†’ any match
    â””â”€ Not&lt;Ctx&gt; â†’ invert

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    DataInput&lt;Ctx&gt; interface         â”‚
â”‚   extract MatchingData from Ctx     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    InputMatcher interface           â”‚
â”‚   match MatchingData â†’ bool         â”‚
â””â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”œâ”€ ExactMatcher
    â”œâ”€ PrefixMatcher
    â”œâ”€ SuffixMatcher
    â”œâ”€ ContainsMatcher
    â””â”€ RegexMatcher
</code></pre>
<h2 id="core-interfaces"><a class="header" href="#core-interfaces">Core Interfaces</a></h2>
<h3 id="matchingdata-1"><a class="header" href="#matchingdata-1">MatchingData</a></h3>
<pre><code class="language-typescript">type MatchingData = string | number | boolean | Uint8Array | null;
</code></pre>
<p>Type-erased value returned by <code>DataInput.get()</code>. Replaces Rustâ€™s <code>MatchingData</code> enum.</p>
<p>Returning <code>null</code> triggers the <strong>null â†’ false invariant</strong>: predicate evaluates to <code>false</code> without consulting the matcher.</p>
<h3 id="datainputctx-1"><a class="header" href="#datainputctx-1"><code>DataInput&lt;Ctx&gt;</code></a></h3>
<pre><code class="language-typescript">interface DataInput&lt;Ctx&gt; {
    get(ctx: Ctx): MatchingData;
}
</code></pre>
<p>Domain-specific extraction port. Implementations:</p>
<ul>
<li><code>PathInput</code> extracts HTTP path</li>
<li><code>HeaderInput</code> extracts HTTP header by name</li>
<li>Custom: implement this interface for your domain</li>
</ul>
<p><strong>Generic over Ctx</strong> â€” accepts context of type <code>Ctx</code>.</p>
<h3 id="inputmatcher-1"><a class="header" href="#inputmatcher-1">InputMatcher</a></h3>
<pre><code class="language-typescript">interface InputMatcher {
    matches(value: MatchingData): boolean;
}
</code></pre>
<p>Domain-agnostic matching port. Non-generic by design â€” same <code>ExactMatcher</code> works for HTTP, test contexts, or any custom domain.</p>
<h2 id="predicates-1"><a class="header" href="#predicates-1">Predicates</a></h2>
<h3 id="singlepredicatectx-1"><a class="header" href="#singlepredicatectx-1"><code>SinglePredicate&lt;Ctx&gt;</code></a></h3>
<pre><code class="language-typescript">class SinglePredicate&lt;Ctx&gt; {
    constructor(
        readonly input: DataInput&lt;Ctx&gt;,
        readonly matcher: InputMatcher,
    );

    evaluate(ctx: Ctx): boolean;
}
</code></pre>
<p>Combines extraction + matching. Enforces the <strong>null â†’ false invariant</strong>.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-typescript">const pred = new SinglePredicate(
    new PathInput(),
    new PrefixMatcher("/api")
);
pred.evaluate(request); // true if path starts with /api
</code></pre>
<h3 id="andctx-1"><a class="header" href="#andctx-1"><code>And&lt;Ctx&gt;</code></a></h3>
<pre><code class="language-typescript">class And&lt;Ctx&gt; {
    constructor(readonly predicates: readonly Predicate&lt;Ctx&gt;[]);

    evaluate(ctx: Ctx): boolean;
}
</code></pre>
<p>All predicates must match. Short-circuits on first <code>false</code>. Empty array returns <code>true</code> (vacuous truth).</p>
<h3 id="orctx-1"><a class="header" href="#orctx-1"><code>Or&lt;Ctx&gt;</code></a></h3>
<pre><code class="language-typescript">class Or&lt;Ctx&gt; {
    constructor(readonly predicates: readonly Predicate&lt;Ctx&gt;[]);

    evaluate(ctx: Ctx): boolean;
}
</code></pre>
<p>Any predicate must match. Short-circuits on first <code>true</code>. Empty array returns <code>false</code>.</p>
<h3 id="notctx-1"><a class="header" href="#notctx-1"><code>Not&lt;Ctx&gt;</code></a></h3>
<pre><code class="language-typescript">class Not&lt;Ctx&gt; {
    constructor(readonly predicate: Predicate&lt;Ctx&gt;);

    evaluate(ctx: Ctx): boolean;
}
</code></pre>
<p>Inverts inner predicate result.</p>
<h3 id="predicatectx-1"><a class="header" href="#predicatectx-1"><code>Predicate&lt;Ctx&gt;</code></a></h3>
<pre><code class="language-typescript">type Predicate&lt;Ctx&gt; = SinglePredicate&lt;Ctx&gt; | And&lt;Ctx&gt; | Or&lt;Ctx&gt; | Not&lt;Ctx&gt;;
</code></pre>
<p>Discriminated union of all predicate types. Check variant with <code>instanceof</code>.</p>
<h3 id="evaluatepredicate"><a class="header" href="#evaluatepredicate">evaluatePredicate()</a></h3>
<pre><code class="language-typescript">function evaluatePredicate&lt;Ctx&gt;(p: Predicate&lt;Ctx&gt;, ctx: Ctx): boolean;
</code></pre>
<p>Evaluate any predicate variant. Dispatches to the appropriate <code>.evaluate()</code> method.</p>
<h3 id="predicatedepth"><a class="header" href="#predicatedepth">predicateDepth()</a></h3>
<pre><code class="language-typescript">function predicateDepth&lt;Ctx&gt;(p: Predicate&lt;Ctx&gt;): number;
</code></pre>
<p>Calculate nesting depth of predicate tree. Used by <code>Matcher.validate()</code> for depth limit enforcement.</p>
<h2 id="matcher-tree-1"><a class="header" href="#matcher-tree-1">Matcher Tree</a></h2>
<h3 id="matcherctx-a-1"><a class="header" href="#matcherctx-a-1"><code>Matcher&lt;Ctx, A&gt;</code></a></h3>
<pre><code class="language-typescript">class Matcher&lt;Ctx, A&gt; {
    constructor(
        readonly matchers: readonly FieldMatcher&lt;Ctx, A&gt;[],
        readonly onNoMatch: OnMatch&lt;Ctx, A&gt; | null = null,
    );

    evaluate(ctx: Ctx): A | null;
    validate(): void;
    depth(): number;
}
</code></pre>
<p>Top-level matcher tree. Evaluates <code>matchers</code> in order (first-match-wins). Returns action <code>A</code> or <code>null</code>.</p>
<p><strong>Auto-validation:</strong> <code>validate()</code> is called in constructor. Trees exceeding <code>MAX_DEPTH</code> (32) throw <code>MatcherError</code>.</p>
<p><strong>Methods:</strong></p>
<ul>
<li><code>evaluate(ctx)</code> â€” Returns first matching action or <code>null</code></li>
<li><code>validate()</code> â€” Checks depth limit (called automatically)</li>
<li><code>depth()</code> â€” Returns total tree depth</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-typescript">const matcher = new Matcher([
    new FieldMatcher(
        new SinglePredicate(new PathInput(), new PrefixMatcher("/api")),
        new Action("api")
    ),
], new Action("default"));

const action = matcher.evaluate(request); // "api" or "default"
</code></pre>
<h3 id="fieldmatcherctx-a-1"><a class="header" href="#fieldmatcherctx-a-1"><code>FieldMatcher&lt;Ctx, A&gt;</code></a></h3>
<pre><code class="language-typescript">class FieldMatcher&lt;Ctx, A&gt; {
    constructor(
        readonly predicate: Predicate&lt;Ctx&gt;,
        readonly onMatch: OnMatch&lt;Ctx, A&gt;,
    );
}
</code></pre>
<p>Pairs a predicate with an outcome (action or nested matcher).</p>
<h3 id="onmatchctx-a-1"><a class="header" href="#onmatchctx-a-1"><code>OnMatch&lt;Ctx, A&gt;</code></a></h3>
<pre><code class="language-typescript">type OnMatch&lt;Ctx, A&gt; = Action&lt;A&gt; | NestedMatcher&lt;Ctx, A&gt;;
</code></pre>
<p>xDS exclusivity â€” action XOR nested matcher, never both. Check variant with <code>instanceof</code>.</p>
<h3 id="actiona-1"><a class="header" href="#actiona-1"><code>Action&lt;A&gt;</code></a></h3>
<pre><code class="language-typescript">class Action&lt;A&gt; {
    constructor(readonly value: A);
}
</code></pre>
<p>Terminal outcome. Returns <code>value</code> when matched.</p>
<h3 id="nestedmatcherctx-a-1"><a class="header" href="#nestedmatcherctx-a-1"><code>NestedMatcher&lt;Ctx, A&gt;</code></a></h3>
<pre><code class="language-typescript">class NestedMatcher&lt;Ctx, A&gt; {
    constructor(readonly matcher: Matcher&lt;Ctx, A&gt;);
}
</code></pre>
<p>Continue evaluation into nested matcher. If nested matcher returns <code>null</code>, evaluation continues to next <code>FieldMatcher</code> (xDS nested matcher failure propagation).</p>
<h3 id="matchererror-1"><a class="header" href="#matchererror-1">MatcherError</a></h3>
<pre><code class="language-typescript">class MatcherError extends Error {
    constructor(message: string);
}
</code></pre>
<p>Thrown when <code>validate()</code> detects depth exceeding <code>MAX_DEPTH</code>, or when compiling invalid regex patterns.</p>
<h3 id="max_depth-1"><a class="header" href="#max_depth-1">MAX_DEPTH</a></h3>
<pre><code class="language-typescript">const MAX_DEPTH: number = 32;
</code></pre>
<p>Maximum allowed matcher tree depth. Enforced at construction time.</p>
<h2 id="string-matchers-1"><a class="header" href="#string-matchers-1">String Matchers</a></h2>
<p>All matchers are classes with <code>readonly</code> properties implementing <code>InputMatcher</code> interface. Return <code>false</code> for non-string or <code>null</code> input.</p>
<h3 id="exactmatcher-1"><a class="header" href="#exactmatcher-1">ExactMatcher</a></h3>
<pre><code class="language-typescript">class ExactMatcher {
    constructor(
        readonly value: string,
        readonly ignoreCase: boolean = false,
    );

    matches(value: MatchingData): boolean;
}
</code></pre>
<p>Exact string equality. When <code>ignoreCase=true</code>, comparison uses <code>.toLowerCase()</code>.</p>
<p><strong>Optimization:</strong> Pattern is pre-lowercased at construction time (private <code>cmpValue</code> field).</p>
<h3 id="prefixmatcher-1"><a class="header" href="#prefixmatcher-1">PrefixMatcher</a></h3>
<pre><code class="language-typescript">class PrefixMatcher {
    constructor(
        readonly prefix: string,
        readonly ignoreCase: boolean = false,
    );

    matches(value: MatchingData): boolean;
}
</code></pre>
<p>String starts with prefix. Pre-lowercased at construction when <code>ignoreCase=true</code>.</p>
<h3 id="suffixmatcher-1"><a class="header" href="#suffixmatcher-1">SuffixMatcher</a></h3>
<pre><code class="language-typescript">class SuffixMatcher {
    constructor(
        readonly suffix: string,
        readonly ignoreCase: boolean = false,
    );

    matches(value: MatchingData): boolean;
}
</code></pre>
<p>String ends with suffix. Pre-lowercased at construction when <code>ignoreCase=true</code>.</p>
<h3 id="containsmatcher-1"><a class="header" href="#containsmatcher-1">ContainsMatcher</a></h3>
<pre><code class="language-typescript">class ContainsMatcher {
    constructor(
        readonly substring: string,
        readonly ignoreCase: boolean = false,
    );

    matches(value: MatchingData): boolean;
}
</code></pre>
<p>Substring search. Pre-lowercased at construction when <code>ignoreCase=true</code> (Knuth optimization: avoid repeated pattern lowercasing).</p>
<h3 id="regexmatcher-1"><a class="header" href="#regexmatcher-1">RegexMatcher</a></h3>
<pre><code class="language-typescript">class RegexMatcher {
    constructor(readonly pattern: string);

    matches(value: MatchingData): boolean;
}
</code></pre>
<p>Regular expression search (not fullmatch). Pattern compiled at construction time. Uses <code>RegExp.test()</code>.</p>
<p><strong>Security:</strong> Uses JavaScriptâ€™s <code>RegExp</code> engine (backtracking, ReDoS-vulnerable). See Performance &gt; ReDoS Protection in the docs. For adversarial input, use <code>bumi-crusty</code> (Phase 8).</p>
<h2 id="http-domain-1"><a class="header" href="#http-domain-1">HTTP Domain</a></h2>
<h3 id="httprequest-1"><a class="header" href="#httprequest-1">HttpRequest</a></h3>
<pre><code class="language-typescript">class HttpRequest {
    constructor(
        readonly method: string = "GET",
        readonly rawPath: string = "/",
        readonly headers: Readonly&lt;Record&lt;string, string&gt;&gt; = {},
    );

    readonly path: string;
    readonly queryParams: Readonly&lt;Record&lt;string, string&gt;&gt;;

    header(name: string): string | null;
    queryParam(name: string): string | null;
}
</code></pre>
<p>HTTP request context for matching.</p>
<p><strong>Parsing:</strong> Query string automatically parsed from <code>rawPath</code> at construction. Headers stored lowercased for case-insensitive lookup.</p>
<p><strong>Properties:</strong></p>
<ul>
<li><code>path</code> â€” path without query string</li>
<li><code>queryParams</code> â€” parsed query parameters</li>
</ul>
<p><strong>Methods:</strong></p>
<ul>
<li><code>header(name)</code> â€” Case-insensitive header lookup</li>
<li><code>queryParam(name)</code> â€” Query parameter lookup</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-typescript">const req = new HttpRequest(
    "GET",
    "/api/users?role=admin",
    { "Content-Type": "application/json" }
);

req.path;              // "/api/users"
req.queryParams;       // { role: "admin" }
req.header("content-type"); // "application/json" (case-insensitive)
req.queryParam("role"); // "admin"
</code></pre>
<h3 id="datainputs-1"><a class="header" href="#datainputs-1">DataInputs</a></h3>
<h4 id="pathinput-1"><a class="header" href="#pathinput-1">PathInput</a></h4>
<pre><code class="language-typescript">class PathInput {
    get(ctx: HttpRequest): MatchingData;
}
</code></pre>
<p>Extracts <code>ctx.path</code> (without query string).</p>
<h4 id="methodinput-1"><a class="header" href="#methodinput-1">MethodInput</a></h4>
<pre><code class="language-typescript">class MethodInput {
    get(ctx: HttpRequest): MatchingData;
}
</code></pre>
<p>Extracts HTTP method (case-sensitive).</p>
<h4 id="headerinput-1"><a class="header" href="#headerinput-1">HeaderInput</a></h4>
<pre><code class="language-typescript">class HeaderInput {
    constructor(readonly name: string);

    get(ctx: HttpRequest): MatchingData;
}
</code></pre>
<p>Extracts header value by name (case-insensitive lookup). Returns <code>null</code> if header not present.</p>
<h4 id="queryparaminput-1"><a class="header" href="#queryparaminput-1">QueryParamInput</a></h4>
<pre><code class="language-typescript">class QueryParamInput {
    constructor(readonly name: string);

    get(ctx: HttpRequest): MatchingData;
}
</code></pre>
<p>Extracts query parameter value by name. Returns <code>null</code> if parameter not present.</p>
<h3 id="gateway-api-types-1"><a class="header" href="#gateway-api-types-1">Gateway API Types</a></h3>
<p>Pure TypeScript types mirroring Gateway API spec (no Kubernetes dependency).</p>
<h4 id="httppathmatch-1"><a class="header" href="#httppathmatch-1">HttpPathMatch</a></h4>
<pre><code class="language-typescript">interface HttpPathMatch {
    readonly type: "Exact" | "PathPrefix" | "RegularExpression";
    readonly value: string;
}
</code></pre>
<p>Path match specification.</p>
<h4 id="httpheadermatch-1"><a class="header" href="#httpheadermatch-1">HttpHeaderMatch</a></h4>
<pre><code class="language-typescript">interface HttpHeaderMatch {
    readonly type: "Exact" | "RegularExpression";
    readonly name: string;
    readonly value: string;
}
</code></pre>
<p>Header match specification.</p>
<h4 id="httpqueryparammatch-1"><a class="header" href="#httpqueryparammatch-1">HttpQueryParamMatch</a></h4>
<pre><code class="language-typescript">interface HttpQueryParamMatch {
    readonly type: "Exact" | "RegularExpression";
    readonly name: string;
    readonly value: string;
}
</code></pre>
<p>Query parameter match specification.</p>
<h4 id="httproutematch-1"><a class="header" href="#httproutematch-1">HttpRouteMatch</a></h4>
<pre><code class="language-typescript">interface HttpRouteMatch {
    readonly path?: HttpPathMatch;
    readonly method?: string;
    readonly headers?: readonly HttpHeaderMatch[];
    readonly queryParams?: readonly HttpQueryParamMatch[];
}
</code></pre>
<p>Gateway API route match config. All conditions within a single <code>HttpRouteMatch</code> are ANDed.</p>
<h3 id="compileroutematch"><a class="header" href="#compileroutematch">compileRouteMatch()</a></h3>
<pre><code class="language-typescript">function compileRouteMatch&lt;A&gt;(
    routeMatch: HttpRouteMatch,
    action: A,
): Matcher&lt;HttpRequest, A&gt;;
</code></pre>
<p>Compile a single <code>HttpRouteMatch</code> into a <code>Matcher</code>.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-typescript">const matcher = compileRouteMatch(
    { path: { type: "PathPrefix", value: "/api" } },
    "api_handler"
);
</code></pre>
<h3 id="compileroutematches"><a class="header" href="#compileroutematches">compileRouteMatches()</a></h3>
<pre><code class="language-typescript">function compileRouteMatches&lt;A&gt;(
    matches: readonly HttpRouteMatch[],
    action: A,
    onNoMatch?: A,
): Matcher&lt;HttpRequest, A&gt;;
</code></pre>
<p>Compile multiple <code>HttpRouteMatch</code> entries into a single <code>Matcher</code>. Multiple matches are ORed per Gateway API semantics. Empty <code>matches</code> array creates a catch-all matcher.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-typescript">const apiRoute: HttpRouteMatch = {
    path: { type: "PathPrefix", value: "/api" },
    method: "GET"
};

const adminRoute: HttpRouteMatch = {
    headers: [{ type: "Exact", name: "x-admin", value: "true" }]
};

const matcher = compileRouteMatches(
    [apiRoute, adminRoute],
    "matched",
    "not_found"
);

matcher.evaluate(request); // "matched" or "not_found"
</code></pre>
<h2 id="requirements-1"><a class="header" href="#requirements-1">Requirements</a></h2>
<ul>
<li><strong>Bun runtime</strong> â€” uses Bunâ€™s fast module resolution and test runner</li>
<li><strong>TypeScript 5+</strong> â€” uses modern TS features (generic classes, discriminated unions)</li>
<li><strong>Zero runtime dependencies</strong> â€” stdlib only (no lodash, no ramda)</li>
<li>Development dependencies: Biome (lint/format), js-yaml (conformance tests)</li>
</ul>
<h2 id="security-1"><a class="header" href="#security-1">Security</a></h2>
<p>See Performance &gt; ReDoS Protection in the docs for regex security details.</p>
<p><strong>Summary:</strong></p>
<ul>
<li><code>RegexMatcher</code> uses JavaScriptâ€™s <code>RegExp</code> (backtracking, ReDoS-vulnerable)</li>
<li>Safe for trusted patterns (your route config, known fixtures)</li>
<li>For adversarial input, use <code>bumi-crusty</code> (Rust-backed via WASM, linear-time regex)</li>
<li>Depth validation automatic at construction (max 32 levels)</li>
<li>Query string parsing uses simple split (no complex URL parsing vulnerabilities)</li>
<li>Headers stored with <code>Object.create(null)</code> to prevent prototype pollution</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="http-domain-reference"><a class="header" href="#http-domain-reference">HTTP Domain Reference</a></h1>
<p>HTTP request matching across all three x.uma implementations.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>All three implementations provide identical HTTP matching capabilities: Gateway API-style config types, a compiler that turns config into matchers, and DataInputs for HTTP contexts.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Implementation</th><th>Package</th><th>Context Type</th><th>Compiler</th></tr>
</thead>
<tbody>
<tr><td><strong>rumi</strong> (Rust)</td><td><code>rumi-http</code></td><td><code>HttpMessage</code></td><td><code>compile_route_matches()</code></td></tr>
<tr><td><strong>puma</strong> (Python)</td><td><code>puma.http</code></td><td><code>HttpRequest</code></td><td><code>compile_route_matches()</code></td></tr>
<tr><td><strong>bumi</strong> (TypeScript)</td><td><code>bumi/http</code></td><td><code>HttpRequest</code></td><td><code>compileRouteMatches()</code></td></tr>
</tbody>
</table>
</div>
<h2 id="architecture-2"><a class="header" href="#architecture-2">Architecture</a></h2>
<p>Every implementation follows the same two-layer pattern:</p>
<pre><code>Config layer:    HttpRouteMatch (human-friendly)
                        |
                   compile()
                        |
Engine layer:    Matcher&lt;HttpContext, A&gt;
                        |
                   evaluate()
                        |
Result:          A | null
</code></pre>
<p><strong>Rust has an extra layer</strong> for data plane use: the config layer produces <code>Matcher&lt;HttpMessage, A&gt;</code>, where <code>HttpMessage</code> is an indexed view over Envoyâ€™s <code>ext_proc ProcessingRequest</code>. Python and TypeScript use a simpler <code>HttpRequest</code> context.</p>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h2>
<p>All three languages use the same Gateway API config types:</p>
<p><strong>Rust:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rumi_http::prelude::*;

let route = HttpRouteMatch {
    path: Some(HttpPathMatch::PathPrefix { value: "/api".into() }),
    method: Some("GET".into()),
    ..Default::default()
};
let matcher = route.compile("api_backend");
<span class="boring">}</span></code></pre>
<p><strong>Python:</strong></p>
<pre><code class="language-python">from puma.http import HttpRouteMatch, compile_route_match

route = HttpRouteMatch(
    path=HttpPathMatch(type="PathPrefix", value="/api"),
    method="GET",
)
matcher = compile_route_match(route, "api_backend")
</code></pre>
<p><strong>TypeScript:</strong></p>
<pre><code class="language-typescript">import { compileRouteMatch } from "bumi/http";

const matcher = compileRouteMatch(
    { path: { type: "PathPrefix", value: "/api" }, method: "GET" },
    "api_backend",
);
</code></pre>
<h2 id="datainputs-2"><a class="header" href="#datainputs-2">DataInputs</a></h2>
<p>Each implementation provides the same set of field extractors:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Input</th><th>Extracts</th><th>Returns <code>null</code> when</th></tr>
</thead>
<tbody>
<tr><td><code>PathInput</code></td><td>URL path (without query string)</td><td>Path missing</td></tr>
<tr><td><code>MethodInput</code></td><td>HTTP method</td><td>Method missing</td></tr>
<tr><td><code>HeaderInput(name)</code></td><td>Header value by name (case-insensitive)</td><td>Header not present</td></tr>
<tr><td><code>QueryParamInput(name)</code></td><td>Query parameter value by name</td><td>Parameter not present</td></tr>
</tbody>
</table>
</div>
<p><strong>Rust-only</strong> (for Envoy <code>ext_proc</code>):</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Input</th><th>Extracts</th></tr>
</thead>
<tbody>
<tr><td><code>SchemeInput</code></td><td><code>:scheme</code> pseudo-header</td></tr>
<tr><td><code>AuthorityInput</code></td><td><code>:authority</code> pseudo-header</td></tr>
</tbody>
</table>
</div>
<h2 id="gateway-api-config-types"><a class="header" href="#gateway-api-config-types">Gateway API Config Types</a></h2>
<p>These types mirror the <a href="https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteMatch">Gateway API HTTPRouteMatch spec</a>. All conditions within a single <code>HttpRouteMatch</code> are ANDed. Multiple <code>HttpRouteMatch</code> entries are ORed.</p>
<h3 id="httppathmatch-2"><a class="header" href="#httppathmatch-2"><code>HttpPathMatch</code></a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Match Logic</th></tr>
</thead>
<tbody>
<tr><td><code>Exact</code></td><td>Path equals value exactly</td></tr>
<tr><td><code>PathPrefix</code></td><td>Path starts with value</td></tr>
<tr><td><code>RegularExpression</code></td><td>Path matches regex pattern</td></tr>
</tbody>
</table>
</div>
<h3 id="httpheadermatch-2"><a class="header" href="#httpheadermatch-2"><code>HttpHeaderMatch</code></a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Match Logic</th></tr>
</thead>
<tbody>
<tr><td><code>Exact</code></td><td>Header value equals string exactly</td></tr>
<tr><td><code>RegularExpression</code></td><td>Header value matches regex pattern</td></tr>
</tbody>
</table>
</div>
<p>Header name lookup is always case-insensitive.</p>
<h3 id="httpqueryparammatch-2"><a class="header" href="#httpqueryparammatch-2"><code>HttpQueryParamMatch</code></a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Match Logic</th></tr>
</thead>
<tbody>
<tr><td><code>Exact</code></td><td>Query param value equals string exactly</td></tr>
<tr><td><code>RegularExpression</code></td><td>Query param value matches regex pattern</td></tr>
</tbody>
</table>
</div>
<h3 id="httproutematch-2"><a class="header" href="#httproutematch-2"><code>HttpRouteMatch</code></a></h3>
<p>Combines path, method, headers, and query parameters. All specified conditions must match (AND semantics).</p>
<p><strong>Rust:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>HttpRouteMatch {
    path: Some(HttpPathMatch::PathPrefix { value: "/api".into() }),
    method: Some("GET".into()),
    headers: Some(vec![
        HttpHeaderMatch::Exact {
            name: "x-version".into(),
            value: "2".into(),
        },
    ]),
    query_params: None,
}
<span class="boring">}</span></code></pre>
<p><strong>Python:</strong></p>
<pre><code class="language-python">HttpRouteMatch(
    path=HttpPathMatch(type="PathPrefix", value="/api"),
    method="GET",
    headers=[HttpHeaderMatch(type="Exact", name="x-version", value="2")],
)
</code></pre>
<p><strong>TypeScript:</strong></p>
<pre><code class="language-typescript">{
    path: { type: "PathPrefix", value: "/api" },
    method: "GET",
    headers: [{ type: "Exact", name: "x-version", value: "2" }],
}
</code></pre>
<h2 id="compiler-functions"><a class="header" href="#compiler-functions">Compiler Functions</a></h2>
<h3 id="single-route"><a class="header" href="#single-route">Single Route</a></h3>
<p>Compile one <code>HttpRouteMatch</code> into a <code>Matcher</code>:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Language</th><th>Function</th><th>Signature</th></tr>
</thead>
<tbody>
<tr><td>Rust</td><td><code>route_match.compile(action)</code></td><td><code>HttpRouteMatch â†’ Matcher&lt;HttpMessage, A&gt;</code></td></tr>
<tr><td>Python</td><td><code>compile_route_match(route, action)</code></td><td><code>HttpRouteMatch â†’ Matcher[HttpRequest, A]</code></td></tr>
<tr><td>TypeScript</td><td><code>compileRouteMatch(route, action)</code></td><td><code>HttpRouteMatch â†’ Matcher&lt;HttpRequest, A&gt;</code></td></tr>
</tbody>
</table>
</div>
<h3 id="multiple-routes"><a class="header" href="#multiple-routes">Multiple Routes</a></h3>
<p>Compile multiple <code>HttpRouteMatch</code> entries into a single <code>Matcher</code> with OR semantics:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Language</th><th>Function</th></tr>
</thead>
<tbody>
<tr><td>Rust</td><td><code>compile_route_matches(&amp;matches, action, fallback)</code></td></tr>
<tr><td>Python</td><td><code>compile_route_matches(matches, action, on_no_match)</code></td></tr>
<tr><td>TypeScript</td><td><code>compileRouteMatches(matches, action, onNoMatch)</code></td></tr>
</tbody>
</table>
</div>
<p><strong>Empty matches array</strong> creates a catch-all matcher (matches everything).</p>
<p><strong>Example (TypeScript):</strong></p>
<pre><code class="language-typescript">import { compileRouteMatches, type HttpRouteMatch } from "bumi/http";

const apiRoute: HttpRouteMatch = {
    path: { type: "PathPrefix", value: "/api" },
    method: "GET",
};

const adminRoute: HttpRouteMatch = {
    headers: [{ type: "Exact", name: "x-admin", value: "true" }],
};

const matcher = compileRouteMatches(
    [apiRoute, adminRoute],
    "allowed",
    "denied",
);
</code></pre>
<h2 id="context-types"><a class="header" href="#context-types">Context Types</a></h2>
<h3 id="httprequest-python-typescript"><a class="header" href="#httprequest-python-typescript"><code>HttpRequest</code> (Python, TypeScript)</a></h3>
<p>Simplified HTTP request for application-level matching.</p>
<pre><code class="language-python"># Python
from puma.http import HttpRequest

req = HttpRequest(
    method="GET",
    raw_path="/api/users?role=admin",
    headers={"content-type": "application/json"},
)

req.path              # "/api/users" (parsed from raw_path)
req.query_params      # {"role": "admin"} (parsed from raw_path)
req.header("Content-Type")  # "application/json" (case-insensitive)
</code></pre>
<pre><code class="language-typescript">// TypeScript
import { HttpRequest } from "bumi/http";

const req = new HttpRequest(
    "GET",
    "/api/users?role=admin",
    { "Content-Type": "application/json" },
);

req.path;                    // "/api/users"
req.queryParam("role");      // "admin"
req.header("content-type");  // "application/json" (case-insensitive)
</code></pre>
<h3 id="httpmessage-rust-only"><a class="header" href="#httpmessage-rust-only"><code>HttpMessage</code> (Rust only)</a></h3>
<p>Indexed view over Envoy <code>ProcessingRequest</code> for data plane matching. Provides O(1) header and query parameter lookups via <code>HashMap</code>.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rumi_http::{HttpMessage, SimpleHttpRequest};

// For testing: SimpleHttpRequest builder
let req = SimpleHttpRequest::builder()
    .method("GET")
    .path("/api/users")
    .header("content-type", "application/json")
    .build();

let message = HttpMessage::from(&amp;req);
<span class="boring">}</span></code></pre>
<h2 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Implementation</th><th>Runtime Dependencies</th></tr>
</thead>
<tbody>
<tr><td>rumi-http</td><td><code>k8s-gateway-api</code>, <code>envoy-grpc-ext-proc</code></td></tr>
<tr><td>puma.http</td><td>None (zero dependencies)</td></tr>
<tr><td>bumi/http</td><td>None (zero runtime dependencies)</td></tr>
</tbody>
</table>
</div>
<h2 id="see-also-2"><a class="header" href="#see-also-2">See Also</a></h2>
<ul>
<li><a href="#rust-api-reference">Rust API Reference</a> â€” rumi core types</li>
<li><a href="#python-api-reference">Python API Reference</a> â€” puma core + HTTP types</li>
<li><a href="#typescript-api-reference">TypeScript API Reference</a> â€” bumi core + HTTP types</li>
<li><a href="#build-an-http-router">Build an HTTP Router</a> â€” Step-by-step tutorial</li>
<li><a href="https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteMatch">Gateway API HTTPRoute Spec</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="roadmap"><a class="header" href="#roadmap">Roadmap</a></h1>
<p>Development phases and current status.</p>
<h2 id="current-status"><a class="header" href="#current-status">Current Status</a></h2>
<p><strong>x.uma is alpha software.</strong> The API is under active development and will change.</p>
<p>Five implementations exist:</p>
<ul>
<li><strong>rumi</strong> (Rust) â€” reference implementation, 195 tests</li>
<li><strong>puma</strong> (Python) â€” pure Python, zero dependencies, 194 tests</li>
<li><strong>bumi</strong> (TypeScript) â€” pure TypeScript, zero runtime deps, 202 tests</li>
<li><strong>puma-crusty</strong> (Python + Rust) â€” PyO3 bindings, 37 tests</li>
<li><strong>bumi-crusty</strong> (TypeScript + WASM) â€” wasm-bindgen bindings, 36 tests</li>
</ul>
<p>All pass the same conformance test suite (<code>spec/tests/</code>). Total: 268 tests across 5 variants.</p>
<h2 id="phase-overview"><a class="header" href="#phase-overview">Phase Overview</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Phase</th><th>Focus</th><th>Status</th></tr>
</thead>
<tbody>
<tr><td>0</td><td>Scaffolding</td><td>âœ… Done</td></tr>
<tr><td>1</td><td>Core Traits</td><td>âœ… Done</td></tr>
<tr><td>2</td><td>Conformance Fixtures</td><td>âœ… Done</td></tr>
<tr><td>2.5</td><td>Extensible MatchingData (<code>Custom</code> variant)</td><td>âœ… Done</td></tr>
<tr><td>3</td><td>StringMatcher, MatcherTree, RadixTree</td><td>âœ… Done</td></tr>
<tr><td>4</td><td>HTTP Domain (ext_proc model)</td><td>âœ… Done</td></tr>
<tr><td>5</td><td>puma (Pure Python + HTTP)</td><td>âœ… Done</td></tr>
<tr><td>5.1</td><td>puma arch-guild hardening</td><td>âœ… Done</td></tr>
<tr><td>6</td><td>bumi (Bun/TypeScript + HTTP)</td><td>âœ… Done</td></tr>
<tr><td>6.1</td><td>bumi arch-guild hardening</td><td>âœ… Done</td></tr>
<tr><td>7</td><td>puma-crusty: PyO3 Python bindings</td><td>âœ… Done</td></tr>
<tr><td>7.5</td><td>rumi-claude: trace + HookMatch compiler</td><td>âœ… Done</td></tr>
<tr><td>8</td><td>bumi-crusty: wasm-bindgen TypeScript bindings</td><td>âœ… Done</td></tr>
<tr><td>9</td><td>Cross-language benchmarks (all 5 variants)</td><td>ğŸš§ In Progress</td></tr>
<tr><td>10</td><td>Semantic matching (cosine similarity)</td><td>Planned</td></tr>
<tr><td>11</td><td>RE2 migration: <code>google-re2</code> for puma, <code>re2js</code> for bumi</td><td>Planned</td></tr>
</tbody>
</table>
</div>
<h2 id="phase-11-re2-linear-time-regex-migration"><a class="header" href="#phase-11-re2-linear-time-regex-migration">Phase 11: RE2 Linear-Time Regex Migration</a></h2>
<p><strong>Status:</strong> Planned</p>
<p>Replace backtracking regex engines in puma and bumi with linear-time RE2 implementations.</p>
<p><strong>Motivation:</strong> Phase 9 benchmarks proved ReDoS is catastrophic â€” Python <code>re</code> at N=20 takes 72ms, JS <code>RegExp</code> takes 11ms, while Rust <code>regex</code> (RE2 semantics) takes 11ns. The crusty bindings solve this but add FFI overhead. RE2 packages give linear-time regex natively without crossing a language boundary.</p>
<p><strong>puma:</strong> <a href="https://pypi.org/project/google-re2/"><code>google-re2</code></a> â€” official Google C++ wrapper</p>
<ul>
<li>Drop-in for <code>RegexMatcher</code> internals (swap <code>re.search</code> â†’ <code>re2.search</code>)</li>
<li>Requires C++ toolchain to build (wheel available for common platforms)</li>
<li>Trade-off: adds a native dependency to previously zero-dep puma</li>
</ul>
<p><strong>bumi:</strong> <a href="https://github.com/le0pard/re2js"><code>re2js</code></a> â€” pure JavaScript port of RE2</p>
<ul>
<li>Zero native deps, zero WASM â€” pure JS with linear-time guarantee</li>
<li>Drop-in for <code>RegexMatcher</code> internals (swap <code>RegExp.test</code> â†’ <code>re2js</code> equivalent)</li>
<li>Best of both worlds: bumiâ€™s 9ns JIT speed + linear-time safety</li>
</ul>
<p><strong>Limitations (both):</strong> No backreferences, no lookahead assertions. Same as Rust <code>regex</code> crate. The vast majority of matcher patterns donâ€™t need these.</p>
<p><strong>Crusty still matters:</strong> RE2 only fixes the regex leaf node. Crusty replaces the entire evaluation pipeline (tree walk, predicate composition, field matching) in Rust. For complex configs with 100+ rules, crustyâ€™s compiled pipeline wins. RE2 + crusty is the best of all worlds.</p>
<h2 id="phase-5-puma-pure-python"><a class="header" href="#phase-5-puma-pure-python">Phase 5: puma (Pure Python)</a></h2>
<p><strong>Status:</strong> Complete (v0.1.0)</p>
<p>Pure Python implementation of the xDS Unified Matcher API. Zero dependencies. Python 3.12+.</p>
<p><strong>Architecture:</strong></p>
<ul>
<li>PEP 695 type params (<code>class Foo[T]:</code>) â€” modern Python generics</li>
<li><code>@dataclass(frozen=True, slots=True)</code> â€” immutability + performance</li>
<li>Protocol-based ports (runtime-checkable)</li>
<li>Union type aliases (<code>type Predicate = Single | And | Or | Not</code>)</li>
</ul>
<p><strong>Type System Mapping:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Rust (rumi)</th><th>Python (puma)</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td><code>trait DataInput&lt;Ctx&gt;</code></td><td><code>Protocol[Ctx]</code></td><td>Contravariant in <code>Ctx</code></td></tr>
<tr><td><code>trait InputMatcher</code></td><td><code>Protocol</code></td><td>Non-generic, runtime-checkable</td></tr>
<tr><td><code>enum MatchingData</code></td><td><code>MatchingData = str | int | bool | bytes | None</code></td><td>Type alias replaces enum</td></tr>
<tr><td><code>enum Predicate&lt;Ctx&gt;</code></td><td><code>type Predicate[Ctx] = Single | And | Or | Not</code></td><td>Pattern-matchable</td></tr>
<tr><td><code>enum OnMatch&lt;Ctx, A&gt;</code></td><td><code>type OnMatch[Ctx, A] = Action | NestedMatcher</code></td><td>xDS exclusivity</td></tr>
</tbody>
</table>
</div>
<p><strong>Deliverables:</strong></p>
<ul>
<li><input disabled="" type="checkbox" checked=""> Core types (<code>Matcher</code>, <code>Predicate</code>, <code>FieldMatcher</code>, <code>OnMatch</code>)</li>
<li><input disabled="" type="checkbox" checked=""> String matchers (<code>Exact</code>, <code>Prefix</code>, <code>Suffix</code>, <code>Contains</code>, <code>Regex</code>)</li>
<li><input disabled="" type="checkbox" checked=""> HTTP domain (<code>HttpRequest</code>, <code>PathInput</code>, <code>MethodInput</code>, <code>HeaderInput</code>, <code>QueryParamInput</code>)</li>
<li><input disabled="" type="checkbox" checked=""> Gateway API compiler (<code>HttpRouteMatch</code> â†’ <code>Matcher</code>)</li>
<li><input disabled="" type="checkbox" checked=""> 194 conformance tests passing (0.10s)</li>
<li><input disabled="" type="checkbox" checked=""> <code>py.typed</code> marker for type checker support</li>
<li><input disabled="" type="checkbox" checked=""> Auto-validation (depth limit enforced at construction)</li>
<li><input disabled="" type="checkbox" checked=""> Typed Gateway API (Literal types, proper return annotations)</li>
<li><input disabled="" type="checkbox" checked=""> Security documentation (ReDoS contract)</li>
</ul>
<p><strong>Known Limitations:</strong></p>
<ul>
<li><code>RegexMatcher</code> uses Python <code>re</code> (backtracking, ReDoS-vulnerable)</li>
<li>For adversarial input, use <code>puma-crusty</code> (Phase 7) with Rust-backed linear-time regex</li>
<li>No proto codegen (pure Python types only)</li>
</ul>
<h2 id="phase-51-arch-guild-hardening"><a class="header" href="#phase-51-arch-guild-hardening">Phase 5.1: Arch-Guild Hardening</a></h2>
<p><strong>Status:</strong> Complete</p>
<p>13-agent architecture review identified 4 gaps, all resolved:</p>
<ol>
<li><strong>py.typed marker</strong> â€” Type checkers now recognize puma as typed</li>
<li><strong>Auto-validation</strong> â€” <code>Matcher.__post_init__</code> calls <code>validate()</code>, depth limits enforced</li>
<li><strong>Typed Gateway API</strong> â€” Literal types for match types, proper return annotations</li>
<li><strong>ReDoS documentation</strong> â€” SECURITY.md explains Python <code>re</code> vs Rust <code>regex</code> trade-off</li>
</ol>
<p><strong>Verdict:</strong> Architecture excellent (zero boundary violations, hexagonal textbook). Safety gap closed via strategic documentation + puma-crusty path for adversarial use cases.</p>
<h2 id="phase-6-bumi-buntypescript"><a class="header" href="#phase-6-bumi-buntypescript">Phase 6: bumi (Bun/TypeScript)</a></h2>
<p><strong>Status:</strong> Complete (v0.1.0)</p>
<p>Pure TypeScript implementation using Bun runtime. Zero runtime dependencies. 202 tests passing.</p>
<p><strong>Architecture:</strong></p>
<ul>
<li>Classes with <code>readonly</code> props for immutability</li>
<li><code>instanceof</code> checks for union discrimination</li>
<li>Biome for lint/format, <code>bun test</code> for testing</li>
<li><code>Object.create(null)</code> for params/headers (prototype pollution protection)</li>
</ul>
<p><strong>Type System Mapping (Rust â†’ TypeScript):</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Rust (rumi)</th><th>TypeScript (bumi)</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td><code>trait DataInput&lt;Ctx&gt;</code></td><td><code>interface DataInput&lt;Ctx&gt;</code></td><td>Generic interface</td></tr>
<tr><td><code>trait InputMatcher</code></td><td><code>interface InputMatcher</code></td><td>Non-generic</td></tr>
<tr><td><code>enum MatchingData</code></td><td><code>type MatchingData = string | number | boolean | Uint8Array | null</code></td><td>Union type</td></tr>
<tr><td><code>enum Predicate&lt;Ctx&gt;</code></td><td><code>type Predicate&lt;Ctx&gt; = Single&lt;Ctx&gt; | And&lt;Ctx&gt; | Or&lt;Ctx&gt; | Not&lt;Ctx&gt;</code></td><td>Discriminated union</td></tr>
<tr><td><code>enum OnMatch&lt;Ctx, A&gt;</code></td><td><code>type OnMatch&lt;Ctx, A&gt; = Action&lt;A&gt; | NestedMatcher&lt;Ctx, A&gt;</code></td><td>Discriminated union</td></tr>
</tbody>
</table>
</div>
<h2 id="phase-7-puma-crusty-pyo3-python-bindings"><a class="header" href="#phase-7-puma-crusty-pyo3-python-bindings">Phase 7: puma-crusty (PyO3 Python Bindings)</a></h2>
<p><strong>Status:</strong> Complete</p>
<p>Rust-backed Python package via PyO3, providing opaque compiled <code>HookMatcher</code> for Claude Code hooks.</p>
<p><strong>Architecture:</strong></p>
<ul>
<li>PyO3 0.25+ for Python 3.14 support</li>
<li><code>#[pyclass(frozen)]</code> for immutable compiled matchers</li>
<li>Opaque engine pattern: config in â†’ compile in Rust â†’ evaluate in Rust â†’ simple types out</li>
<li><code>maturin develop</code> for local builds, <code>maturin build</code> for wheels</li>
<li>Linear-time regex (Rust <code>regex</code> crate â€” ReDoS immune)</li>
</ul>
<p><strong>Key APIs:</strong></p>
<ul>
<li><code>HookMatcher.compile(rules, action, fallback)</code> â†’ compiled matcher</li>
<li><code>matcher.evaluate(**context)</code> â†’ action string or None</li>
<li><code>matcher.trace(**context)</code> â†’ detailed trace for debugging</li>
</ul>
<h2 id="phase-8-bumi-crusty-wasm-bindgen-typescript-bindings"><a class="header" href="#phase-8-bumi-crusty-wasm-bindgen-typescript-bindings">Phase 8: bumi-crusty (wasm-bindgen TypeScript Bindings)</a></h2>
<p><strong>Status:</strong> Complete</p>
<p>Rust-backed TypeScript package via wasm-bindgen + wasm-pack.</p>
<p><strong>Architecture:</strong></p>
<ul>
<li>Config types use plain JS objects (discriminated unions), not opaque Rust structs</li>
<li><code>StringMatch</code> is a zero-size namespace struct with static factory methods</li>
<li><code>serde-wasm-bindgen</code> for trace output serialization (Rust â†’ JS with camelCase)</li>
<li>Same security hardening as puma-crusty (fail-closed, input limits, validate after compile)</li>
</ul>
<h2 id="phase-9-cross-language-benchmarks"><a class="header" href="#phase-9-cross-language-benchmarks">Phase 9: Cross-Language Benchmarks</a></h2>
<p><strong>Status:</strong> In Progress</p>
<p>Performance comparison across all 5 x.uma variants using language-native tools.</p>
<p><strong>Tooling:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Language</th><th>Tool</th></tr>
</thead>
<tbody>
<tr><td>Rust</td><td>divan (<code>#[divan::bench]</code> attribute API)</td></tr>
<tr><td>Python</td><td>pytest-benchmark</td></tr>
<tr><td>TypeScript</td><td>mitata</td></tr>
</tbody>
</table>
</div>
<p><strong>Benchmark Categories:</strong></p>
<ul>
<li><strong>Compile latency</strong> â€” config â†’ matcher construction</li>
<li><strong>Evaluate throughput</strong> â€” matcher + context â†’ action (hot path)</li>
<li><strong>FFI overhead</strong> â€” pure vs crusty head-to-head comparison</li>
<li><strong>ReDoS demonstration</strong> â€” <code>(a+)+$</code> pattern, linear (Rust) vs exponential (Python/TS)</li>
<li><strong>Scaling</strong> â€” 1 to 200 rules, miss-heavy workloads, trace overhead</li>
</ul>
<h2 id="historical-phase-4-http-domain"><a class="header" href="#historical-phase-4-http-domain">Historical: Phase 4 (HTTP Domain)</a></h2>
<p>Phase 4 delivered the HTTP domain for rumi (Rust). Two-layer architecture:</p>
<p><strong>User API:</strong> Gateway API <code>HttpRouteMatch</code> (config-time, YAML/JSON)
<strong>Data Plane API:</strong> Envoy <code>ext_proc ProcessingRequest</code> (runtime)</p>
<pre><code class="language-text">Gateway API HttpRouteMatch (config)
        â†“ compile()
rumi Matcher&lt;ProcessingRequest, A&gt;
        â†“ evaluate()
ext_proc ProcessingRequest (runtime)
</code></pre>
<p><strong>Why Two Layers?</strong></p>
<ul>
<li>Gateway API is the CNCF standard (Istio, Envoy Gateway, Contour, Kong)</li>
<li>ext_proc is Envoyâ€™s universal HTTP processing model (REST, gRPC, GraphQL)</li>
<li>x.uma provides the match vocabulary, actions are domain-specific</li>
</ul>
<p><strong>Deliverables:</strong></p>
<ul>
<li>rumi-http crate with <code>HttpMessage</code> indexed context</li>
<li>DataInputs: <code>PathInput</code>, <code>MethodInput</code>, <code>HeaderInput</code>, <code>QueryParamInput</code>, <code>SchemeInput</code>, <code>AuthorityInput</code></li>
<li>Gateway API types via <code>k8s-gateway-api</code> crate</li>
<li>Compiler: <code>HttpRouteMatch::compile()</code> â†’ <code>Matcher&lt;HttpMessage, A&gt;</code></li>
<li>Integration tests with ext_proc fixtures</li>
</ul>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>See the <a href="https://github.com/mox-labs/x.uma">GitHub repository</a> for contribution guidelines.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace-2a3cd908.js"></script>
        <script src="mode-rust-2c9d5c9a.js"></script>
        <script src="editor-16ca416c.js"></script>
        <script src="theme-dawn-4493f9c8.js"></script>
        <script src="theme-tomorrow_night-9dbe62a9.js"></script>

        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
