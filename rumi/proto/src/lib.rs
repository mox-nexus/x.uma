//! Proto-generated types for x.uma — xDS + xuma extensions.
//!
//! Generated by `buf generate` using neoeinstein-prost + neoeinstein-prost-serde.
//! These types have both `prost::Message` (binary wire format) and
//! `serde::Serialize/Deserialize` (JSON config format) implementations.
//!
//! # Module structure
//!
//! - [`xds`] — Upstream xDS types (Matcher, StringMatcher, TypedExtensionConfig)
//! - [`xuma`] — x.uma extension types (domain inputs, contexts, actions)
//! - [`any_resolver`] — Decodes `Any` payloads into `TypedConfig` for registry use
//! - [`convert`] — Converts proto `Matcher` to `MatcherConfig<TypedConfig>`

#![allow(
    clippy::all,
    clippy::pedantic,
    rustdoc::all,
    unused_imports,
    unreachable_pub,
    non_camel_case_types
)]

pub mod any_resolver;
pub mod convert;

// ═══════════════════════════════════════════════════════════════════════════════
// Upstream xDS types
// ═══════════════════════════════════════════════════════════════════════════════

pub mod xds {
    pub mod core {
        pub mod v3 {
            include!("gen/xds/core/v3/xds.core.v3.rs");
        }
    }
    pub mod r#type {
        pub mod v3 {
            include!("gen/xds/r#type/v3/xds.type.v3.rs");
        }
        pub mod matcher {
            pub mod v3 {
                include!("gen/xds/r#type/matcher/v3/xds.type.matcher.v3.rs");
            }
        }
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// Transitive xDS dependency stubs
//
// CelExpression references cel::expr::ParsedExpr and
// google::api::expr::v1alpha1::ParsedExpr. These are stub types
// satisfying the structural requirements without pulling in the
// full CEL/Google API proto trees.
//
// When full CEL support is needed, generate with:
//   buf generate buf.build/google/cel-spec --path cel/expr --template buf.gen.rust.yaml
//   buf generate buf.build/googleapis/googleapis --path google/api/expr/v1alpha1 \
//     --path google/rpc/status.proto --template buf.gen.rust.yaml
// Then replace these stubs with the generated includes.
// ═══════════════════════════════════════════════════════════════════════════════

pub mod cel {
    pub mod expr {
        /// Stub for `cel.expr.ParsedExpr` (transitive xDS dependency).
        #[derive(Clone, PartialEq, ::prost::Message, serde::Serialize, serde::Deserialize)]
        pub struct ParsedExpr {
            #[prost(message, optional, tag = "2")]
            pub expr: ::core::option::Option<Expr>,
            #[prost(message, optional, tag = "3")]
            pub source_info: ::core::option::Option<SourceInfo>,
        }

        /// Stub for `cel.expr.CheckedExpr` (transitive xDS dependency).
        #[derive(Clone, PartialEq, ::prost::Message, serde::Serialize, serde::Deserialize)]
        pub struct CheckedExpr {
            #[prost(map = "int64, message", tag = "2")]
            pub reference_map: ::std::collections::HashMap<i64, Reference>,
            #[prost(map = "int64, message", tag = "3")]
            pub type_map: ::std::collections::HashMap<i64, Type>,
            #[prost(message, optional, tag = "4")]
            pub source_info: ::core::option::Option<SourceInfo>,
            #[prost(string, tag = "5")]
            pub expr_version: ::prost::alloc::string::String,
            #[prost(message, optional, tag = "6")]
            pub expr: ::core::option::Option<Expr>,
        }

        /// Minimal Expr stub.
        #[derive(Clone, PartialEq, ::prost::Message, serde::Serialize, serde::Deserialize)]
        pub struct Expr {}

        /// Minimal SourceInfo stub.
        #[derive(Clone, PartialEq, ::prost::Message, serde::Serialize, serde::Deserialize)]
        pub struct SourceInfo {}

        /// Minimal Reference stub.
        #[derive(Clone, PartialEq, ::prost::Message, serde::Serialize, serde::Deserialize)]
        pub struct Reference {}

        /// Minimal Type stub.
        #[derive(Clone, PartialEq, ::prost::Message, serde::Serialize, serde::Deserialize)]
        pub struct Type {}
    }
}

pub mod google {
    pub mod api {
        pub mod expr {
            pub mod v1alpha1 {
                /// Stub for `google.api.expr.v1alpha1.ParsedExpr`.
                #[derive(
                    Clone, PartialEq, ::prost::Message, serde::Serialize, serde::Deserialize,
                )]
                pub struct ParsedExpr {}

                /// Stub for `google.api.expr.v1alpha1.CheckedExpr`.
                #[derive(
                    Clone, PartialEq, ::prost::Message, serde::Serialize, serde::Deserialize,
                )]
                pub struct CheckedExpr {}
            }
        }
    }
    /// Well-known protobuf types (NullValue, Struct, etc.) via pbjson-types.
    pub mod protobuf {
        pub use prost_types::*;
    }
    pub mod rpc {
        /// Stub for `google.rpc.Status`.
        #[derive(Clone, PartialEq, ::prost::Message, serde::Serialize, serde::Deserialize)]
        pub struct Status {
            #[prost(int32, tag = "1")]
            pub code: i32,
            #[prost(string, tag = "2")]
            pub message: ::prost::alloc::string::String,
            #[prost(message, repeated, tag = "3")]
            pub details: ::prost::alloc::vec::Vec<prost_types::Any>,
        }
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// x.uma extension types
// ═══════════════════════════════════════════════════════════════════════════════

pub mod xuma {
    pub mod core {
        pub mod v1 {
            include!("gen/xuma/core/v1/xuma.core.v1.rs");
        }
    }
    pub mod http {
        pub mod v1 {
            include!("gen/xuma/http/v1/xuma.http.v1.rs");
        }
    }
    pub mod claude {
        pub mod v1 {
            include!("gen/xuma/claude/v1/xuma.claude.v1.rs");
        }
    }
    pub mod test {
        pub mod v1 {
            include!("gen/xuma/test/v1/xuma.test.v1.rs");
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn xds_string_matcher_exact_deserializes() {
        let json = r#"{"exact": "hello"}"#;
        let matcher: xds::r#type::matcher::v3::StringMatcher = serde_json::from_str(json).unwrap();
        assert!(matcher.match_pattern.is_some());
    }
}
